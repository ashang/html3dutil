<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<head>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="../extras/camera.js"></script>
<script type="text/javascript" src="frustum.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/

/**
* Finds the intersection point of three planes.
* @private
* @param {Array<number>} p1 A four-element array
* defining the first plane. The first three elements of the array
* are the X, Y, and Z components of the plane's normal vector, and
* the fourth element is the shortest distance from the plane
* to the origin, or if negative, from the origin to the plane,
* divided by the normal's length.
* @param {Array<number>} p2 A four-element array
* defining the second plane.
* @param {Array<number>} p3 A four-element array
* defining the third plane.
* @return {Array<number>} The intersection point, or
* null if all three planes meet at a line or any two planes
* are parallel.
*/
GLMath.planeIntersection=function(p1,p2,p3){
 var c23=GLMath.vec3cross(p2,p3);
 var d=GLMath.vec3dot(p1,c23);
 if(d==0){
  // no intersection point
  return null;
 }
 var c12=GLMath.vec3cross(p1,p2);
 var c31=GLMath.vec3cross(p3,p1)
 GLMath.vec3scaleInPlace(c23,-p1[3]);
 GLMath.vec3scaleInPlace(c31,-p2[3]);
 GLMath.vec3scaleInPlace(c12,-p3[3]);
 c23[0]+=c31[0]; c23[1]+=c31[1]; c23[2]+=c31[2];
 c23[0]+=c12[0]; c23[1]+=c12[1]; c23[2]+=c12[2];
 GLMath.vec3scaleInPlace(c23,1.0/d);
 return c23;
}
/**
* Normalizes this plane so that its normal is unit
* length (unless all the normal's components are 0).
* The plane's distance will be divided by the
* normal's length.
* @private
* @param {Array<number>} plane A four-element array
* defining the plane. The first three elements of the array
* are the X, Y, and Z components of the plane's normal vector, and
* the fourth element is the shortest distance from the plane
* to the origin, or if negative, from the origin to the plane,
* divided by the normal's length.
* @return {Array<number>} The parameter "plane".
*/
GLMath.planeNormInPlace=function(plane){
 var x=plane[0];
 var y=plane[1];
 var z=plane[2];
 var w=plane[3];
 len=Math.sqrt(x*x+y*y+z*z);
 if(len!=0){
  len=1.0/len;
  plane[0]*=len;
  plane[1]*=len;
  plane[2]*=len;
  plane[3]*=len;
 }
 return plane;
}

/**
* Gets the six clipping planes of a view frustum defined
* by a 4x4 matrix. These six planes together form the 
* shape of a "chopped-off" pyramid (or frustum).<p>
* In this model, the eye, or camera, is placed at the top
* of the pyramid, four planes are placed at the pyramid's
* sides, one plane (the far plane) forms its base, and a
* final plane (the near plane) is the pyramid's chopped
* off top.
* @private
* @param {Array<number>} A 4x4 matrix.  This will
* usually be a projection-view matrix (projection matrix
* multiplied by view matrix).
* @return {Array<Array<number>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.  All six planes
* will be normalized.
*/
GLMath.mat4toFrustumPlanes=function(matrix){
 var frustum=[[],[],[],[],[],[]]
 // Left clipping plane
 frustum[0]=GLMath.planeNormInPlace([
  matrix[3]  + matrix[0],
  matrix[7]  + matrix[4],
  matrix[11] + matrix[8],
  matrix[15] + matrix[12]
 ])
 // Right clipping plane
 frustum[1]=GLMath.planeNormInPlace([
  matrix[3]  - matrix[0],
  matrix[7]  - matrix[4],
  matrix[11] - matrix[8],
  matrix[15] - matrix[12]
 ])
 // Top clipping plane
 frustum[2]=GLMath.planeNormInPlace([
  matrix[3]  - matrix[1],
  matrix[7]  - matrix[5],
  matrix[11] - matrix[9],
  matrix[15] - matrix[13]
 ])
 // Bottom clipping plane
 frustum[3]=GLMath.planeNormInPlace([
  matrix[3]  + matrix[1],
  matrix[7]  + matrix[5],
  matrix[11] + matrix[9],
  matrix[15] + matrix[13]
 ])
 // Near clipping plane
 frustum[4]=GLMath.planeNormInPlace([
  matrix[3]  + matrix[2],
  matrix[7]  + matrix[6],
  matrix[11] + matrix[10],
  matrix[15] + matrix[14]
 ])
 // Far clipping plane
 frustum[5]=GLMath.planeNormInPlace([
  matrix[3]  - matrix[2],
  matrix[7]  - matrix[6],
  matrix[11] - matrix[10],
  matrix[15] - matrix[14]
 ])
 return frustum
}
/**
* Determines whether a sphere is at least
* partially inside a view frustum.
* @private
* @param {Array<Array<number>>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.
* @param {number} x X coordinate of the sphere's center
* in world space.
* @param {number} y Y coordinate of the sphere's center
* in world space.
* @param {number} z Z coordinate of the sphere's center
* in world space.
* @param {number} radius Radius of the sphere
* in world-space units.
* @return {boolean} <code>true</code> if the sphere 
* is partially or totally
* inside the frustum; <code>false</code> otherwise.
*/
GLMath.frustumHasSphere=function(frustum, x, y, z, radius){
 if(radius<0)throw new Error("radius is negative");
 for(var i=0;i<6;i++){
  var plane=frustum[i];
  var dot=plane[3]+plane[0]*x+
     plane[1]*y+plane[2]*z;
  if(dot<-radius)return false;
 }
 return true;
}

/**
* Determines whether an axis-aligned bounding box
* is at least partially inside a view frustum.
* @private
* @param {Array<Array<number>>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.
* @param {Array<number>} box An axis-aligned bounding
* box in world space, which is an array of six values.  
* The first three values are the smallest X, Y, and Z coordinates,
* and the last three values are the largest X, Y, and Z
* coordinates.
* @return {boolean} <code>true</code> if the box
* may be partially or totally
* inside the frustum; <code>false</code> if the box is
* definitely outside the frustum.
*/
GLMath.frustumHasBox=function(frustum, box){
 for(var i=0;i<6;i++){
  var plane=frustum[i];
  if( ((((plane[0] * box[0]) + plane[1] * box[1]) + plane[2] * box[2]) + plane[3])<=0.0 &&
      ((((plane[0] * box[3]) + plane[1] * box[4]) + plane[2] * box[5]) + plane[3])<=0.0 &&
      ((((plane[0] * box[0]) + plane[1] * box[4]) + plane[2] * box[2]) + plane[3])<=0.0 &&
      ((((plane[0] * box[0]) + plane[1] * box[4]) + plane[2] * box[5]) + plane[3])<=0.0 &&
      ((((plane[0] * box[0]) + plane[1] * box[1]) + plane[2] * box[5]) + plane[3])<=0.0 &&
      ((((plane[0] * box[3]) + plane[1] * box[4]) + plane[2] * box[2]) + plane[3])<=0.0 &&
      ((((plane[0] * box[3]) + plane[1] * box[1]) + plane[2] * box[2]) + plane[3])<=0.0 &&
      ((((plane[0] * box[3]) + plane[1] * box[1]) + plane[2] * box[5]) + plane[3])<=0.0){
    return false; 
  }
 }
 return true;
}


/**
* Determines whether a point is
* outside or inside a view frustum.
* @private
* @param {Array<Array<number>>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.
* @param {number} x X coordinate of a point
* in world space.
* @param {number} y Y coordinate of a point
* in world space.
* @param {number} z Z coordinate of a point
* in world space.
* @return {boolean} true if the point is inside;
* otherwise false;
*/
GLMath.frustumHasPoint=function(frustum, x, y, z){
 for(var i=0;i<6;i++){
  var d=frustum[i][0]*x+frustum[i][1]*y+
     frustum[i][2]*z+frustum[i][3];
  if(d<=0)return false;
 }
 return true;
}

/**
* Finds the coordinates of the corners
* of a view frustum's near clipping plane.
* @private
* @param {Array<Array<number>>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.
* @return {Array<number>} A 4-element array
* containing the 3-element points for the top-left,
* bottom-left, top-right, and bottom-right corners,
* respectively, of the near clipping plane.
*/
GLMath.frustumNearPlane=function(frustum){
 var topLeft=GLMath.planeIntersection(
  frustum[4],frustum[0],frustum[2]);
 var bottomLeft=GLMath.planeIntersection(
  frustum[4],frustum[0],frustum[3]);
 var topRight=GLMath.planeIntersection(
  frustum[4],frustum[1],frustum[2]);
 var bottomRight=GLMath.planeIntersection(
  frustum[4],frustum[1],frustum[3]);
 return [topLeft,bottomLeft,topRight,bottomRight];
}
/**
* Finds the coordinates of the corners
* of a view frustum's far clipping plane.
* @private
* @param {Array<Array<number>>} An array of six
* 4-element arrays representing the six clipping planes of the
* view frustum.  In order, they are the left, right, top,
* bottom, near, and far clipping planes.
* @return {Array<number>} A 4-element array
* containing the 3-element points for the top-left,
* bottom-left, top-right, and bottom-right corners,
* respectively, of the near clipping plane.
*/
GLMath.frustumFarPlane=function(frustum){
  var topLeft=GLMath.planeIntersection(
  frustum[5],frustum[0],frustum[2]);
 var bottomLeft=GLMath.planeIntersection(
  frustum[5],frustum[0],frustum[3]);
 var topRight=GLMath.planeIntersection(
  frustum[5],frustum[1],frustum[2]);
 var bottomRight=GLMath.planeIntersection(
  frustum[5],frustum[1],frustum[3]);
 return [topLeft,bottomLeft,topRight,bottomRight];
}

function perspectiveFrustum(fov,aspect,near,far,cameraPos,lookingAt){
 var proj=GLMath.mat4perspective(fov,aspect,near,far);
 var view=GLMath.mat4lookat(cameraPos,lookingAt)
 var projview=GLMath.mat4multiply(proj,view);
 var frustum=GLMath.mat4toFrustumPlanes(projview);
 return frustum;
}

Mesh.prototype.vertex3v=function(x){
 return this.vertex3(x[0],x[1],x[2]);
}

function frustumMesh(frustum){
 var mesh=new Mesh();
 var nearRect=GLMath.frustumNearPlane(frustum);
 var farRect=GLMath.frustumFarPlane(frustum);
 mesh.color3("yellow");
 mesh.mode(Mesh.LINES);
 mesh.vertex3v(nearRect[0]).vertex3v(farRect[0]);
 mesh.vertex3v(nearRect[1]).vertex3v(farRect[1]);
 mesh.vertex3v(nearRect[2]).vertex3v(farRect[2]);
 mesh.vertex3v(nearRect[3]).vertex3v(farRect[3]);
 mesh.mode(Mesh.LINE_STRIP)
 mesh.vertex3v(nearRect[0]).vertex3v(nearRect[1])
   .vertex3v(nearRect[3]).vertex3v(nearRect[2])
   .vertex3v(nearRect[0]);
 mesh.mode(Mesh.LINE_STRIP)
 mesh.vertex3v(farRect[0]).vertex3v(farRect[1])
   .vertex3v(farRect[3]).vertex3v(farRect[2])
   .vertex3v(farRect[0]);
 return mesh;
}

  // Create the 3D scene; find the HTML canvas and pass it
  // to Scene3D.
  var scene=new Scene3D(document.getElementById("canvas"));
  // Set the perspective view.  Camera has a 45-degree field of view
  // and will see objects from 0.1 to 100 units away.
  var camera=new Camera(scene,45,1,1000).setDistance(10);
  var frustum=perspectiveFrustum(45,scene.getClientAspect(),2,10,[0,0,10],[0,0,0]);
  var mesh=frustumMesh(frustum);
  var spheres=new ShapeGroup();
  var radius=0.3;
  var sphere=scene.makeShape(Meshes.createSphere(radius));
  for(var i=-10; i<=10;i++){
   var shape=sphere.copy().setPosition(1,-1,i)
   if(!GLMath.frustumHasSphere(frustum,1,-1,i,radius)){
    shape.setColor("red")
   }
    spheres.addShape(shape);
  }
  for(var i=-10; i<=10;i++){
   var shape=sphere.copy().setPosition(2,2,i)
   if(!GLMath.frustumHasSphere(frustum,2,2,i,radius)){
    shape.setColor("red")
   } else {
    shape.setColor("orange")
   }
    spheres.addShape(shape);
  }
  scene.addShape(scene.makeShape(mesh));
  scene.addShape(spheres);
  // Set up the render loop
  GLUtil.renderLoop(function(){
   camera.update();
   // Render the scene
   scene.render();
  });
//-->
</script>
<p>Controls: Drag with the mouse to move the scene; use the mouse
wheel to move the camera forward and back.</p>
<p>This demo contains a wireframe view volume of a perspective
projection and two rows of
spheres.  Note that initially, the spheres approach the center of the
screen as their depth increases.  As you move the scene with
your mouse, you will see how the spheres are placed in relation
to the projected view volume.  (Note that the view volume shown
is smaller than the one that results by the scene's actual projection,
in order to show the effect better.)  Spheres that would be clipped
out by the wireframe volume are colored red.</p>

</body>
