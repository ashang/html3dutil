<head>
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="../extras/camera.js"></script>
<script type="text/javascript" src="../extras/frame.js"></script>
<script type="text/javascript" src="../extras/path.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
<script src="https://peteroupc.github.io/colorpicker/cbox.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/

function makeFloor(xStart,yStart,width,height,tileSize,z){
 if(z==null)z=0.0
 var mesh=new Mesh()
 var tilesX=Math.ceil(width/tileSize)
 var tilesY=Math.ceil(height/tileSize)
 var lastY=(height-(tilesY*tileSize))/tileSize
 var lastX=(width-(tilesX*tileSize))/tileSize
 if(lastY<=0)lastY=1.0
 if(lastX<=0)lastX=1.0
 mesh.normal3(0,0,1)
 for(var y=0;y<tilesY;y++){
  var endY=(y==tilesY-1) ? 1.0-lastY : 0.0
  var endPosY=(y==tilesY-1) ? yStart+height : yStart+(y+1)*tileSize
  for(var x=0;x<tilesX;x++){
   var endX=(x==tilesX-1) ? lastX : 1.0
   var endPosX=(x==tilesX-1) ? xStart+width : xStart+(x+1)*tileSize
   mesh.mode(Mesh.TRIANGLE_STRIP)
     .texCoord2(0,1).vertex3(xStart+x*tileSize,yStart+y*tileSize,z)
     .texCoord2(0,endY).vertex3(xStart+x*tileSize,endPosY,z)
     .texCoord2(endX,1).vertex3(endPosX,yStart+y*tileSize,z)
     .texCoord2(endX,endY).vertex3(endPosX,endPosY,z)
  }
 }
 return mesh
}

function rotateVec(vec,angle){
 return GLMath.mat4transformVec3(
   GLMath.mat4rotated(angle,0,0,1),vec);
}

// Path taken from a public domain SVG icon, which was
// created by Jakub Steiner
var path=GraphicsPath.fromString(
"M 44.155643,23.75 C 44.155643,45.413332 45.663332,43.905643 24,43.905643 2.3366679,43.905643 3.8443565,45.413332 3.8443565,23.75 3.8443565,2.0866679 2.3366679,3.5943565 24,3.5943565 c 21.663332,0 20.155643,-1.5076886 20.155643,20.1556435 z"
)
var curves=path.getCurves(0.2)
function getPoints(curves, numPoints, offset){
 var points=[]
 for(var i=0;i<numPoints;i++){
  var t=i/(numPoints-1)+offset
  if(t>=0.0 && t<=1.0){
   var ev=curves.evaluate(t)
   points.push([ev[0],ev[1]])
  }
 }
 return points
}

function pointMarch(
  group, // shape group containing the marching points
  t // value from 0 to 1 specifying the point in time of the animation
){
 var POINTCOUNT=50
 var adjust=(t*(1.0/(POINTCOUNT-1)))
 var pts=getPoints(curves,POINTCOUNT,adjust)
 for(var i=0;i<pts.length;i++){
  if(!group.shapes[i])continue
  group.shapes[i].setVisible(true).setPosition(pts[i][0],pts[i][1],0)
 }
 for(var j=pts.length;j<POINTCOUNT;j++){
  if(!group.shapes[j])continue
  group.shapes[j].setVisible(false)
 }
}
var points=path.getPoints(50,0.2)

  var scene=new Scene3D(document.getElementById("canvas"));
  scene.setClearColor("white");
  var group=new ShapeGroup()
  scene.setDirectionalLight(0,[0,-3,1.2],[1,1,1])
  scene.setDirectionalLight(1,[0,3,1.2],[.6,.6,.6])
  scene.loadAndMapTextures(["461223191.jpg"]).then(function(results){
   if(results.failures.length>0)return
   var mesh=null
   var sphere=scene.makeShape(Meshes.createSphere(0.2,16,8)).setColor("blue")
   for(var i=0;i<50;i++){
    group.addShape(sphere.copy())
   }
   pointMarch(group,0)
   scene.addShape(
    scene.makeShape(makeFloor(0,0,50,50,10)).setColor("#eeeeee"))
   scene.addShape(group)
  })
  var anim=null
  var timer={}
  GLUtil.renderLoop(function(time){
   scene.setPerspective(45,scene.getClientAspect(),1,1000)
   scene.setLookAt([22.5,22.5-3*8,1.2*50],[22.5,22.5,0],[0,0,1])
   var t=GLUtil.getTimePosition(timer,time,1000)
   pointMarch(group,t)
   scene.render();
  });
//-->
</script>
</body>
