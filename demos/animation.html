<head>
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="../extras/camera.js"></script>
<script type="text/javascript" src="../extras/frame.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
<script src="https://peteroupc.github.io/colorpicker/cbox.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/

    function createWasher(inner,outer,height,slices){
      var innerCylinder=Meshes.createCylinder(inner,inner,height,slices,1,false,true);
      var outerCylinder=Meshes.createCylinder(outer,outer,height,slices,1,false,false);
      var base=Meshes.createDisk(inner,outer,slices,2,true).reverseWinding();
      var top=Meshes.createDisk(inner,outer,slices,2,false);
      // move the top disk to the top of the cylinder
      top.transform(GLMath.mat4translated(0,0,height));
      // merge the base and the top
      console.log(innerCylinder)
      return innerCylinder.merge(outerCylinder).merge(base).merge(top);
    }
function Animators(){
 this.list=[]
 this.curTime=0
}
Animators.prototype._ensure=function(shape){
 for(var i=0;i<this.list.length;i++){
  if(this.list[i].shape==shape)return this.list[i]
 }
 var anim=new Animator(shape)
 this.list.push(anim)
 return anim
}
Animators.prototype.startAt=function(time){
 this.curTime=time
 return this;
}
Animators.prototype.thenShow=function(shape){
 this._ensure(shape).setVisibleAt(true,this.curTime)
 return this;
}
Animators.prototype.thenShowAndMove=function(shape,x,y,z,x2,y2,z2,dur){
 return this.thenShow(shape).thenMove(shape,x,y,z,x2,y2,z2,dur)
}
Animators.prototype.thenMove=function(shape,x,y,z,x2,y2,z2,dur){
 this._ensure(shape).moveTo(x,y,z,x2,y2,z2,this.curTime,dur)
 this.curTime+=dur
 return this;
}
Animators.prototype.thenPause=function(time){
 this.curTime+=time
 return this;
}
Animators.prototype.update=function(time){
 for(var i=0;i<this.list.length;i++){
  this.list[i].update(time)
 }
}

function Animator(shape){
 this.shape=shape;
 this.positionAnim=[]
 this.visibleAnim=[]
}
Animator._compact=function(arr){
 var fillOffset=0
 var newLength=arr.length
 for(var i=0;i<arr.length;i++){
  if(fillOffset!=i && arr[i]!=null){
   arr[fillOffset]=arr[i]
   fillOffset++
  } else if(arr[i]!=null){
   fillOffset++
  }
 }
 arr.length=fillOffset
}
Animator.prototype.showAndMoveTo=function(
  x,y,z,x2,y2,z2,startInMs,durationInMs){
 return this.setVisibleAt(true,startInMs)
   .moveTo(x,y,z,x2,y2,z2,startInMs,durationInMs)
}
Animator.prototype.moveTo=function(
  x,y,z,x2,y2,z2,startInMs,durationInMs){
 this.positionAnim.push([
  [x,y,z],[x2,y2,z2],startInMs,startInMs+durationInMs])
 return this;
}
Animator.prototype.setVisibleAt=function(vis,timeInMs){
 this.visibleAnim.push([!!vis,timeInMs])
 return this;
}
Animator.prototype.update=function(time){
 var posChanged=false
 var visChanged=false
 for(var i=0;i<this.positionAnim.length;i++){
  var a=this.positionAnim[i]
  if(!a)continue
  if(time<a[2])continue // hasn't begun yet
  if(time>=a[3]){
   // finished
   this.shape.setPosition(a[1])
   this.positionAnim[i]=null
   posChanged=true
  } else {
   // in progress
   var t=(time-a[2])/(a[3]-a[2]);
   this.shape.setPosition(GLMath.vec3lerp(a[0],a[1],t));
  }
 }
 for(var i=0;i<this.visibleAnim.length;i++){
  var a=this.visibleAnim[i]
  if(!a)continue
  if(time>=a[1]){
   this.shape.setVisible(a[0])
   this.visibleAnim[i]=null
   visChanged=true
  }
 }
 if(posChanged)Animator._compact(this.positionAnim)
 if(visChanged)Animator._compact(this.visibleAnim)
}

  // Create the 3D scene; find the HTML canvas and pass it
  // to Scene3D.
  var scene=new Scene3D(document.getElementById("canvas"));
  scene.setClearColor("white");
  scene.setPerspective(45,scene.getClientAspect(),1,1000)
  scene.setLookAt([0,-3,1.2])
  scene.setDirectionalLight(0,[0,-3,1.2])
  var shapes=[]
  var shapecolors=["white","blue","red","green","brown","orange","purple"]
  var shapesizes=[1,0.9,0.8,0.7,0.6,0.7,0.8]
  for(var i=0;i<shapecolors.length;i++){
   var s=scene.makeShape(createWasher(0.5,shapesizes[i],0.1,32)).setColor(shapecolors[i])
     .setVisible(false)
   shapes.push(s)
   scene.addShape(s)
  }
  var xyz=new ShapeGroup();
  var axisline=scene.makeShape(Meshes.createCapsule(0.005,10,6,4));
  var zaxis=axisline.copy().setColor("blue")
  var yaxis=axisline.copy().setColor("green");
  yaxis.getTransform().setOrientation(90,1,0,0);
  var xaxis=axisline.copy().setColor("red");
  xaxis.getTransform().setOrientation(90,0,1,0);
  xyz.addShape(xaxis).addShape(yaxis).addShape(zaxis);
  scene.addShape(xyz)
  var anim=null
  GLUtil.renderLoop(function(time){
   if(!anim){
    anim=new Animators().startAt(time+200)
    for(var i=0;i<shapes.length;i++){
      anim.thenShowAndMove(shapes[i],0,0,4,0,0,0.1*i,1000)
    }
   } else {
    anim.update(time)
   }
   scene.render();
  });
//-->
</script>
</body>
