<meta charset=utf-8>
<head>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/

/**
* Updates the position of a particle using Verlet integration.
* @param {Array<number>} particle Information on a single particle in
* the form of an array of nine numbers as follows:<ul>
* <li>The first three numbers are the X, Y, and Z coordinates
* of the particle's position.
* <li>The next three numbers are the X, Y, and Z coordinates
* of the particle's previous position.
* <li>The last three numbers are the X, Y, and Z components
* of the particle's acceleration (force divided by mass).
* @param {number} timeStep Time step for integration.  This is usually
* a fractional number of seconds.
*/
GLMath.integrateVerlet=function(particle, timeStep){
 // update each position
 var x=particle[0];
 var y=particle[1];
 var z=particle[2];
 particle[0]+=particle[6]*timeStep+particle[0]-particle[3];
 particle[1]+=particle[7]*timeStep+particle[1]-particle[4];
 particle[2]+=particle[8]*timeStep+particle[2]-particle[5];
 particle[3]=x;
 particle[4]=y;
 particle[5]=z;
}
GLMath.integrateVerletWithFriction=function(particle, friction, timeStep){
 // update each position
 var x=particle[0];
 var y=particle[1];
 var z=particle[2];
 particle[0]+=particle[6]*timeStep+friction*(particle[0]-particle[3]);
 particle[1]+=particle[7]*timeStep+friction*(particle[1]-particle[4]);
 particle[2]+=particle[8]*timeStep+friction*(particle[2]-particle[5]);
 particle[3]=x;
 particle[4]=y;
 particle[5]=z;
}

GLMath.constrainPointToBox=function(p, radius, pointIndex, bounds){
 var xmin=bounds[0]+radius;
 var xmax=bounds[3]-radius;
 var ymin=bounds[1]+radius;
 var ymax=bounds[4]-radius;
 var zmin=bounds[2]+radius;
 var zmax=bounds[5]-radius;
 p[pointIndex]=Math.min(xmax,Math.max(p[pointIndex],xmin));
 p[pointIndex+1]=Math.min(ymax,Math.max(p[pointIndex+1],ymin));
 p[pointIndex+2]=Math.min(zmax,Math.max(p[pointIndex+2],zmin));
}

function CubicBody(radius, mass, x, y, z){
 this.divmass=1.0/mass;
 this.particle=[x,y,z,x,y,z,0,-30*this.divmass,0];
 this.radius=radius;
 this.mass=mass;
}
CubicBody.prototype.x=function(){
 return this.particle[0];
}
CubicBody.prototype.y=function(){
 return this.particle[1];
}
CubicBody.prototype.z=function(){
 return this.particle[2];
}
CubicBody.prototype.constrainToBox=function(bounds){
 GLMath.constrainPointToBox(this.particle,this.radius,0,bounds);
}
CubicBody.prototype.integrate=function(timeStep){
 GLMath.integrateVerlet(this.particle,timeStep);
}

function Particles(scene,count,width,height){
 this.shapes=new ShapeGroup();
 var sphere=scene.makeShape(Meshes.createSphere(1,64,64));
 this.bodies=[];
 this.bounds=[0,0,-5000,width,height,5000];
 for(var i=0;i<count;i++){
  var p=[];
  var mass=Math.random()*6+1;
  p[0]=Math.random()*width;
  p[1]=Math.random()*height;
  p[2]=0;
  var scale=(scene.getWidth()/100)*mass;
  GLMath.constrainPointToBox(p,scale,0,this.bounds);
  this.bodies.push(new CubicBody(scale,mass,p[0],p[1],p[2]));
  var shape=sphere.copy();
  shape.setScale(scale,scale,scale);
  shape.setPosition(p);
  shape.setColor([Math.random(),Math.random(),Math.random()]);
  this.shapes.addShape(shape);
 }
 scene.addShape(this.shapes);
 this.timeInfo={};
}
Particles.prototype.update=function(time){
 var timeStep=GLUtil.newFrames(this.timeInfo,time)/60;
 for(var i=0;i<this.bodies.length;i++){
  var body=this.bodies[i];
  body.integrate(timeStep);
  body.constrainToBox(this.bounds);
  this.shapes.shapes[i].setPosition(body.x(),body.y(),body.z());
 }
}

  // Create the 3D scene; find the HTML canvas and pass it
  // to Scene3D.
  var scene=new Scene3D(document.getElementById("canvas"))
   .setClearColor("white")
  scene.setOrtho(0,scene.getWidth(),0,scene.getHeight(),-5000,5000);
  var tris=new Particles(scene,10,scene.getWidth(),scene.getHeight());
  // Set up the render loop
  GLUtil.renderLoop(function(time){
   tris.update(time);
   // Render the scene
   scene.render();
  });
//-->
</script>
</body>
