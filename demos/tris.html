<head><meta charset=utf-8><meta name="viewport" content="user-scalable=no,initial-scale=1,maximum-scale=1">
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../h3du_min.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
/* global H3DU */
// <!--
/*
 Any copyright to this file is released to the Public Domain.
 http://creativecommons.org/publicdomain/zero/1.0/
 If you like this, you should donate
 to Peter O. (original author of
 the Public Domain HTML 3D Library) at:
 http://peteroupc.github.io/
*/

function TriangleParticles(scene, count, w, h) {
  "use strict";
  this.tris = [];
  this.width = w;
  this.scene = scene;
  this.timer = {};
  this.height = h;
  var triVertices=[]
  for(var i = 0; i < count; i++) {
    var tri = TriangleParticles.generateTri(this.width, this.height);
    this.tris[i] = tri;
    triVertices.push(
tri.position[0],tri.position[1],tri.position[2],0,0,1,
tri.color[0],tri.color[1],tri.color[2],
tri.position[3],tri.position[4],tri.position[5],0,0,1,
tri.color[0],tri.color[1],tri.color[2],
tri.position[6],tri.position[7],tri.position[8],0,0,1,
tri.color[0],tri.color[1],tri.color[2])
  }
  this.group=H3DU.MeshBuffer.fromPositionsColors(triVertices)
}
TriangleParticles.prototype.update = function(time) {
  "use strict";
  var frames = H3DU.newFrames(this.timer, time);
  var attr=this.group.getAttribute("POSITION")
  var attrcolor=this.group.getAttribute("COLOR")
  var vec=[]
  for(var i = 0; i < this.tris.length; i++) {
    this.tris[i].life -= frames;
    if(this.tris[i].life <= 0) {
      var tri = TriangleParticles.generateTri(this.width, this.height);
      this.tris[i] = tri;
      // NOTE: No rotation here
      attr.setXyz(i*3,tri.position[0],tri.position[1],tri.position[2])
          .setXyz(i*3+1,tri.position[3],tri.position[4],tri.position[5])
          .setXyz(i*3+2,tri.position[6],tri.position[7],tri.position[8])
      attrcolor.setVec(i*3,tri.color)
          .setVec(i*3+1,tri.color)
          .setVec(i*3+2,tri.color)
    } else {
      var trans = H3DU.MathUtil.mat4translated(
         H3DU.MathUtil.vec3scale(this.tris[i].movement, frames));
      trans=H3DU.MathUtil.mat4rotate(trans,
         this.tris[i].rotation * frames, 0, 0, 1);
      attr.getVec(i*3,vec)
      attr.setVec(i*3,H3DU.MathUtil.mat4transformVec3(vec))
      attr.getVec(i*3+1,vec)
      attr.setVec(i*3+1,H3DU.MathUtil.mat4transformVec3(vec))
      attr.getVec(i*3+2,vec)
      attr.setVec(i*3+2,H3DU.MathUtil.mat4transformVec3(vec))
    }
  }
};
// Calculates the area of a triangle
TriangleParticles._getArea = function(tri) {
  "use strict";
  var tx = [tri[0] - tri[3], tri[1] - tri[4], tri[2] - tri[5]];
  var ty = [tri[6] - tri[3], tri[7] - tri[4], tri[8] - tri[5]];
  var tz = H3DU.MathUtil.vec3cross(tx, ty);
  return H3DU.MathUtil.vec3length(tz) * 0.5;
};

TriangleParticles.generateTri = function(width, height) {
  "use strict";
  var xpos = Math.random() * (width + 10) - 5;
  var ypos = Math.random() * (height + 10) - 5;
  var maxw = 100;
  var maxh = 100;
  var pos;
  do {
    pos = [
      Math.random() * maxw - maxw / 2,
      Math.random() * maxh - maxh / 2,
      0,
      Math.random() * maxw - maxw / 2,
      Math.random() * maxh - maxh / 2,
      0,
      Math.random() * maxw - maxw / 2,
      Math.random() * maxh - maxh / 2,
      0];
  } while(TriangleParticles._getArea(pos) < 200);
  var dx = Math.random() * 10 - 5;
  var dy = Math.random() * 10 - 5;
  var rotation = Math.floor(Math.random() * 10) - 5;
  var life = Math.floor(Math.random() * 200);
  var r = Math.random();
  var g = Math.random();
  var b = Math.random();
  return {
    "center":[xpos, ypos, 0],
    "position":pos,
    "rotation":rotation,
    "movement":[dx, dy, 0],
    "color":[r, g, b],
    "life":life
  };
};
// -->
</script>
</body>
