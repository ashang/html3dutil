<head><meta name="viewport" content="user-scalable=no,initial-scale=1,maximum-scale=1">
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="../extras/frame.js"></script>
<script type="text/javascript" src="../extras/path.js"></script>
<script type="text/javascript" src="../extras/pathclip.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/

function circle(path,x,y,radius){
 return path.moveTo(x,y-radius)
   .arcTo(x+radius,y-radius,x+radius,y,radius)
   .arcTo(x+radius,y+radius,x,y+radius,radius)
   .arcTo(x-radius,y+radius,x-radius,y,radius)
   .arcTo(x-radius,y-radius,x,y-radius,radius)
   .closePath()
}
path=circle(new GraphicsPath(),15,15,15)
path2=circle(new GraphicsPath(),30,15,15)
path=path.union(path2,0.2)
var curves=path.getCurves(0.2)
function getPoints(curves, numPoints, offset){
 var points=[]
 for(var i=0;i<numPoints;i++){
  var t=i/(numPoints-1)+offset
  if(t>=0.0 && t<=1.0){
   var ev=curves.evaluate(t)
   points.push([ev[0],ev[1]])
  }
 }
 return points
}

function pathFloor(path, z, flatness){
 if(z==null)z=0
 var tris=path.getTriangles(flatness);
 var mesh=new Mesh().mode(Mesh.TRIANGLES)
   .normal3(0,0,1);
 for(var i=0;i<tris.length;i++){
  var tri=tris[i]
  mesh.vertex3(tri[0],tri[1],z)
   .vertex3(tri[2],tri[3],z)
   .vertex3(tri[4],tri[5],z)
 }
 return mesh
}
function pointMarch(
  group, // shape group containing the marching points
  curves, // curves of the path
  t // value from 0 to 1 specifying the point in time of the animation
){
 var POINTCOUNT=50
 var adjust=(t*(1.0/(POINTCOUNT-1)))
 var pts=getPoints(curves,POINTCOUNT,adjust)
 for(var i=0;i<pts.length;i++){
  if(!group.shapes[i])continue
  group.shapes[i].setVisible(true).setPosition(pts[i][0],pts[i][1],0)
 }
 for(var j=pts.length;j<POINTCOUNT;j++){
  if(!group.shapes[j])continue
  group.shapes[j].setVisible(false)
 }
}
var points=path.getPoints(50,0.2)

  var scene=new Scene3D(document.getElementById("canvas"));
  scene.setClearColor("white");
  var fc=new FrameCounterDiv(scene)
  var group=new ShapeGroup()
  scene.setDirectionalLight(0,[0,-3,1.2],[1,1,1])
  scene.setDirectionalLight(1,[0,3,1.2],[.6,.6,.6])
   var mesh=null
   var sphere=scene.makeShape(Meshes.createSphere(0.2,16,8)).setColor("blue")
   for(var i=0;i<50;i++){
    group.addShape(sphere.copy())
   }
   scene.addShape(
    scene.makeShape(pathFloor(path)).setColor("#eeeeee"))
   scene.addShape(group)
  var anim=null
  var timer={}
  GLUtil.renderLoop(function(time){
   scene.setPerspective(45,scene.getClientAspect(),1,1000)
   scene.setLookAt([22.5,22.5-3*8,1.2*50],[22.5,22.5,0],[0,0,1])
   var t=GLUtil.getTimePosition(timer,time,1000)
   pointMarch(group,curves,t)
   fc.update()
   scene.render();
  });
//-->
</script>
</body>
