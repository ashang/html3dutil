<head><meta name="viewport" content="user-scalable=no,initial-scale=1,maximum-scale=1">
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../h3du_min.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<script id="vertex" type="x-shader/x-shader">
precision highp float;
attribute vec3 position;
varying vec2 posVar;
void main(){
 posVar=position.xy;
 gl_Position=vec4(position,1.0);
}
</script>
<script id="fragment" type="x-shader/x-shader">
precision highp float;
varying vec2 posVar;
uniform float u_time;
// NOTE: The online Book of Shaders, chapter 10, has
// a very good explanation on how this function works.
// The following was inspired by that chapter.
float rand(vec2 seed){
 float sinParameter=dot(seed,vec2(50.987,33.123));
 return fract(12345.43*sin(sinParameter));
}
float rand(float seed){
 float sinParameter=dot(vec2(seed),vec2(50.987,33.123));
 return fract(12345.43*sin(sinParameter));
}
float smootherstep(float a, float b, float f){
 return a+((10.0+f*(f*6.0-15.0))*f*f*f)*(b-a);
}
vec2 smootherstep(float a, float b, vec2 f){
 return a+((10.0+f*(f*6.0-15.0))*f*f*f)*(b-a);
}
float noise(float seed){
 float f=smootherstep(0.0,1.0,fract(seed));
 float fl=floor(seed);
 return mix(rand(fl),rand(fl+1.0),f);
}
float noise(vec2 seed){
 vec2 f=smootherstep(0.0,1.0,fract(seed));
 vec2 zo=vec2(0.0,1.0);
 vec2 fl=floor(seed);
 float r1=rand(fl+zo.xx);
 float r2=rand(fl+zo.xy);
 float r3=rand(fl+zo.yx);
 float r4=rand(fl+zo.yy);
 return mix(mix(r1,r3,f.x),mix(r2,r4,f.x),f.y);
}
float fbm(vec2 x, float freq, float amp, float lac, float gain){
 float ret=0.0;
 for(int i=0;i<6;i++){ // 6 octaves, or iterations
   ret+=noise(x*freq)*amp;
   amp*=gain;
   freq*=lac;
 }
 return ret;
}
vec3 palette(vec3 offset, vec3 scale, vec3 c, vec3 d, float t){
 // See <http://www.iquilezles.org/www/articles/palettes/palettes.htm>
  return cos((c*t+d)*6.283185307)*scale+offset;
}
vec3 palette(vec3 c, vec3 d, float t){
  return cos((c*t+d)*6.283185307)*0.5+0.5;
}
float fbmwarp(vec2 x, float freq, float amp, float lac, float gain){
 // See "Domain Warping" in The Book of Shaders, chapter 13
 float ret=fbm(x,freq,amp,lac,gain);
 ret=fbm(ret+x,freq,amp,lac,gain);
 ret=fbm(ret+x,freq,amp,lac,gain);
 return ret;
}
void main(){
 float n;
 n=fbmwarp(posVar+u_time*0.1,2.5,0.8,3.0,0.3);
 vec3 color=palette(vec3(1.0,0.8,0.6),vec3(0.5,0.65,0.75),n);
 gl_FragColor=vec4(color,1.0);
}
</script>

<script id="demo">
/* global H3DU */
var vertexShader = document.getElementById("vertex").textContent;
var fragmentShader = document.getElementById("fragment").textContent;

var scene = new H3DU.Scene3D(document.getElementById("canvas"))
 .setClearColor("white");
var shader = new H3DU.ShaderInfo(vertexShader, fragmentShader);
shader.setUniforms({"u_time":0});
// Create a quad to fill the frame buffer
var batch = new H3DU.Batch3D().addShape(
  new H3DU.Shape(new H3DU.Mesh(
    [-1, 1, 0, -1, -1, 0,
      1, 1, 0, 1, -1, 0],
     [0, 1, 2, 2, 1, 3], 0)).setShader(shader));
// Create a square-sized frame buffer info
var fbo = new H3DU.FrameBufferInfo(512, 512);
// Render to the frame buffer
scene.render([
  new H3DU.RenderPass3D(batch, {
    "frameBuffer":fbo,
    "useFrameBufferSize":true
  })
]);
// //////////////////////////////////////////////////////
var b2 = new H3DU.Batch3D()
   .perspectiveAspect(45, 0.1, 100)
   .setLookAt([0, 0, 40]);
b2.getLights().setBasic();
var mesh = H3DU.Meshes.createBox(10, 20, 20);
var shape = new H3DU.Shape(mesh).setTexture(fbo);
b2.addShape(shape);
   // Create a timer
var timer = {};
  // Set up the render loop
H3DU.renderLoop(function(time) {
  "use strict";
   // Update the shape's rotation
  var q = H3DU.Math.quatFromTaitBryan(
        360 * H3DU.getTimePosition(timer, time, 6000),
       360 * H3DU.getTimePosition(timer, time, 12000),
       0
      );
  shape.setQuaternion(q);
  scene.render(b2);
});
</script>
</body>
