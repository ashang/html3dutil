<head><meta name="viewport" content="user-scalable=no,initial-scale=1,maximum-scale=1">
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../h3du_min.js"></script>
<script type="text/javascript" src="../extras/frame.js"></script>
<script type="text/javascript" src="../extras/curvetube.js"></script>
<script type="text/javascript" src="../extras/path.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<canvas id=canvas></canvas>
<div style="position:absolute;left:0;top:0;width:25%">Involute and evolute of an ellipse</div>
<script id="demo">
/* global H3DU */
// <!--
/*
 Any copyright to this file is released to the Public Domain.
 http://creativecommons.org/publicdomain/zero/1.0/
 If you like this, you should donate
 to Peter O. (original author of
 the Public Domain HTML 3D Library) at:
 http://peteroupc.github.io/
*/

function makeCurvePath(curve) {
  "use strict";
  var ce = new H3DU.CurveEval();
  var mesh = new H3DU.Mesh();
  ce.vertex(curve);
  ce.evalCurve(mesh, H3DU.Mesh.LINES, 60);
  return mesh;
}

var _vecNormInPlaceAndScale = function(vec, scale) {
  "use strict";
  var len = 0;
  for(var i = 0; i < vec.length; i++) {
    len += vec[i] * vec[i];
  }
  len = Math.sqrt(len);
  if(len !== 0) {
    var newscale = 1.0 / len * scale;
    for(i = 0; i < vec.length; i++) {
      vec[i] *= newscale;
    }
  } else {
    for(i = 0; i < vec.length; i++) {
      vec[i] *= scale;
    }
  }
  return vec;
};
var _vecAdd = function(v1, v2) {
  "use strict";
  var ret = [];
  for(var i = 0; i < v1.length; i++) {
    ret[i] = v1[i] + v2[i];
  }
  return ret;
};
var _vecScale = function(v1, s) {
  "use strict";
  var ret = [];
  for(var i = 0; i < v1.length; i++) {
    ret[i] = v1[i] * s;
  }
  return ret;
};
function curveInvolute(evaluator) {
  "use strict";
  var neweval = H3DU.CurveEval.wrapEvaluator(evaluator);
  return {
    "evaluate":function(u) {
      var arclen = neweval.arcLength(u);
      var tangent = neweval.tangent(u);
      var position = neweval.evaluate(u);
      return _vecAdd(position,
          _vecNormInPlaceAndScale(tangent, -arclen));
    },
    "endPoints":function() {
      return neweval.endPoints();
    }
  };
}
function curveEvolute(evaluator) {
  "use strict";
  var neweval = H3DU.CurveEval.wrapEvaluator(evaluator);
  return {
    "evaluate":function(u) {
      var position = neweval.evaluate(u);
      var tangent = neweval.tangent(u);
      var accel = neweval.accel(u);
      var denom = tangent[0] * accel[1] - accel[0] * tangent[1];
      var numpart = tangent[0] * tangent[0] + tangent[1] * tangent[1];
      return [
        position[0] - numpart * tangent[1] / denom,
        position[1] + numpart * tangent[0] / denom,
        0
      ];
    },
    "endPoints":function() {
      return neweval.endPoints();
    }
  };
}

/* exported ruledSurface */
function ruledSurface(directrix, director) {
  "use strict";
  return H3DU.SurfaceEval.wrapEvaluator({
    "evaluate":function(u, v) {
      var dx = directrix.evaluate(u);
      var dr = _vecScale(director.evaluate(u), v);
      return _vecAdd(dx, dr);
    },
    "endPoints":function() {
      var ep = H3DU.CurveEval.findEndPoints(directrix);
      return [ep[0], ep[1], 0, 1];
    }
  });
}

var simpleCurve = {
  "evaluate":function(u) {
    "use strict";
    return [Math.cos(u) * 1.5, Math.sin(u) * 0.8, 0];
  },
  "endPoints":function() {
    "use strict"; return [0, Math.PI * 2];
  }
};

var scene = new H3DU.Scene3D(document.getElementById("canvas"));
scene.setClearColor("white");
var sub = new H3DU.Batch3D()
   .perspectiveAspect(45, 1, 1000)
   .setLookAt([0, 0, 10]);
  // var fc = new H3DU.FrameCounterDiv();
var group = new H3DU.ShapeGroup();
sub.getLights().setBasic();
var mesh = makeCurvePath(simpleCurve);
sub.addShape(
    new H3DU.Shape(mesh).setMaterial(H3DU.Material.fromBasic("blue")));
mesh = makeCurvePath(curveInvolute(simpleCurve));
sub.addShape(
    new H3DU.Shape(mesh).setMaterial(H3DU.Material.fromBasic("red")));
mesh = makeCurvePath(curveEvolute(simpleCurve));
sub.addShape(
    new H3DU.Shape(mesh).setMaterial(H3DU.Material.fromBasic("green")));
sub.addShape(group);
H3DU.renderLoop(function() {
  "use strict";
  scene.render(sub);
});
// -->
</script>
</body>
