### Members

* [A](#extras_camera_InputTracker.A)<br>Key code for the A key.
* [ADD](#extras_camera_InputTracker.ADD)<br>Key code for the plus key.
* [ALT](#extras_camera_InputTracker.ALT)<br>Key code for the return key.
* [BITANGENT](#Semantic.BITANGENT)<br>Attribute semantic for a bitangent vector.
* [COLOR](#Semantic.COLOR)<br>Attribute semantic for a color.
* [CTRL](#extras_camera_InputTracker.CTRL)<br>Key code for the return key.
* [CUSTOM](#Semantic.CUSTOM)<br>Attribute semantic for custom attributes.
* [DELETE](#extras_camera_InputTracker.DELETE)<br>Key code for the delete key.
* [DIVIDE_BIT](#H3DU.BSplineCurve.DIVIDE_BIT)<br>Indicates to divide each other coordinate of the returned point
by the last coordinate of the point and omit the last
coordinate.
* [DOWN](#extras_camera_InputTracker.DOWN)<br>Key code for the down arrow key.
* [END](#extras_camera_InputTracker.END)<br>Key code for the end key.
* [ENTER](#extras_camera_InputTracker.ENTER)<br>Key code for the enter key.
* [ESC](#extras_camera_InputTracker.ESC)<br>Key code for the return key.
* [GlobalPitchRollYaw](#H3DU.MathUtil.GlobalPitchRollYaw)<br>Indicates that a vector's rotation occurs as a pitch, then roll, then yaw (each rotation around the original axes).
* [GlobalPitchYawRoll](#H3DU.MathUtil.GlobalPitchYawRoll)<br>Indicates that a vector's rotation occurs as a pitch, then yaw, then roll (each rotation around the original axes),
or in the reverse order around
* [GlobalRollPitchYaw](#H3DU.MathUtil.GlobalRollPitchYaw)<br>Indicates that a vector's rotation occurs as a roll, then pitch, then yaw (each rotation around the original axes).
* [GlobalRollYawPitch](#H3DU.MathUtil.GlobalRollYawPitch)<br>Indicates that a vector's rotation occurs as a roll, then yaw, then pitch (each rotation around the original axes).
* [GlobalYawPitchRoll](#H3DU.MathUtil.GlobalYawPitchRoll)<br>Indicates that a vector's rotation occurs as a yaw, then pitch, then roll (each rotation around the original axes).
* [GlobalYawRollPitch](#H3DU.MathUtil.GlobalYawRollPitch)<br>Indicates that a vector's rotation occurs as a yaw, then roll, then pitch (each rotation around the original axes).
* [HOME](#extras_camera_InputTracker.HOME)<br>Key code for the home key.
* [HalfPi](#H3DU.MathUtil.HalfPi)<br>Closest approximation to pi divided by 2, or a 90-degree turn in radians.
* [JOINT](#Semantic.JOINT)<br>Attribute semantic for a skinning joint.
* [JOINTMATRIX](#Semantic.JOINTMATRIX)<br>Uniform semantic for a joint matrix.
* [LEFT](#extras_camera_InputTracker.LEFT)<br>Key code for the left arrow key.
* [LINES](#H3DU.MeshBuffer.LINES)<br>TODO: Not documented yet.
* [LocalPitchRollYaw](#H3DU.MathUtil.LocalPitchRollYaw)<br>Indicates that a vector's rotation occurs as a pitch, then roll, then yaw, where the roll and yaw
occur around the rotated object's new axes and not necessarily the original axes.
* [LocalPitchYawRoll](#H3DU.MathUtil.LocalPitchYawRoll)<br>Indicates that a vector's rotation occurs as a pitch, then yaw, then roll, where the yaw and roll
occur around the rotated object's new axes and not necessarily the original axes.
* [LocalRollPitchYaw](#H3DU.MathUtil.LocalRollPitchYaw)<br>Indicates that a vector's rotation occurs as a roll, then pitch, then yaw, where the pitch and yaw
occur around the rotated object's new axes and not necessarily the original axes.
* [LocalRollYawPitch](#H3DU.MathUtil.LocalRollYawPitch)<br>Indicates that a vector's rotation occurs as a roll, then yaw, then pitch, where the yaw and pitch
occur around the rotated object's new axes and not necessarily the original axes.
* [LocalYawPitchRoll](#H3DU.MathUtil.LocalYawPitchRoll)<br>Indicates that a vector's rotation occurs as a yaw, then pitch, then roll, where the pitch and roll
occur around the rotated object's new axes and not necessarily the original axes.
* [LocalYawRollPitch](#H3DU.MathUtil.LocalYawRollPitch)<br>Indicates that a vector's rotation occurs as a yaw, then roll, then pitch, where the roll and pitch
occur around the rotated object's new axes and not necessarily the original axes.
* [MODEL](#Semantic.MODEL)<br>Uniform semantic for a model matrix.
* [MODELVIEW](#Semantic.MODELVIEW)<br>Uniform semantic for a model-view matrix.
* [MODELVIEWINVERSETRANSPOSE](#Semantic.MODELVIEWINVERSETRANSPOSE)<br>Uniform semantic for the inverse of the 3x3 transpose of the model-view matrix.
* [MODELVIEWPROJECTION](#Semantic.MODELVIEWPROJECTION)<br>Uniform semantic for a model-view-projection matrix.
* [NORMAL](#Semantic.NORMAL)<br>Attribute semantic for a vertex normal.
* [Num180DividedByPi](#H3DU.MathUtil.Num180DividedByPi)<br>Closest approximation to 180 divided by pi, or the number of
degrees in a radian.
* [PAGEDOWN](#extras_camera_InputTracker.PAGEDOWN)<br>Key code for the page down key.
* [PAGEUP](#extras_camera_InputTracker.PAGEUP)<br>Key code for the page up key.
* [POINTS](#H3DU.MeshBuffer.POINTS)<br>TODO: Not documented yet.
* [POSITION](#Semantic.POSITION)<br>Attribute semantic for a vertex position.
* [PROJECTION](#Semantic.PROJECTION)<br>Uniform semantic for a projection matrix.
* [PiDividedBy180](#H3DU.MathUtil.PiDividedBy180)<br>Closest approximation to pi divided by 180, or the number
of radians in a degree.
* [PiTimes2](#H3DU.MathUtil.PiTimes2)<br>Closest approximation to pi times 2, or a 360-degree turn in radians.
* [RETURN](#extras_camera_InputTracker.RETURN)<br>Key code for the return key.
* [RIGHT](#extras_camera_InputTracker.RIGHT)<br>Key code for the right arrow key.
* [SHIFT](#extras_camera_InputTracker.SHIFT)<br>Key code for the shift key.
* [SPACE](#extras_camera_InputTracker.SPACE)<br>Key code for the space bar.
* [SUBTRACT](#extras_camera_InputTracker.SUBTRACT)<br>Key code for the minus key.
* [TAB](#extras_camera_InputTracker.TAB)<br>Key code for the tab key.
* [TANGENT](#Semantic.TANGENT)<br>Attribute semantic for a tangent vector.
* [TEXCOORD](#Semantic.TEXCOORD)<br>Attribute semantic for a texture coordinate.
* [TRIANGLES](#H3DU.MeshBuffer.TRIANGLES)<br>TODO: Not documented yet.
* [ToDegrees](#H3DU.MathUtil.ToDegrees)<br>Closest approximation to 180 divided by pi, or the number of
degrees in a radian.
* [ToRadians](#H3DU.MathUtil.ToRadians)<br>Closest approximation to pi divided by 180, or the number
of radians in a degree.
* [UP](#extras_camera_InputTracker.UP)<br>Key code for the up arrow key.
* [VIEW](#Semantic.VIEW)<br>Uniform semantic for a view matrix.
* [VIEWINVERSE](#Semantic.VIEWINVERSE)<br>Uniform semantic for an inverse view matrix.
* [WEIGHT](#Semantic.WEIGHT)<br>Attribute semantic for a skinning weight.
* [ZERO](#extras_camera_InputTracker.ZERO)<br>Key code for the 0 key.
* [buffer](#H3DU.BufferAccessor_buffer)<br>A <i>buffer</i> of arbitrary size.
* [checkerboardShader](#extras_checkerboardshader.checkerboardShader)<br>TODO: Not documented yet.
* [colorMatrixShader](#extras_colormatrixshader.colorMatrixShader)<br>GLSL shader data for a family of image processing filters, which modify colors based on a transformation matrix, a 4x4 matrix that is multiplied by the red/green/blue color to get a new color.
* [countPerValue](#H3DU.BufferAccessor_countPerValue)<br>A count of the number of elements each value has.
* [deltaXY](#extras_camera_InputTracker_deltaXY)<br>**Deprecated: Yes**
* [horGradientShader](#extras_horgradshader.horGradientShader)<br>TODO: Not documented yet.
* [kernelMatrixShader](#extras_kernelmatrixshader.kernelMatrixShader)<br>GLSL shader code for a family of image processing filters, such as blurring, sharpening,
edge detection, and embossing, that process each pixel and its neighbors.
* [leftButton](#extras_camera_InputTracker_leftButton)<br>True if the left mouse button was detected as being down.
* [marbleShader](#extras_marbleshader.marbleShader)<br>TODO: Not documented yet.
* [marbleShader2](#extras_marbleshader2.marbleShader2)<br>TODO: Not documented yet.
* [middleButton](#extras_camera_InputTracker_middleButton)<br>True if the middle mouse button was detected as being down.
* [mirrorShader](#extras_mirrorshader.mirrorShader)<br>TODO: Not documented yet.
* [offset](#H3DU.BufferAccessor_offset)<br>An offset, which identifies the index, starting from 0, of the first value
of the attribute within the buffer.
* [pixelateShader](#extras_pixelateshader.pixelateShader)<br>TODO: Not documented yet.
* [radialGradientShader](#extras_radgradshader.radialGradientShader)<br>TODO: Not documented yet.
* [rightButton](#extras_camera_InputTracker_rightButton)<br>True if the right mouse button was detected as being down.
* [shapes](#H3DU.ShapeGroup_shapes)<br>**Deprecated: Use the ShapeGroup#shapeCount,
ShapeGroup#getShape, and
ShapeGroup#setShape methods instead.**
* [skySphereCubeMapShader](#extras_skysphereshader.skySphereCubeMapShader)<br>TODO: Not documented yet.
* [skySphereShader](#extras_skysphereshader.skySphereShader)<br>TODO: Not documented yet.
* [stride](#H3DU.BufferAccessor_stride)<br>A stride, which gives the number of elements from the start of one
value to the start of the next.
* [stripesBackShader](#extras_stripesbackshader.stripesBackShader)<br>TODO: Not documented yet.
* [sunburstBackShader](#extras_sunburstbackshader.sunburstBackShader)<br>TODO: Not documented yet.
* [vignetteShader](#extras_vignetteshader.vignetteShader)<br>TODO: Not documented yet.
* [warpShader](#extras_warpshader.warpShader)<br>TODO: Not documented yet.
* [waterpaintShader](#extras_waterpaintshader.waterpaintShader)<br>TODO: Not documented yet.
* [waveShader](#extras_waveshader.waveShader)<br>TODO: Not documented yet.
* [woodShader](#extras_woodshader.woodShader)<br>TODO: Not documented yet.

### Methods

* [FourierKnot](#extras_fourierknot.FourierKnot)<br>A curve evaluator object that calculates a knot in the form of the Fourier series

<b>F</b>(u) = &Sigma;<sub>i=1, n</sub> <b>a</b> cos(<i>iu</i>) + <b>b</b> sin(<i>iu</i>).
* [MoebiusLikeStrip](#extras_moresurfaces.MoebiusLikeStrip)<br>TODO: Not documented yet.
* [StarField](#extras_starfield.StarField)<br>TODO: Not documented yet.
* [accel](#H3DU.Curve_accel)<br>Finds an approximate acceleration vector at the given U coordinate of this curve.
* [addShape](#H3DU.ShapeGroup_addShape)<br>Adds a 3D shape to this shape group, at the end of the list
of shapes.
* [all](#Promise.all)<br>Wait for all these promises to complete.
* [arc](#H3DU.GraphicsPath_arc)<br>Adds path segments in the form of a circular arc to this path,
using the parameterization specified in the "arc" method of the
HTML Canvas 2D Context.
* [arcLength](#extras_evaluators_Hypotrochoid_arcLength)<br>Finds an approximate arc length (distance) between the start of this
curve and the point at the given U coordinate of this curve.
* [arcShape](#H3DU.GraphicsPath_arcShape)<br>Adds path segments to this path that form an arc running along an axis-aligned
ellipse, or a shape based on that arc and ellipse, given the ellipse's center
and dimensions, start angle, and sweep angle.
* [arcShapeForBox](#H3DU.GraphicsPath_arcShapeForBox)<br>Adds path segments to this path that form an arc running along an axis-aligned
ellipse, or a shape based on that arc and ellipse, given the ellipse's corner point
and dimensions, start angle, and sweep angle.
* [arcSvgTo](#H3DU.GraphicsPath_arcSvgTo)<br>Adds path segments in the form of an elliptical arc to this path,
using the parameterization used by the SVG specification.
* [arcTo](#H3DU.GraphicsPath_arcTo)<br>Adds path segments in the form of a circular arc to this path,
using the parameterization specified in the "arcTo" method of the
HTML Canvas 2D Context.
* [arrow](#H3DU.GraphicsPath_arrow)<br>Adds path segments to this path in the form of an arrow shape.
* [attribute](#H3DU.SurfaceBuilder_attribute)<br>Sets the parametric surface used to generate vertex attribute values.
* [bevelRect](#H3DU.GraphicsPath_bevelRect)<br>Adds path segments to this path that form an axis-aligned rectangle with beveled corners.
* [bezierCurveTo](#H3DU.GraphicsPath_bezierCurveTo)<br>Adds a cubic B&eacute;zier curve to this path starting
at this path's current position.
* [bitangent](#H3DU.BSplineSurface_bitangent)<br>Finds the bitangent vector at the
given point on the surface.
* [boxCenter](#H3DU.MathUtil.boxCenter)<br>Finds the center of a 3D bounding box.
* [boxDimensions](#H3DU.MathUtil.boxDimensions)<br>Finds the dimensions of a 3D bounding box.
* [boxIsEmpty](#H3DU.MathUtil.boxIsEmpty)<br>Determines whether a 3D bounding box is empty.
* [catch](#Promise_Promise$1_catch)<br>Creates a promise that calls a function if
this promise is rejected.
* [changeEnds](#H3DU.Curve_changeEnds)<br>Creates a curve evaluator object for a curve that is generated using
the same formula as this one (and uses the same U coordinates),
but has a different set of end points.
* [clamped](#H3DU.BSplineSurface.clamped)<br>Creates a B-spline surface with uniform knots, except that
the surface's edges lie on the edges of the control point array.
* [clampedKnots](#H3DU.BSplineCurve.clampedKnots)<br>Generates a knot vector with uniform knots, to be
passed to the BSplineCurve or BSplineCurve constructor,
except that with the knot vector the curve will start and end at the first and last control points and will
be tangent to the line between the first and second control points
and to the line between the next-to-last and last control points.
* [clearVertices](#H3DU.SurfaceBuilder_clearVertices)<br>Clears the arrays of attribute values (such as positions and normals)
and vertex indices generated so far.
* [closePath](#H3DU.GraphicsPath_closePath)<br>Makes this path closed.
* [colorToLinear](#H3DU.MathUtil.colorToLinear)<br>Converts a color from companded sRGB to linear sRGB using the sRGB transfer function, and returns
a new vector with the result.
* [colorTosRGB](#H3DU.MathUtil.colorTosRGB)<br>Converts a color from linear sRGB to companded sRGB using the sRGB transfer function, and returns
a new vector with the result.
* [constantAttribute](#H3DU.SurfaceBuilder_constantAttribute)<br>Sets a value for an attribute semantic that will be the same for all
future vertices generated by the "evalSurface" method.
* [continuousHypo](#extras_drawingtoy_DrawingToy_continuousHypo)<br>Adds line segments that approximate one or more curves drawn by rolling a wheel inside a fixed ring (<i>hypotrochoids</i>), where each additional curve may be drawn from a different hole position, a different ring position, or both.
* [contourLines](#extras_contourlines.contourLines)<br>Generates contour lines for two-dimensional data.
* [copy](#H3DU.ShapeGroup_copy)<br>Makes a copy of this shape group and the objects contained
in it.
* [count](#H3DU.BufferAccessor_count)<br>Gets the number of values defined for this accessor.
* [createBox](#H3DU.Meshes.createBox)<br>Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
* [createCapsule](#H3DU.Meshes.createCapsule)<br>Creates a mesh of a capsule, centered at the origin.
* [createClosedCylinder](#H3DU.Meshes.createClosedCylinder)<br>Creates a mesh of a closed cylinder.
* [createConvexHull](#extras_convex.createConvexHull)<br>Generates the convex hull of a set of 3-dimensional points, that is, the smallest convex set
that contains all the points given.
* [createCylinder](#H3DU.Meshes.createCylinder)<br>Creates a mesh of a cylinder.
* [createDisk](#H3DU.Meshes.createDisk)<br>Creates a mesh of a 2D disk.
* [createFloor](#extras_createfloor.createFloor)<br>Generates a mesh buffer of a tiled floor.
* [createGear](#extras_gearmesh.createGear)<br>Builds a mesh buffer representing a gear centered at the origin.
* [createLathe](#H3DU.Meshes.createLathe)<br>Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the Z axis.
* [createMultiColoredArrow](#extras_arrow.createMultiColoredArrow)<br>TODO: Not documented yet.
* [createPartialDisk](#H3DU.Meshes.createPartialDisk)<br>Creates a mesh of a 2D disk or an arc of a 2D disk.
* [createPlane](#H3DU.Meshes.createPlane)<br>Creates a mesh of a 2D rectangle, centered at the origin.
* [createPointedStar](#H3DU.Meshes.createPointedStar)<br>Creates a mesh in the form of a two-dimensional n-pointed star.
* [createSphere](#H3DU.Meshes.createSphere)<br>Creates a mesh of a sphere, centered at the origin.
* [createTorus](#H3DU.Meshes.createTorus)<br>Creates a mesh of a torus (donut), centered at the origin.
* [createWasher](#extras_createwasher.createWasher)<br>TODO: Not documented yet.
* [curveCatacaustic](#extras_derivedcurves.curveCatacaustic)<br>TODO: Not documented yet.
* [curveEvolute](#extras_derivedcurves.curveEvolute)<br>TODO: Not documented yet.
* [curveInverse](#extras_derivedcurves.curveInverse)<br>TODO: Not documented yet.
* [curveInvolute](#extras_derivedcurves.curveInvolute)<br>TODO: Not documented yet.
* [curveOrthotomic](#extras_derivedcurves.curveOrthotomic)<br>TODO: Not documented yet.
* [curvePedalCurve](#extras_derivedcurves.curvePedalCurve)<br>TODO: Not documented yet.
* [curveRadialCurve](#extras_derivedcurves.curveRadialCurve)<br>TODO: Not documented yet.
* [curveToBuffer](#H3DU.CurveBuilder.curveToBuffer)<br>Convenience method for creating a mesh buffer from a parametric
curve.
* [difference](#H3DU.GraphicsPath_difference)<br>Computes the difference between this path's shape and another
path's shape.
* [dispose](#extras_camera_InputTracker_dispose)<br>Disposes all resources used by this input tracker.
* [dodecahedron](#extras_polyhedra_Polyhedra.dodecahedron)<br>Generates a mesh of a regular dodecahedron or a sphere based on that solid.
* [dodecahedronFaces](#extras_polyhedra_Polyhedra.dodecahedronFaces)<br>Gets the vertices of a dodecahedron with maximum radius 1.
* [dodecahedronFacesCompact](#extras_polyhedra_Polyhedra.dodecahedronFacesCompact)<br>Gets a more compact representation of the vertices of a dodecahedron
with maximum radius 1.
* [ellipse](#H3DU.GraphicsPath_ellipse)<br>Adds path segments to this path that form an axis-aligned ellipse given its center
and dimensions.
* [ellipseForBox](#H3DU.GraphicsPath_ellipseForBox)<br>Adds path segments to this path that form an axis-aligned ellipse, given the ellipse's corner point
and dimensions.
* [endPoints](#extras_evaluators_Epitrochoid_endPoints)<br>Gets the endpoints of this curve.
* [epi](#extras_drawingtoy_DrawingToy_epi)<br>Adds line segments that approximate a curve drawn by rolling a wheel outside a fixed ring (an <i>epitrochoid</i>).
* [evalCurve](#H3DU.CurveBuilder_evalCurve)<br>Generates the vertex attributes of the parametric curves.
* [evalSurface](#H3DU.SurfaceBuilder_evalSurface)<br>Generates the vertex attributes of the parametric surfaces.
* [evaluate](#extras_evaluators_Epitrochoid_evaluate)<br>Generates a point on the curve from the given U coordinate.
* [fitRange](#H3DU.Curve_fitRange)<br>Creates a curve evaluator object for a curve that follows the same
path as this one but has its U coordinates remapped to fit the given range.
* [fragmentShaderLib](#extras_fragmentshaderlib.fragmentShaderLib)<br>TODO: Not documented yet.
* [fromBezierCurve](#H3DU.BSplineCurve.fromBezierCurve)<br>Creates a B-spline curve from the control points of a B&eacute;zier curve.
* [fromBezierSurface](#H3DU.BSplineSurface.fromBezierSurface)<br>Creates a B-spline surface from the control points of a B&eacute;zier surface.
* [fromCatmullRomSpline](#H3DU.PiecewiseCurve.fromCatmullRomSpline)<br>Creates a piecewise curve made up of B-spline curves from the control points of a
cubic Catmull&ndash;Rom spline.
* [fromEllipseArc](#H3DU.PiecewiseCurve.fromEllipseArc)<br>TODO: Not documented yet.
* [fromFunction](#extras_evaluators_SurfaceOfRevolution.fromFunction)<br>Creates a surface evaluator object for a surface of revolution
whose curve is the graph of a single-variable function.
* [fromHermiteSpline](#H3DU.PiecewiseCurve.fromHermiteSpline)<br>Creates a piecewise curve made up of B-spline curves from the control points of a
Hermite spline.
* [fromPositions](#H3DU.MeshBuffer.fromPositions)<br>Creates a new mesh buffer with the given array of vertex positions.
* [fromPositionsNormals](#H3DU.MeshBuffer.fromPositionsNormals)<br>Creates a new mesh buffer with the given array of vertex positions
and vertex normals.
* [fromPositionsNormalsUV](#H3DU.MeshBuffer.fromPositionsNormalsUV)<br>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.
* [fromPositionsUV](#H3DU.MeshBuffer.fromPositionsUV)<br>Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.
* [fromStlString](#extras_stl.fromStlString)<br>TODO: Not documented yet.
* [fromString](#H3DU.GraphicsPath.fromString)<br>Creates a graphics path from a string whose format follows
the SVG (Scalable Vector Graphics) specification.
* [fromTCBSpline](#H3DU.PiecewiseCurve.fromTCBSpline)<br>Creates a piecewise curve made up of B-spline curves from the control points of a
cubic TCB spline (tension/continuity/bias spline, also known as Kochanek&ndash;Bartels spline).
* [frustum](#extras_matrixstack_MatrixStack_frustum)<br>Modifies the matrix at the top of this stack by multiplying it by
a frustum matrix.
* [frustumHasBox](#H3DU.MathUtil.frustumHasBox)<br>Determines whether an axis-aligned bounding box
is at least partially inside a view frustum.
* [frustumHasPoint](#H3DU.MathUtil.frustumHasPoint)<br>Determines whether a point is
outside or inside a view frustum.
* [frustumHasSphere](#H3DU.MathUtil.frustumHasSphere)<br>Determines whether a sphere is at least
partially inside a view frustum.
* [get](#extras_matrixstack_MatrixStack_get)<br>Gets a copy of the matrix at the top of this stack.
* [getAttribute](#H3DU.MeshBuffer_getAttribute)<br>Gets a vertex attribute included in this mesh buffer.
* [getBounds](#H3DU.ShapeGroup_getBounds)<br>Finds a bounding box that holds all vertices in this shape group.
* [getColorMatrix](#extras_colormatrixshader.getColorMatrix)<br>Gets a specific kind of color matrix for the color
matrix shader.
* [getControlPoints](#H3DU.BSplineSurface_getControlPoints)<br>Gets a reference to the array of control point arrays used
in this surface object.
* [getCurrentPoint](#H3DU.GraphicsPath_getCurrentPoint)<br>Gets the current point stored in this path.
* [getCurves](#H3DU.GraphicsPath_getCurves)<br>Gets a curve evaluator object for
the curves described by this path.
* [getDistance](#extras_camera_Camera_getDistance)<br>Finds the distance from the camera's position to the reference point.
* [getIndices](#H3DU.MeshBuffer_getIndices)<br>Gets the array of vertex indices used by this mesh buffer.
* [getKernelMatrix](#extras_kernelmatrixshader.getKernelMatrix)<br>TODO: Not documented yet.
* [getKey](#extras_camera_InputTracker_getKey)<br>Gets whether a key is pressed, as detected by this
input tracker.
* [getKnots](#H3DU.BSplineSurface_getKnots)<br>Gets a reference to the array of knot vectors used
in this curve object.
* [getLength](#H3DU.Curve_getLength)<br>Convenience method for getting the total length of this curve.
* [getLinePoints](#H3DU.GraphicsPath_getLinePoints)<br>Gets an array of the end points of
line segments approximating the path.
* [getLinePointsAsObjects](#H3DU.GraphicsPath_getLinePointsAsObjects)<br>Gets an array of the end points of
line segments approximating the path.
* [getLines](#H3DU.GraphicsPath_getLines)<br>Gets an array of line segments approximating
the path.
* [getMatrix](#H3DU.ShapeGroup_getMatrix)<br>Gets a copy of the transformation needed to transform
this shape group's coordinates to world coordinates.
* [getMeshBuffer](#H3DU.Shape_getMeshBuffer)<br>Returns a reference to the mesh buffer used by this shape.
* [getPoints](#H3DU.GraphicsPath_getPoints)<br>Gets an array of points evenly spaced across the length
of the path.
* [getPointsAsObjects](#H3DU.GraphicsPath_getPointsAsObjects)<br>Gets an array of points evenly spaced across the length
of the path.
* [getPosition](#extras_camera_Camera_getPosition)<br>Gets the position of the camera.
* [getPositions](#H3DU.MeshBuffer_getPositions)<br>Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.
* [getPromiseResults](#H3DU.getPromiseResults)<br>Utility function that returns a promise that
resolves after the given list of promises finishes
its work.
* [getPromiseResultsAll](#H3DU.getPromiseResultsAll)<br>Utility function that returns a promise that
resolves or is rejected after the given list of promises finishes
its work.
* [getQuaternion](#H3DU.Transform_getQuaternion)<br>Returns a copy of the rotation of an object in the form of a <a href="tutorial-glmath.md">quaternion</a>.
* [getScale](#H3DU.Transform_getScale)<br>Returns a copy of a three-element array giving the scaling for an object's width,
height, and depth, respectively.
* [getShape](#H3DU.ShapeGroup_getShape)<br>Gets the shape or shape group located
in this shape group at the given index.
* [getSubpaths](#H3DU.GraphicsPath_getSubpaths)<br>TODO: Not documented yet.
* [getTimePosition](#H3DU.getTimePosition)<br>Gets the position of a time value within an interval.
* [getTransform](#H3DU.ShapeGroup_getTransform)<br>Gets a reference to the transform used by this shape group object.
* [getTriangles](#H3DU.GraphicsPath_getTriangles)<br>Converts the subpaths in this path to triangles.
* [getVec](#H3DU.BufferAccessor_getVec)<br>Gets the elements of a vertex attribute value.
* [getVectorFromCenter](#extras_camera_Camera_getVectorFromCenter)<br>Gets the 3-element vector that points from the reference
point to the camera's position.
* [getVisible](#H3DU.ShapeGroup_getVisible)<br>Gets whether this shape group will be drawn on rendering.
* [gradient](#H3DU.Surface_gradient)<br>Finds an approximate gradient vector of this surface at the given U and V coordinates.
* [hexahedron](#extras_polyhedra_Polyhedra.hexahedron)<br>Generates a mesh of a regular hexahedron (cube) or a sphere based on that solid.
* [hexahedronFaces](#extras_polyhedra_Polyhedra.hexahedronFaces)<br>Gets the vertices of a hexahedron (cube) with maximum radius 1.
* [hexahedronFacesCompact](#extras_polyhedra_Polyhedra.hexahedronFacesCompact)<br>Gets a more compact representation of the vertices of a hexahedron
(cube) with maximum radius 1.
* [horizontalGradient](#extras_gradients.horizontalGradient)<br>Generates a 32x32 bitmap of a linear gradient in the horizontal direction.
* [hypo](#extras_drawingtoy_DrawingToy_hypo)<br>Adds line segments that approximate a curve drawn by rolling a wheel inside a fixed ring (a <i>hypotrochoid</i>).
* [icosahedron](#extras_polyhedra_Polyhedra.icosahedron)<br>Generates a mesh of a regular icosahedron or a sphere based on that solid.
* [icosahedronFaces](#extras_polyhedra_Polyhedra.icosahedronFaces)<br>Gets the vertices of a regular icosahedron with maximum radius 1.
* [interlaced](#extras_torusknot_TorusKnot.interlaced)<br>TODO: Not documented yet.
* [interpCubicBezier](#H3DU.MathUtil.interpCubicBezier)<br>An interpolation timing function based on the path of a
cubic B&eacute;zier
curve with end points (0, 0) and (1, 1) and with two
configurable control points.
* [interpolate](#H3DU.GraphicsPath_interpolate)<br>Does a linear interpolation between two graphics paths.
* [intersection](#H3DU.GraphicsPath_intersection)<br>Computes the intersection, or the area common to both this path's shape
and another path's shape.
* [isIdentity](#H3DU.Transform_isIdentity)<br>Returns whether this transform is the identity transform.
* [isIncomplete](#H3DU.GraphicsPath_isIncomplete)<br>Returns whether the curve path is incomplete
because of an error in parsing the curve string.
* [jerk](#H3DU.Curve_jerk)<br>Finds an approximate jerk vector at the given U coordinate of this curve.
* [line](#H3DU.GraphicsPath_line)<br>Adds a line segment to this path.
* [lineTo](#H3DU.GraphicsPath_lineTo)<br>Adds a line segment to the path, starting
at the path's end position, then
sets the end position to the end of the segment.
* [load](#extras_text_H3DU.TextureAtlas.load)<br>Loads a texture atlas definition from a file.
* [loadData](#extras_text_H3DU.TextFont.loadData)<br>Loads a bitmap font definition from a file.
* [loadIdentity](#extras_matrixstack_MatrixStack_loadIdentity)<br>Modifies the matrix at the top of this stack by replacing it with the identity matrix.
* [loadMatrix](#extras_matrixstack_MatrixStack_loadMatrix)<br>Modifies the matrix at the top of this stack by replacing it with the given matrix.
* [loadTextures](#extras_text_H3DU.TextureAtlas_loadTextures)<br>Loads the texture files used by this texture atlas.
* [loadTga](#extras_tga.loadTga)<br>TODO: Not documented yet.
* [loadTransposeMatrix](#extras_matrixstack_MatrixStack_loadTransposeMatrix)<br>Modifies the matrix at the top of this stack by replacing it with the
transpose of the given matrix.
* [loadWithTextures](#extras_text_H3DU.TextureAtlas.loadWithTextures)<br>Loads a texture atlas definition from a file along with the textures
it uses.
* [lookAt](#extras_matrixstack_MatrixStack_lookAt)<br>Modifies the matrix at the top of this stack by multiplying it by
a matrix representing a camera view.
* [makeBlank](#H3DU.BufferAccessor.makeBlank)<br>Generates a vertex attribute buffer, with each value set to all zeros.
* [makeIndices](#H3DU.BufferAccessor.makeIndices)<br>Generates an array of increasing vertex indices.
* [makeSphere](#extras_polyhedra_Polyhedra.makeSphere)<br>Modifies the vertices and indices of a solid to
generate an approximation of a sphere.
* [makeSprites](#extras_text_H3DU.TextureAtlas_makeSprites)<br>Makes a shape group used to display one or more sprites.
* [makeTextMeshes](#extras_text_H3DU.TextFont_makeTextMeshes)<br>Creates an array of meshes containing the primitives
needed to draw text with this font.
* [mat3copy](#H3DU.MathUtil.mat3copy)<br>Returns a copy of a 3x3 matrix.
* [mat3identity](#H3DU.MathUtil.mat3identity)<br>Returns the identity 3x3 matrix (a matrix that keeps
vectors unchanged when they are transformed with this matrix).
* [mat3invert](#H3DU.MathUtil.mat3invert)<br>Finds the inverse of a 3x3 matrix, describing a transformation that undoes the given transformation.
* [mat3multiply](#H3DU.MathUtil.mat3multiply)<br>Multiplies two 3x3 matrices.
* [mat3transform](#H3DU.MathUtil.mat3transform)<br>Transforms a 3-element vector with a 3x3 matrix and returns
the transformed vector.
* [mat3transpose](#H3DU.MathUtil.mat3transpose)<br>Returns the transpose of a 3x3 matrix.
* [mat3transposeInPlace](#H3DU.MathUtil.mat3transposeInPlace)<br>Transposes a 3x3 matrix in place without creating
a new matrix.
* [mat4copy](#H3DU.MathUtil.mat4copy)<br>Returns a copy of a 4x4 matrix.
* [mat4frustum](#H3DU.MathUtil.mat4frustum)<br>Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>
in the form of a view frustum, or the limits in the "camera"'s view.
* [mat4identity](#H3DU.MathUtil.mat4identity)<br>Returns the identity 4x4 matrix (a matrix that keeps
vectors unchanged when they are transformed with this matrix).
* [mat4inverseTranspose3](#H3DU.MathUtil.mat4inverseTranspose3)<br>Returns the transposed result of the inverted 3x3 upper left corner of
the given 4x4 matrix.
* [mat4invert](#H3DU.MathUtil.mat4invert)<br>Finds the inverse of a 4x4 matrix, describing a transformation that undoes the given transformation.
* [mat4isIdentity](#H3DU.MathUtil.mat4isIdentity)<br>Returns whether a 4x4 matrix is the identity matrix.
* [mat4lookat](#H3DU.MathUtil.mat4lookat)<br>Returns a 4x4 matrix that represents a camera view,
transforming world space coordinates, shared by every object in a scene, to coordinates in <i>eye space</i>
(also called <i>camera space</i> or <i>view space</i>).
* [mat4multiply](#H3DU.MathUtil.mat4multiply)<br>Multiplies two 4x4 matrices.
* [mat4oblique](#H3DU.MathUtil.mat4oblique)<br>Returns a 4x4 view matrix representing an oblique projection,
when used in conjunction with an orthographic projection.
* [mat4ortho](#H3DU.MathUtil.mat4ortho)<br>Returns a 4x4 matrix representing an <a href="tutorial-camera.md">orthographic projection</a>.
* [mat4ortho2d](#H3DU.MathUtil.mat4ortho2d)<br>Returns a 4x4 matrix representing a 2D <a href="tutorial-camera.md">orthographic projection</a>.
* [mat4ortho2dAspect](#H3DU.MathUtil.mat4ortho2dAspect)<br>Returns a 4x4 matrix representing a 2D <a href="tutorial-camera.md">orthographic projection</a>,
retaining the view rectangle's aspect ratio.
* [mat4orthoAspect](#H3DU.MathUtil.mat4orthoAspect)<br>Returns a 4x4 matrix representing an <a href="tutorial-camera.md">orthographic projection</a>,
retaining the view rectangle's aspect ratio.
* [mat4perspective](#H3DU.MathUtil.mat4perspective)<br>Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>.
* [mat4perspectiveHorizontal](#H3DU.MathUtil.mat4perspectiveHorizontal)<br>Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>,
given an X axis field of view.
* [mat4projectVec3](#H3DU.MathUtil.mat4projectVec3)<br>Transforms a 3-element vector with a 4x4 matrix and returns
a perspective-correct version of the vector as a 3D point.
* [mat4rotate](#H3DU.MathUtil.mat4rotate)<br>Multiplies a 4x4 matrix by a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>,
and returns a new matrix.
* [mat4rotated](#H3DU.MathUtil.mat4rotated)<br>Returns a 4x4 matrix representing a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>.
* [mat4scale](#H3DU.MathUtil.mat4scale)<br>Multiplies a 4x4 matrix by a scaling transformation.
* [mat4scaleInPlace](#H3DU.MathUtil.mat4scaleInPlace)<br>Modifies a 4x4 matrix by multiplying it by a
scaling transformation.
* [mat4scaled](#H3DU.MathUtil.mat4scaled)<br>Returns a 4x4 matrix representing a scaling transformation.
* [mat4toFrustumPlanes](#H3DU.MathUtil.mat4toFrustumPlanes)<br>Finds the six clipping planes of a view frustum defined
by a 4x4 matrix.
* [mat4toMat3](#H3DU.MathUtil.mat4toMat3)<br>Returns the upper-left part of a 4x4 matrix as a new
3x3 matrix.
* [mat4transform](#H3DU.MathUtil.mat4transform)<br>Transforms a 4-element vector with a 4x4 matrix and returns
the transformed vector.
* [mat4transformVec3](#H3DU.MathUtil.mat4transformVec3)<br>Transforms a 3-element vector with a 4x4 matrix as though it were
an affine transformation matrix (without perspective) and returns the transformed vector.
* [mat4translate](#H3DU.MathUtil.mat4translate)<br>Multiplies a 4x4 matrix by a translation transformation.
* [mat4translated](#H3DU.MathUtil.mat4translated)<br>Returns a 4x4 matrix representing a translation.
* [mat4transpose](#H3DU.MathUtil.mat4transpose)<br>Returns the transpose of a 4x4 matrix.
* [mat4transposeInPlace](#H3DU.MathUtil.mat4transposeInPlace)<br>Transposes a 4x4 matrix in place without creating
a new matrix.
* [measure](#extras_text_H3DU.TextFont_measure)<br>Calculates the width and height of a text string when
drawn using this font.
* [merge](#H3DU.GraphicsPath_merge)<br>Merges the path segments in another path onto this one.
* [mousePos](#extras_camera_InputTracker_mousePos)<br>Returns the current mouse position, delta
mouse position, and delta mouse wheel
position (see the "update" method).
* [mousewheel](#extras_camera_InputTracker_mousewheel)<br>**Deprecated: Will be removed in the future. Use the
mousePos method to find out whether the user
has rotated the mouse wheel.**
* [moveAngleHorizontal](#extras_camera_Camera_moveAngleHorizontal)<br>Moves the camera to the left or right so that it faces
the same reference point at the same distance.
* [moveAngleVertical](#extras_camera_Camera_moveAngleVertical)<br>Moves the camera upward or downward so that it faces
the same reference point at the same distance.
* [moveClose](#extras_camera_Camera_moveClose)<br>Moves the camera the given distance, but not too close
to the reference point.
* [moveForward](#extras_camera_Camera_moveForward)<br>Moves the camera forward the given distance.
* [moveHorizontal](#extras_camera_Camera_moveHorizontal)<br>Moves the camera horizontally relative to the camera's up vector.
* [movePosition](#H3DU.Transform_movePosition)<br>Moves the relative position of an object from its original
position.
* [moveTo](#H3DU.GraphicsPath_moveTo)<br>Moves the current start position and end position to the given position.
* [moveVertical](#extras_camera_Camera_moveVertical)<br>Moves the camera toward or away from the camera's up vector.
* [multMatrix](#extras_matrixstack_MatrixStack_multMatrix)<br>Modifies the matrix at the top of this stack by multiplying it by another matrix.
* [multQuaternion](#H3DU.Transform_multQuaternion)<br>Combines an object's current rotation with another rotation
described by a <a href="tutorial-glmath.md">quaternion</a> (a 4-element array
for describing 3D rotations).
* [multRotation](#H3DU.Transform_multRotation)<br>Combines an object's current rotation with another rotation
in the form of an angle and an axis of
rotation.
* [newFrames](#H3DU.newFrames)<br>Returns the number of frame-length intervals that occurred since
the last known time, where a frame's length is 1/60 of a second.
* [normDistances](#extras_polyhedra_Polyhedra.normDistances)<br>Normalizes the distance from the origin to each vertex in the given
array to a fixed radius.
* [normal](#H3DU.Surface_normal)<br>Convenience method for finding an approximate normal vector of this surface at the given U and V coordinates.
* [normalizeKernelInPlace](#extras_kernelmatrixshader.normalizeKernelInPlace)<br>TODO: Not documented yet.
* [normalizeNormals](#H3DU.MeshBuffer_normalizeNormals)<br>Modifies this mesh buffer by converting the normals it defines to <a href="tutorial-glmath.md">unit vectors</a>
("normalized" vectors with a length of 1).
* [octahedron](#extras_polyhedra_Polyhedra.octahedron)<br>Generates a mesh of a regular octahedron or a sphere based on that solid.
* [octahedronFaces](#extras_polyhedra_Polyhedra.octahedronFaces)<br>Gets the vertices of a regular octahedron with radius 1.
* [ortho](#extras_matrixstack_MatrixStack_ortho)<br>Modifies the matrix at the top of this stack by multiplying it by
an orthographic projection.
* [ortho2d](#extras_matrixstack_MatrixStack_ortho2d)<br>Modifies the matrix at the top of this stack by multiplying it by
a 2D orthographic projection.
* [pathLength](#H3DU.GraphicsPath_pathLength)<br>Finds the approximate length of this path.
* [perspective](#extras_matrixstack_MatrixStack_perspective)<br>Modifies the matrix at the top of this stack by multiplying it by
a matrix that defines a perspective projection.
* [pickMatrix](#extras_matrixstack_MatrixStack_pickMatrix)<br>Modifies the matrix at the top of this stack by multiplying it by
a matrix that transforms the view to a portion of the viewport.
* [planeFromNormalAndPoint](#H3DU.MathUtil.planeFromNormalAndPoint)<br>Creates a plane from a normal vector and a point on the plane.
* [planeNormalize](#H3DU.MathUtil.planeNormalize)<br>Normalizes this plane so that its normal is a <a href="tutorial-glmath.md">unit vector</a>,
unless all the normal's components are 0, and returns a new plane with the result.
* [planeNormalizeInPlace](#H3DU.MathUtil.planeNormalizeInPlace)<br>Normalizes this plane so that its normal is a <a href="tutorial-glmath.md">unit vector</a>,
unless all the normal's components are 0, and sets this plane to the result.
* [planePointsToConvexHull](#extras_convex.planePointsToConvexHull)<br>Generates a convex hull of the half-space representation
of several planes.
* [polarCurve](#extras_derivedcurves.polarCurve)<br>TODO: Not documented yet.
* [polyline](#H3DU.GraphicsPath_polyline)<br>Adds path segments to this path that form a polygon or a connected line segment strand.
* [popMatrix](#extras_matrixstack_MatrixStack_popMatrix)<br>Removes the matrix at the top of this stack, making
the matrix beneath it the new top matrix.
* [position](#H3DU.SurfaceBuilder_position)<br>Sets the parametric surface used to generate vertex positions.
* [positionNormal](#H3DU.SurfaceBuilder_positionNormal)<br>Sets the parametric surface used to generate vertex positions and normals.
* [positionNormalTexCoord](#H3DU.SurfaceBuilder_positionNormalTexCoord)<br>Sets the parametric surface used to generate vertex positions and normals, and
sets a surface evaluator that generates texture coordinates in the interval [0, 1] along the U and V axes of the surface.
* [positionTexCoord](#H3DU.SurfaceBuilder_positionTexCoord)<br>Sets the parametric surface used to generate vertex positions, and
sets a surface evaluator that generates texture coordinates in the interval [0, 1] along the U and V axes of the surface.
* [primitiveCount](#H3DU.ShapeGroup_primitiveCount)<br>Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this shape group.
* [primitiveType](#H3DU.MeshBuffer_primitiveType)<br>Gets the type of primitive stored in this mesh buffer.
* [pushMatrix](#extras_matrixstack_MatrixStack_pushMatrix)<br>Makes a copy of the matrix at the top of this stack
and puts the copy on top of the stack.
* [quadraticCurveTo](#H3DU.GraphicsPath_quadraticCurveTo)<br>Adds a quadratic B&eacute;zier curve to this path starting
at this path's current position.
* [quatConjugate](#H3DU.MathUtil.quatConjugate)<br>Returns a quaternion that describes a rotation that undoes the given rotation (an "inverted" rotation); this is done by reversing the sign of the X, Y, and Z components (which describe the quaternion's <a href="tutorial-glmath.md">axis of rotation</a>).
* [quatCopy](#H3DU.MathUtil.quatCopy)<br>Returns a copy of a quaternion.
* [quatDot](#H3DU.MathUtil.quatDot)<br>Finds the dot product of two quaternions.
* [quatFromAxisAngle](#H3DU.MathUtil.quatFromAxisAngle)<br>Generates a quaternion from a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>,
* [quatFromMat4](#H3DU.MathUtil.quatFromMat4)<br>Generates a quaternion from the vector rotation described in a 4x4 matrix.
* [quatFromTaitBryan](#H3DU.MathUtil.quatFromTaitBryan)<br>Generates a quaternion from pitch, yaw and roll angles (or <i>Tait&ndash;Bryan angles</i>).
* [quatFromVectors](#H3DU.MathUtil.quatFromVectors)<br>Generates a quaternion describing a rotation between
two 3-element vectors.
* [quatIdentity](#H3DU.MathUtil.quatIdentity)<br>Returns the identity quaternion of multiplication, (0, 0, 0, 1).
* [quatInvert](#H3DU.MathUtil.quatInvert)<br>Returns a quaternion that describes a rotation that undoes the given rotation (an "inverted" rotation) and is converted to a <a href="tutorial-glmath.md">unit vector</a>.
* [quatIsIdentity](#H3DU.MathUtil.quatIsIdentity)<br>Returns whether this quaternion is the identity quaternion, (0, 0, 0, 1).
* [quatLength](#H3DU.MathUtil.quatLength)<br>Returns the distance of this quaternion from the origin.
* [quatMultiply](#H3DU.MathUtil.quatMultiply)<br>Multiplies two quaternions, creating a composite rotation.
* [quatNlerp](#H3DU.MathUtil.quatNlerp)<br>Returns a quaternion that lies along the shortest path between the
given two quaternion rotations, using a linear interpolation function, and converts
it to a <a href="tutorial-glmath.md">unit vector</a>.
* [quatNormalize](#H3DU.MathUtil.quatNormalize)<br>Converts a quaternion to a <a href="tutorial-glmath.md">unit vector</a>; returns a new quaternion.
* [quatNormalizeInPlace](#H3DU.MathUtil.quatNormalizeInPlace)<br>Converts a quaternion to a <a href="tutorial-glmath.md">unit vector</a>.
* [quatRotate](#H3DU.MathUtil.quatRotate)<br>Multiplies a quaternion by a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>.
* [quatScale](#H3DU.MathUtil.quatScale)<br>Multiplies each element of a quaternion by a factor
and returns the result as a new quaternion.
* [quatScaleInPlace](#H3DU.MathUtil.quatScaleInPlace)<br>Multiplies each element of a quaternion by a factor
and stores the result in that quaternion.
* [quatSlerp](#H3DU.MathUtil.quatSlerp)<br>Returns a quaternion that lies along the shortest path between the
given two quaternion rotations, using a spherical interpolation function.
* [quatToAxisAngle](#H3DU.MathUtil.quatToAxisAngle)<br>Calculates the vector rotation for this quaternion in the form
of the angle to rotate the vector by and an <a href="tutorial-glmath.md">axis of rotation</a> to
rotate that vector around.
* [quatToMat4](#H3DU.MathUtil.quatToMat4)<br>Generates a 4x4 matrix describing the rotation
described by this quaternion.
* [quatToTaitBryan](#H3DU.MathUtil.quatToTaitBryan)<br>Converts this quaternion to the same version of the rotation
in the form of pitch, yaw, and roll angles (or <i>Tait&ndash;Bryan angles</i>).
* [quatTransform](#H3DU.MathUtil.quatTransform)<br>Transforms a 3- or 4-element vector using a
quaternion's vector rotation.
* [race](#Promise.race)<br>Creates a promise that resolves or is rejected when one of those promises
resolves or is rejected.
* [radialGradient](#extras_gradients.radialGradient)<br>Generates a 32x32 bitmap of a radial gradient.
* [randomConvexPolyhedron](#extras_convex.randomConvexPolyhedron)<br>Generates a mesh buffer of a convex polyhedron at random.
* [randomPolygon](#extras_randompolygon.randomPolygon)<br>TODO: Not documented yet.
* [raypick](#extras_raypick.raypick)<br>Finds the three-dimensional shape object and world-space coordinates
corresponding to the given two-dimensional (X and Y) coordinates.
* [recalcNormals](#H3DU.MeshBuffer_recalcNormals)<br>Recalculates the normal vectors for triangles
in this mesh.
* [rect](#H3DU.GraphicsPath_rect)<br>Adds path segments to this path that form an axis-aligned rectangle.
* [regularPolygon](#H3DU.GraphicsPath_regularPolygon)<br>Adds path segments to this path that form a regular polygon.
* [regularStar](#H3DU.GraphicsPath_regularStar)<br>Adds path segments to this path that form a regular N-pointed star.
* [reject](#Promise.reject)<br>Returns a promise that is rejected.
* [removeShape](#H3DU.ShapeGroup_removeShape)<br>Removes all instances of a 3D shape from this shape group
* [reset](#H3DU.Transform_reset)<br>Resets this transform to the untransformed state.
* [resolve](#Promise.resolve)<br>Returns a promise that resolves.
* [reverse](#H3DU.GraphicsPath_reverse)<br>Returns a path that reverses the course of this path.
* [reverseNormals](#H3DU.MeshBuffer_reverseNormals)<br>Modifies this mesh buffer by reversing the sign of normals it defines.
* [reverseWinding](#H3DU.MeshBuffer_reverseWinding)<br>Reverses the winding order of the triangles in this mesh buffer
by swapping the second and third vertex indices of each one.
* [rose](#extras_evaluators_Hypotrochoid.rose)<br>Creates a curve evaluator object for a rose, a special
form of hypotrochoid.
* [rotate](#extras_matrixstack_MatrixStack_rotate)<br>Modifies the matrix at the top of this stack by multiplying it by a rotation transformation.
* [roundRect](#H3DU.GraphicsPath_roundRect)<br>Adds path segments to this path that form an axis-aligned rounded rectangle.
* [ruledSurface](#extras_derivedcurves.ruledSurface)<br>TODO: Not documented yet.
* [scale](#extras_matrixstack_MatrixStack_scale)<br>Modifies the matrix at the top of this stack by multiplying it by a
scaling transformation.
* [scaleTo](#extras_evaluators_Epitrochoid_scaleTo)<br>Creates a modified version of this curve so that it
fits the given radius.
* [set](#H3DU.BufferAccessor_set)<br>Sets the first element of the attribute value with the given vertex index.
* [setAttribute](#H3DU.MeshBuffer_setAttribute)<br>Adds information about a buffer attribute to this
mesh buffer (or sets an
existing attribute's information).
* [setAttributeEx](#H3DU.MeshBuffer_setAttributeEx)<br>Adds information about a buffer attribute to this
mesh buffer (or sets an
existing attribute's information), taking a semantic index as
an additional parameter.
* [setColor](#extras_drawingtoy_DrawingToy_setColor)<br>Sets the color to apply when drawing future curves with this object.
* [setDistance](#extras_camera_Camera_setDistance)<br>Moves the camera a given distance from the reference
point without changing its orientation.
* [setIndices](#H3DU.MeshBuffer_setIndices)<br>Sets the vertex indices used by this mesh buffer.
* [setMatrix](#H3DU.Transform_setMatrix)<br>Sets this transform's transformation matrix.
* [setPosition](#extras_camera_Camera_setPosition)<br>Sets the position of the camera.
* [setPrimitiveType](#H3DU.MeshBuffer_setPrimitiveType)<br>Sets the type of graphics primitives stored in this mesh buffer.
* [setQuaternion](#H3DU.ShapeGroup_setQuaternion)<br>Sets this shape group's rotation in the form of a <a href="tutorial-glmath.md">quaternion</a>.
* [setRotation](#H3DU.Transform_setRotation)<br>Sets this transform's rotation in the form of an angle and an axis of
rotation.
* [setScale](#H3DU.ShapeGroup_setScale)<br>Sets the scale of this shape group relative to its original
size.
* [setShape](#H3DU.ShapeGroup_setShape)<br>Sets a shape or shape group at the given index in this shape group.
* [setTransform](#H3DU.ShapeGroup_setTransform)<br>Sets the transform used by this shape group to a copy
of the given transform.
* [setVec](#H3DU.BufferAccessor_setVec)<br>Sets the elements of a vertex attribute value.
* [setVisible](#H3DU.ShapeGroup_setVisible)<br>Sets whether this shape group will be drawn on rendering.
* [shapeCount](#H3DU.ShapeGroup_shapeCount)<br>Returns the number of shapes and/or shape groups that
are direct children of this shape group.
* [simple](#extras_torusknot_TorusKnot.simple)<br>Generates a torus knot with simple parameters.
* [spiralCurve](#extras_derivedcurves.spiralCurve)<br>TODO: Not documented yet.
* [split](#H3DU.BSplineCurve_split)<br>Splits this B-spline curve into two at the given point.
* [surfaceToBuffer](#H3DU.SurfaceBuilder.surfaceToBuffer)<br>Convenience method for creating a mesh buffer from a parametric
surface.
* [tangent](#H3DU.BSplineSurface_tangent)<br>Finds the tangent vector at the
given point on the surface.
* [tetrahedron](#extras_polyhedra_Polyhedra.tetrahedron)<br>Generates a mesh of a regular tetrahedron or a sphere based on that solid.
* [tetrahedronFaces](#extras_polyhedra_Polyhedra.tetrahedronFaces)<br>Gets the vertices of a tetrahedron with radius 1.
* [texCoord](#H3DU.SurfaceBuilder_texCoord)<br>Sets the parametric surface used to generate texture coordinates.
* [textShape](#extras_text_H3DU.TextFont_textShape)<br>Creates a group of shapes containing the primitives needed to
draw text in the given position, size, and color.
* [then](#Promise_Promise$1_then)<br>Creates a promise that calls a function depending on whether
this promise resolves or is rejected.
* [toArcLengthParam](#H3DU.Curve_toArcLengthParam)<br>Gets a curve evaluator object for a curve that follows the same
path as this one but has its U coordinates remapped to
an <i>arc length parameterization</i>.
* [toCurvePath](#H3DU.GraphicsPath_toCurvePath)<br>Creates a path in which arcs are decomposed
to cubic B&eacute;zier curves (which will approximate those arcs).
* [toExtrudedMeshBuffer](#H3DU.GraphicsPath_toExtrudedMeshBuffer)<br>Generates a mesh buffer consisting of "walls" that follow this graphics path approximately.
* [toGLColor](#H3DU.toGLColor)<br>Creates a 4-element array representing a color.
* [toLineMeshBuffer](#H3DU.GraphicsPath_toLineMeshBuffer)<br>Generates a mesh buffer consisting of the approximate line segments that make up this graphics path.
* [toLinePath](#H3DU.GraphicsPath_toLinePath)<br>Creates a path in which curves and arcs are decomposed
to line segments.
* [toMeshBuffer](#extras_drawingtoy_DrawingToy_toMeshBuffer)<br>TODO: Not documented yet.
* [toString](#H3DU.GraphicsPath_toString)<br>Returns this path in the form of a string in SVG path format.
* [torus](#extras_evaluators_SurfaceOfRevolution.torus)<br>A surface evaluator object for a torus, a special case of a surface of revolution.
* [transform](#H3DU.GraphicsPath_transform)<br>Returns a modified version of this path that is transformed
according to the given affine transformation (a transformation
that keeps straight lines straight and parallel lines parallel).
* [translate](#extras_matrixstack_MatrixStack_translate)<br>Modifies the matrix at the top of this stack by multiplying it by a
translation transformation.
* [turnAngleHorizontal](#extras_camera_Camera_turnAngleHorizontal)<br>Turns the camera to the left or right so that it faces
the same distance from a reference point.
* [turnAngleVertical](#extras_camera_Camera_turnAngleVertical)<br>Turns the camera upward or downward so that it faces
the same distance from a reference point.
* [uniform](#H3DU.BSplineSurface.uniform)<br>Creates a B-spline surface with uniform knots.
* [uniformKnots](#H3DU.BSplineCurve.uniformKnots)<br>Generates a knot vector with uniform knots, to be
passed to the BSplineCurve or BSplineCurve constructor.
* [union](#H3DU.GraphicsPath_union)<br>Computes the combination of this path's shape with another
path's shape.
* [update](#extras_camera_Camera_update)<br>Updates information about this camera based
on the state of an input tracker.
* [vec2abs](#H3DU.MathUtil.vec2abs)<br>Returns a new 2-element
vector with the absolute value of each of its components.
* [vec2absInPlace](#H3DU.MathUtil.vec2absInPlace)<br>Sets each component of the given 2-element
vector to its absolute value.
* [vec2add](#H3DU.MathUtil.vec2add)<br>Adds two 2-element vectors and returns a new
vector with the result.
* [vec2addInPlace](#H3DU.MathUtil.vec2addInPlace)<br>Adds two 2-element vectors and stores
the result in the first vector.
* [vec2assign](#H3DU.MathUtil.vec2assign)<br>Assigns the values of a 2-element vector into another
2-element vector.
* [vec2clamp](#H3DU.MathUtil.vec2clamp)<br>Returns a 2-element vector in which each element of the given 2-element vector is clamped
so it's not less than one value or greater than another value.
* [vec2clampInPlace](#H3DU.MathUtil.vec2clampInPlace)<br>Clamps each element of the given 2-element vector
so it's not less than one value or greater than another value.
* [vec2copy](#H3DU.MathUtil.vec2copy)<br>Returns a copy of a 2-element vector.
* [vec2dist](#H3DU.MathUtil.vec2dist)<br>Finds the straight-line distance from one three-element vector
to another, treating both as 3D points.
* [vec2dot](#H3DU.MathUtil.vec2dot)<br>Finds the dot product of two 2-element vectors.
* [vec2length](#H3DU.MathUtil.vec2length)<br>Returns the distance of this 2-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
* [vec2lerp](#H3DU.MathUtil.vec2lerp)<br>Does a linear interpolation between two 2-element vectors;
returns a new vector.
* [vec2mul](#H3DU.MathUtil.vec2mul)<br>Multiplies each of the components of two 2-element vectors and returns a new
vector with the result.
* [vec2mulInPlace](#H3DU.MathUtil.vec2mulInPlace)<br>Multiplies each of the components of two 2-element vectors and stores
the result in the first vector.
* [vec2negate](#H3DU.MathUtil.vec2negate)<br>Negates a 2-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction.
* [vec2negateInPlace](#H3DU.MathUtil.vec2negateInPlace)<br>Negates a 2-element vector in place, generally resulting in a vector with
the same length but opposite direction.
* [vec2normalize](#H3DU.MathUtil.vec2normalize)<br>Converts a 2-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
* [vec2normalizeInPlace](#H3DU.MathUtil.vec2normalizeInPlace)<br>Converts a 2-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
* [vec2perp](#H3DU.MathUtil.vec2perp)<br>Returns an arbitrary 2-element vector that is perpendicular
(orthogonal) to the given 2-element vector.
* [vec2proj](#H3DU.MathUtil.vec2proj)<br>Returns the projection of a 2-element vector on the given
reference vector.
* [vec2reflect](#H3DU.MathUtil.vec2reflect)<br>Returns a vector that reflects off a surface.
* [vec2scale](#H3DU.MathUtil.vec2scale)<br>Multiplies each element of a 2-element vector by a factor.
* [vec2scaleInPlace](#H3DU.MathUtil.vec2scaleInPlace)<br>Multiplies each element of a 2-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor.
* [vec2sub](#H3DU.MathUtil.vec2sub)<br>Subtracts the second vector from the first vector and returns a new
vector with the result.
* [vec2subInPlace](#H3DU.MathUtil.vec2subInPlace)<br>Subtracts the second vector from the first vector and stores
the result in the first vector.
* [vec3abs](#H3DU.MathUtil.vec3abs)<br>Returns a new 3-element
vector with the absolute value of each of its components.
* [vec3absInPlace](#H3DU.MathUtil.vec3absInPlace)<br>Sets each component of the given 3-element
vector to its absolute value.
* [vec3add](#H3DU.MathUtil.vec3add)<br>Adds two 3-element vectors and returns a new
vector with the result.
* [vec3addInPlace](#H3DU.MathUtil.vec3addInPlace)<br>Adds two 3-element vectors and stores
the result in the first vector.
* [vec3assign](#H3DU.MathUtil.vec3assign)<br>Assigns the values of a 3-element vector into another
3-element vector.
* [vec3clamp](#H3DU.MathUtil.vec3clamp)<br>Returns a 3-element vector in which each element of the given 3-element vector is clamped
so it's not less than one value or greater than another value.
* [vec3clampInPlace](#H3DU.MathUtil.vec3clampInPlace)<br>Clamps each element of the given 3-element vector
so it's not less than one value or greater than another value.
* [vec3copy](#H3DU.MathUtil.vec3copy)<br>Returns a copy of a 3-element vector.
* [vec3cross](#H3DU.MathUtil.vec3cross)<br>Finds the cross product of two 3-element vectors (called A and B).
* [vec3dist](#H3DU.MathUtil.vec3dist)<br>Finds the straight-line distance from one three-element vector
to another, treating both as 3D points.
* [vec3dot](#H3DU.MathUtil.vec3dot)<br>Finds the dot product of two 3-element vectors.
* [vec3fromWindowPoint](#H3DU.MathUtil.vec3fromWindowPoint)<br>Unprojects the <i>window coordinates</i> given in a
3-element vector,
using the given transformation matrix and viewport
rectangle.
* [vec3length](#H3DU.MathUtil.vec3length)<br>Returns the distance of this 3-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
* [vec3lerp](#H3DU.MathUtil.vec3lerp)<br>Does a linear interpolation between two 3-element vectors;
returns a new vector.
* [vec3mul](#H3DU.MathUtil.vec3mul)<br>Multiplies each of the components of two 3-element vectors and returns a new
vector with the result.
* [vec3mulInPlace](#H3DU.MathUtil.vec3mulInPlace)<br>Multiplies each of the components of two 3-element vectors and stores
the result in the first vector.
* [vec3negate](#H3DU.MathUtil.vec3negate)<br>Negates a 3-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction.
* [vec3negateInPlace](#H3DU.MathUtil.vec3negateInPlace)<br>Negates a 3-element vector in place, generally resulting in a vector with
the same length but opposite direction.
* [vec3normalize](#H3DU.MathUtil.vec3normalize)<br>Converts a 3-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
* [vec3normalizeInPlace](#H3DU.MathUtil.vec3normalizeInPlace)<br>Converts a 3-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
* [vec3perp](#H3DU.MathUtil.vec3perp)<br>Returns an arbitrary 3-element vector that is perpendicular
(orthogonal) to the given 3-element vector.
* [vec3proj](#H3DU.MathUtil.vec3proj)<br>Returns the projection of a 3-element vector on the given
reference vector.
* [vec3reflect](#H3DU.MathUtil.vec3reflect)<br>Returns a vector that reflects off a surface.
* [vec3scale](#H3DU.MathUtil.vec3scale)<br>Multiplies each element of a 3-element vector by a factor.
* [vec3scaleInPlace](#H3DU.MathUtil.vec3scaleInPlace)<br>Multiplies each element of a 3-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor.
* [vec3sub](#H3DU.MathUtil.vec3sub)<br>Subtracts the second vector from the first vector and returns a new
vector with the result.
* [vec3subInPlace](#H3DU.MathUtil.vec3subInPlace)<br>Subtracts the second vector from the first vector and stores
the result in the first vector.
* [vec3toWindowPoint](#H3DU.MathUtil.vec3toWindowPoint)<br>Transforms the 3D point specified in this 3-element vector to its
<i>window coordinates</i>
using the given transformation matrix and viewport rectangle.
* [vec3triple](#H3DU.MathUtil.vec3triple)<br>Finds the scalar triple product of three vectors (A, B, and C).
* [vec4abs](#H3DU.MathUtil.vec4abs)<br>Returns a new 4-element
vector with the absolute value of each of its components.
* [vec4absInPlace](#H3DU.MathUtil.vec4absInPlace)<br>Sets each component of the given 4-element
vector to its absolute value.
* [vec4add](#H3DU.MathUtil.vec4add)<br>Adds two 4-element vectors and returns a new
vector with the result.
* [vec4addInPlace](#H3DU.MathUtil.vec4addInPlace)<br>Adds two 4-element vectors and stores
the result in the first vector.
* [vec4assign](#H3DU.MathUtil.vec4assign)<br>Assigns the values of a 4-element vector into another
4-element vector.
* [vec4clamp](#H3DU.MathUtil.vec4clamp)<br>Returns a 4-element vector in which each element of the given 4-element vector is clamped
* [vec4clampInPlace](#H3DU.MathUtil.vec4clampInPlace)<br>Clamps each element of the given 4-element vector
so it's not less than one value or greater than another value.
* [vec4copy](#H3DU.MathUtil.vec4copy)<br>Returns a copy of a 4-element vector.
* [vec4dot](#H3DU.MathUtil.vec4dot)<br>Finds the dot product of two 4-element vectors.
* [vec4length](#H3DU.MathUtil.vec4length)<br>Returns the distance of this 4-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
* [vec4lerp](#H3DU.MathUtil.vec4lerp)<br>Does a linear interpolation between two 4-element vectors;
returns a new vector.
* [vec4negate](#H3DU.MathUtil.vec4negate)<br>Negates a 4-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction.
* [vec4negateInPlace](#H3DU.MathUtil.vec4negateInPlace)<br>Negates a 4-element vector in place, generally resulting in a vector with
the same length but opposite direction.
* [vec4normalize](#H3DU.MathUtil.vec4normalize)<br>Converts a 4-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
* [vec4normalizeInPlace](#H3DU.MathUtil.vec4normalizeInPlace)<br>Converts a 4-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
* [vec4proj](#H3DU.MathUtil.vec4proj)<br>Returns the projection of a 4-element vector on the given
reference vector.
* [vec4scale](#H3DU.MathUtil.vec4scale)<br>Multiplies each element of a 4-element vector by a factor, returning
a new vector that is parallel to the old vector
but with its length multiplied by the given factor.
* [vec4scaleInPlace](#H3DU.MathUtil.vec4scaleInPlace)<br>Multiplies each element of a 4-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor.
* [vec4sub](#H3DU.MathUtil.vec4sub)<br>Subtracts the second vector from the first vector and returns a new
vector with the result.
* [vec4subInPlace](#H3DU.MathUtil.vec4subInPlace)<br>Subtracts the second vector from the first vector and stores
the result in the first vector.
* [velocity](#extras_evaluators_Trochoid_velocity)<br>Finds the velocity (derivative) of this curve at the given point.
* [vertexCount](#H3DU.ShapeGroup_vertexCount)<br>Gets the number of vertices composed by all shapes in this shape group.
* [vertexIndices](#H3DU.MeshBuffer_vertexIndices)<br>Gets the vertex indices of a given primitive (triangle, line,
or point) in this mesh buffer.
* [wireFrame](#H3DU.MeshBuffer_wireFrame)<br>Converts the triangles in this mesh to line segments.
* [xor](#H3DU.GraphicsPath_xor)<br>Computes the shape contained in either this path or another path,
but not both.

<a name='extras_camera_InputTracker.A'></a>
### module:extras/camera~InputTracker.A (constant)

Key code for the A key. Add 1 through 25 to get
the keys for the other letters of the English alphabet.

Default Value: `65`

<a name='extras_camera_InputTracker.ADD'></a>
### module:extras/camera~InputTracker.ADD (constant)

Key code for the plus key.

Default Value: `107`

<a name='extras_camera_InputTracker.ALT'></a>
### module:extras/camera~InputTracker.ALT (constant)

Key code for the return key.

Default Value: `18`

<a name='Semantic.BITANGENT'></a>
### Semantic.BITANGENT (constant)

Attribute semantic for a bitangent vector.

<a name='Semantic.COLOR'></a>
### Semantic.COLOR (constant)

Attribute semantic for a color.
The default shader uses 3-component colors.

<a name='extras_camera_InputTracker.CTRL'></a>
### module:extras/camera~InputTracker.CTRL (constant)

Key code for the return key.

Default Value: `17`

<a name='Semantic.CUSTOM'></a>
### Semantic.CUSTOM (constant)

Attribute semantic for custom attributes.

<a name='extras_camera_InputTracker.DELETE'></a>
### module:extras/camera~InputTracker.DELETE (constant)

Key code for the delete key.

Default Value: `46`

<a name='H3DU.BSplineCurve.DIVIDE_BIT'></a>
### H3DU.BSplineCurve.DIVIDE_BIT (constant)

Indicates to divide each other coordinate of the returned point
by the last coordinate of the point and omit the last
coordinate. This is used to convert
homogeneous coordinates to conventional coordinates.
If this bit is set, the length of each control point must be at least 2.

A B-spline curve that has control points whose last coordinate is other than
1 is a <i>rational</i> B-spline curve.

Default Value: `2`

<a name='extras_camera_InputTracker.DOWN'></a>
### module:extras/camera~InputTracker.DOWN (constant)

Key code for the down arrow key.

Default Value: `40`

<a name='extras_camera_InputTracker.END'></a>
### module:extras/camera~InputTracker.END (constant)

Key code for the end key.

Default Value: `35`

<a name='extras_camera_InputTracker.ENTER'></a>
### module:extras/camera~InputTracker.ENTER (constant)

Key code for the enter key.

Default Value: `13`

<a name='extras_camera_InputTracker.ESC'></a>
### module:extras/camera~InputTracker.ESC (constant)

Key code for the return key.

Default Value: `27`

<a name='H3DU.MathUtil.GlobalPitchRollYaw'></a>
### H3DU.MathUtil.GlobalPitchRollYaw (constant)

Indicates that a vector's rotation occurs as a pitch, then roll, then yaw (each rotation around the original axes).

<a name='H3DU.MathUtil.GlobalPitchYawRoll'></a>
### H3DU.MathUtil.GlobalPitchYawRoll (constant)

Indicates that a vector's rotation occurs as a pitch, then yaw, then roll (each rotation around the original axes),
or in the reverse order around

<a name='H3DU.MathUtil.GlobalRollPitchYaw'></a>
### H3DU.MathUtil.GlobalRollPitchYaw (constant)

Indicates that a vector's rotation occurs as a roll, then pitch, then yaw (each rotation around the original axes).

<a name='H3DU.MathUtil.GlobalRollYawPitch'></a>
### H3DU.MathUtil.GlobalRollYawPitch (constant)

Indicates that a vector's rotation occurs as a roll, then yaw, then pitch (each rotation around the original axes).

<a name='H3DU.MathUtil.GlobalYawPitchRoll'></a>
### H3DU.MathUtil.GlobalYawPitchRoll (constant)

Indicates that a vector's rotation occurs as a yaw, then pitch, then roll (each rotation around the original axes).

<a name='H3DU.MathUtil.GlobalYawRollPitch'></a>
### H3DU.MathUtil.GlobalYawRollPitch (constant)

Indicates that a vector's rotation occurs as a yaw, then roll, then pitch (each rotation around the original axes).

<a name='extras_camera_InputTracker.HOME'></a>
### module:extras/camera~InputTracker.HOME (constant)

Key code for the home key.

Default Value: `36`

<a name='H3DU.MathUtil.HalfPi'></a>
### H3DU.MathUtil.HalfPi (constant)

Closest approximation to pi divided by 2, or a 90-degree turn in radians.

Default Value: `1.5707963267948966`

<a name='Semantic.JOINT'></a>
### Semantic.JOINT (constant)

Attribute semantic for a skinning joint.

<a name='Semantic.JOINTMATRIX'></a>
### Semantic.JOINTMATRIX (constant)

Uniform semantic for a joint matrix.

<a name='extras_camera_InputTracker.LEFT'></a>
### module:extras/camera~InputTracker.LEFT (constant)

Key code for the left arrow key.

Default Value: `37`

<a name='H3DU.MeshBuffer.LINES'></a>
### H3DU.MeshBuffer.LINES (constant)

TODO: Not documented yet.

<a name='H3DU.MathUtil.LocalPitchRollYaw'></a>
### H3DU.MathUtil.LocalPitchRollYaw (constant)

Indicates that a vector's rotation occurs as a pitch, then roll, then yaw, where the roll and yaw
occur around the rotated object's new axes and not necessarily the original axes.

<a name='H3DU.MathUtil.LocalPitchYawRoll'></a>
### H3DU.MathUtil.LocalPitchYawRoll (constant)

Indicates that a vector's rotation occurs as a pitch, then yaw, then roll, where the yaw and roll
occur around the rotated object's new axes and not necessarily the original axes.

<a name='H3DU.MathUtil.LocalRollPitchYaw'></a>
### H3DU.MathUtil.LocalRollPitchYaw (constant)

Indicates that a vector's rotation occurs as a roll, then pitch, then yaw, where the pitch and yaw
occur around the rotated object's new axes and not necessarily the original axes.

<a name='H3DU.MathUtil.LocalRollYawPitch'></a>
### H3DU.MathUtil.LocalRollYawPitch (constant)

Indicates that a vector's rotation occurs as a roll, then yaw, then pitch, where the yaw and pitch
occur around the rotated object's new axes and not necessarily the original axes.

<a name='H3DU.MathUtil.LocalYawPitchRoll'></a>
### H3DU.MathUtil.LocalYawPitchRoll (constant)

Indicates that a vector's rotation occurs as a yaw, then pitch, then roll, where the pitch and roll
occur around the rotated object's new axes and not necessarily the original axes.

<a name='H3DU.MathUtil.LocalYawRollPitch'></a>
### H3DU.MathUtil.LocalYawRollPitch (constant)

Indicates that a vector's rotation occurs as a yaw, then roll, then pitch, where the roll and pitch
occur around the rotated object's new axes and not necessarily the original axes.

<a name='Semantic.MODEL'></a>
### Semantic.MODEL (constant)

Uniform semantic for a model matrix.

<a name='Semantic.MODELVIEW'></a>
### Semantic.MODELVIEW (constant)

Uniform semantic for a model-view matrix.

<a name='Semantic.MODELVIEWINVERSETRANSPOSE'></a>
### Semantic.MODELVIEWINVERSETRANSPOSE (constant)

Uniform semantic for the inverse of the 3x3 transpose of the model-view matrix.

<a name='Semantic.MODELVIEWPROJECTION'></a>
### Semantic.MODELVIEWPROJECTION (constant)

Uniform semantic for a model-view-projection matrix.

<a name='Semantic.NORMAL'></a>
### Semantic.NORMAL (constant)

Attribute semantic for a vertex normal.
The default shader uses 3-dimensional normals.

<a name='H3DU.MathUtil.Num180DividedByPi'></a>
### H3DU.MathUtil.Num180DividedByPi (constant)

Closest approximation to 180 divided by pi, or the number of
degrees in a radian. Multiply by this number to convert radians to degrees.

Default Value: `57.29577951308232`

<a name='extras_camera_InputTracker.PAGEDOWN'></a>
### module:extras/camera~InputTracker.PAGEDOWN (constant)

Key code for the page down key.

Default Value: `34`

<a name='extras_camera_InputTracker.PAGEUP'></a>
### module:extras/camera~InputTracker.PAGEUP (constant)

Key code for the page up key.

Default Value: `33`

<a name='H3DU.MeshBuffer.POINTS'></a>
### H3DU.MeshBuffer.POINTS (constant)

TODO: Not documented yet.

<a name='Semantic.POSITION'></a>
### Semantic.POSITION (constant)

Attribute semantic for a vertex position.
The default shader uses 3-dimensional positions.

<a name='Semantic.PROJECTION'></a>
### Semantic.PROJECTION (constant)

Uniform semantic for a projection matrix.

<a name='H3DU.MathUtil.PiDividedBy180'></a>
### H3DU.MathUtil.PiDividedBy180 (constant)

Closest approximation to pi divided by 180, or the number
of radians in a degree. Multiply by this number to convert degrees to radians.

Default Value: `0.017453292519943295`

<a name='H3DU.MathUtil.PiTimes2'></a>
### H3DU.MathUtil.PiTimes2 (constant)

Closest approximation to pi times 2, or a 360-degree turn in radians.

Default Value: `6.283185307179586`

<a name='extras_camera_InputTracker.RETURN'></a>
### module:extras/camera~InputTracker.RETURN (constant)

Key code for the return key.

Default Value: `10`

<a name='extras_camera_InputTracker.RIGHT'></a>
### module:extras/camera~InputTracker.RIGHT (constant)

Key code for the right arrow key.

Default Value: `39`

<a name='extras_camera_InputTracker.SHIFT'></a>
### module:extras/camera~InputTracker.SHIFT (constant)

Key code for the shift key.

Default Value: `16`

<a name='extras_camera_InputTracker.SPACE'></a>
### module:extras/camera~InputTracker.SPACE (constant)

Key code for the space bar.

Default Value: `32`

<a name='extras_camera_InputTracker.SUBTRACT'></a>
### module:extras/camera~InputTracker.SUBTRACT (constant)

Key code for the minus key.

Default Value: `109`

<a name='extras_camera_InputTracker.TAB'></a>
### module:extras/camera~InputTracker.TAB (constant)

Key code for the tab key.

Default Value: `9`

<a name='Semantic.TANGENT'></a>
### Semantic.TANGENT (constant)

Attribute semantic for a tangent vector.

<a name='Semantic.TEXCOORD'></a>
### Semantic.TEXCOORD (constant)

Attribute semantic for a texture coordinate.

Note that the default shader supports only 2-dimensional
texture coordinates. For such texturing tasks as mapping
a square to a trapezoid, 3-dimensional texture coordinates
are useful to ensure the texturing is perspective-correct.
In this case, the 3-D texture coordinates are converted
to 2-D by dividing the X and Y components by the Z component.
In a fragment shader, this can look like the following
code: <code>texCoord.xy/texCoord.z</code>.

<a name='H3DU.MeshBuffer.TRIANGLES'></a>
### H3DU.MeshBuffer.TRIANGLES (constant)

TODO: Not documented yet.

<a name='H3DU.MathUtil.ToDegrees'></a>
### H3DU.MathUtil.ToDegrees (constant)

Closest approximation to 180 divided by pi, or the number of
degrees in a radian. Multiply by this number to convert radians to degrees.

<a name='H3DU.MathUtil.ToRadians'></a>
### H3DU.MathUtil.ToRadians (constant)

Closest approximation to pi divided by 180, or the number
of radians in a degree. Multiply by this number to convert degrees to radians.

<a name='extras_camera_InputTracker.UP'></a>
### module:extras/camera~InputTracker.UP (constant)

Key code for the up arrow key.

Default Value: `38`

<a name='Semantic.VIEW'></a>
### Semantic.VIEW (constant)

Uniform semantic for a view matrix.

<a name='Semantic.VIEWINVERSE'></a>
### Semantic.VIEWINVERSE (constant)

Uniform semantic for an inverse view matrix.

<a name='Semantic.WEIGHT'></a>
### Semantic.WEIGHT (constant)

Attribute semantic for a skinning weight.

<a name='extras_camera_InputTracker.ZERO'></a>
### module:extras/camera~InputTracker.ZERO (constant)

Key code for the 0 key. Add 1 through 9 to get
the keys for the other basic digits 1 through 9.

Default Value: `48`

<a name='H3DU.BufferAccessor_buffer'></a>
### H3DU.BufferAccessor#buffer

A <i>buffer</i> of arbitrary size. This buffer
is made up of <i>values</i>, one for each vertex, and each value
takes up one or more <i>elements</i> in the buffer, which are numbers such
as X coordinates or red components, depending on the attribute's semantic.
Each value has the same number of elements. An example of a <i>value</i>
is (10, 20, 5), which can take up three consecutive <i>elements</i>
in a <code>Float32Array</code> buffer such as the one given in this
property.

Type: Float32Array

<a name='extras_checkerboardshader.checkerboardShader'></a>
### module:extras/checkerboardshader.checkerboardShader

TODO: Not documented yet.

<a name='extras_colormatrixshader.colorMatrixShader'></a>
### module:extras/colormatrixshader.colorMatrixShader

GLSL shader data for a family of image processing filters, which modify colors based on a transformation matrix, a 4x4 matrix that is multiplied by the red/green/blue color to get a new color. The shader program takes three uniforms: "sampler", which
is the input texture, "t", a value from 0 to 1 indicating how strongly to
apply the color matrix, and "matrix", which is the 4x4 matrix just described.

<a name='H3DU.BufferAccessor_countPerValue'></a>
### H3DU.BufferAccessor#countPerValue

A count of the number of elements each value has. For example, 3-dimensional
positions will have 3 elements, one for each coordinate.

Type: number

<a name='extras_camera_InputTracker_deltaXY'></a>
### module:extras/camera~InputTracker#deltaXY

**Deprecated: Yes**

An alias for InputTracker#mousePos.

<a name='extras_horgradshader.horGradientShader'></a>
### module:extras/horgradshader.horGradientShader

TODO: Not documented yet.

<a name='extras_kernelmatrixshader.kernelMatrixShader'></a>
### module:extras/kernelmatrixshader.kernelMatrixShader

GLSL shader code for a family of image processing filters, such as blurring, sharpening,
edge detection, and embossing, that process each pixel and its neighbors. This filter takes
a 3x3 matrix called a _convolution kernel_, which gives the contribution of each pixel's color to the final color. All the numbers in the matrix usually add up to 1. An example of a convolution kernel:

    [ 0, 1/8, 0,
    1/8, 1/2, 1/8,
    0, 1/8, 0 ]

This matrix means that the destination pixel will have 1/2 of the original pixel's color, and 1/8 of the
colors of its 4 adjacent pixels. Note that this example adds up to 1.
![\*\*Blur filtered image\*\*](filters4.png)
![\*\*Edge detect filtered image\*\*](filters8.png)
This shader program takes three uniforms: "sample", the source texture;
"textureSize", the width and height of the texture in pixels;
"matrix", the 3x3 convolution kernel.

<a name='extras_camera_InputTracker_leftButton'></a>
### module:extras/camera~InputTracker#leftButton

True if the left mouse button was detected as being down.

Type: boolean

<a name='extras_marbleshader.marbleShader'></a>
### module:extras/marbleshader.marbleShader

TODO: Not documented yet.

<a name='extras_marbleshader2.marbleShader2'></a>
### module:extras/marbleshader2.marbleShader2

TODO: Not documented yet.

<a name='extras_camera_InputTracker_middleButton'></a>
### module:extras/camera~InputTracker#middleButton

True if the middle mouse button was detected as being down.

Type: boolean

<a name='extras_mirrorshader.mirrorShader'></a>
### module:extras/mirrorshader.mirrorShader

TODO: Not documented yet.

<a name='H3DU.BufferAccessor_offset'></a>
### H3DU.BufferAccessor#offset

An offset, which identifies the index, starting from 0, of the first value
of the attribute within the buffer. The offset counts the number of
elements in the buffer to the first value. For example, if this property is 6,
then the first element of the first value in the buffer is found at
<code>acc.buffer[acc.offset]</code> (assuming the buffer is
more than 6 elements long).

Type: number

<a name='extras_pixelateshader.pixelateShader'></a>
### module:extras/pixelateshader.pixelateShader

TODO: Not documented yet.

<a name='extras_radgradshader.radialGradientShader'></a>
### module:extras/radgradshader.radialGradientShader

TODO: Not documented yet.

<a name='extras_camera_InputTracker_rightButton'></a>
### module:extras/camera~InputTracker#rightButton

True if the right mouse button was detected as being down.

Type: boolean

<a name='H3DU.ShapeGroup_shapes'></a>
### H3DU.ShapeGroup#shapes

**Deprecated: Use the ShapeGroup#shapeCount,
ShapeGroup#getShape, and
ShapeGroup#setShape methods instead.**

List of shapes contained in this group.
This property should only be used to access properties
and call methods on each shape, and not to add, remove
or replace shapes directly.

<a name='extras_skysphereshader.skySphereCubeMapShader'></a>
### module:extras/skysphereshader.skySphereCubeMapShader

TODO: Not documented yet.

<a name='extras_skysphereshader.skySphereShader'></a>
### module:extras/skysphereshader.skySphereShader

TODO: Not documented yet.

<a name='H3DU.BufferAccessor_stride'></a>
### H3DU.BufferAccessor#stride

A stride, which gives the number of elements from the start of one
value to the start of the next. A "packed" buffer will have a stride
equal to the count per value.

Type: number

<a name='extras_stripesbackshader.stripesBackShader'></a>
### module:extras/stripesbackshader.stripesBackShader

TODO: Not documented yet.

<a name='extras_sunburstbackshader.sunburstBackShader'></a>
### module:extras/sunburstbackshader.sunburstBackShader

TODO: Not documented yet.

<a name='extras_vignetteshader.vignetteShader'></a>
### module:extras/vignetteshader.vignetteShader

TODO: Not documented yet.

<a name='extras_warpshader.warpShader'></a>
### module:extras/warpshader.warpShader

TODO: Not documented yet.

<a name='extras_waterpaintshader.waterpaintShader'></a>
### module:extras/waterpaintshader.waterpaintShader

TODO: Not documented yet.

<a name='extras_waveshader.waveShader'></a>
### module:extras/waveshader.waveShader

TODO: Not documented yet.

<a name='extras_woodshader.woodShader'></a>
### module:extras/woodshader.woodShader

TODO: Not documented yet.

<a name='extras_fourierknot.FourierKnot'></a>
### (static) module:extras/fourierknot.FourierKnot(a, b)

A curve evaluator object that calculates a knot in the form of the Fourier series

<b>F</b>(u) = &Sigma;<sub>i=1, n</sub> <b>a</b> cos(<i>iu</i>) + <b>b</b> sin(<i>iu</i>).

#### Parameters

* `a` (Type: Array.&lt;Array.&lt;number>>)<br>The cosine coefficients.
* `b` (Type: Array.&lt;Array.&lt;number>>)<br>The sine coefficients.

<a name='extras_moresurfaces.MoebiusLikeStrip'></a>
### (static) module:extras/moresurfaces.MoebiusLikeStrip(maj, a, b)

TODO: Not documented yet.

#### Parameters

* `maj` (Type: *)
* `a` (Type: *)
* `b` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_starfield.StarField'></a>
### (static) module:extras/starfield.StarField(range)

TODO: Not documented yet.

#### Parameters

* `range` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.Curve_accel'></a>
### H3DU.Curve#accel(u)

Finds an approximate acceleration vector at the given U coordinate of this curve.
The implementation in Curve calls the evaluator's <code>accel</code>
method if it implements it; otherwise, does a numerical differentiation using
the velocity vector.

The <b>acceleration</b> of a curve is a vector which is the second-order derivative of the curve's position at the given coordinate. The vector returned by this method <i>should not</i> be "normalized" to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `u` (Type: number)<br>U coordinate of a point on the curve.

#### Return Value

An array describing an acceleration vector. It should have at least as many
elements as the number of dimensions of the underlying curve. (Type: Array.&lt;number>)

<a name='H3DU.ShapeGroup_addShape'></a>
### H3DU.ShapeGroup#addShape(shape)

Adds a 3D shape to this shape group, at the end of the list
of shapes. Its reference, not a copy,
will be stored in the list of shapes.

#### Parameters

* `shape` (Type: Shape | ShapeGroup)<br>A 3D shape. Throws an error if null.

#### Return Value

This object. (Type: ShapeGroup)

<a name='Promise.all'></a>
### (static) Promise.all(all)

Wait for all these promises to complete. One failed => this fails too.

#### Parameters

* `all` (Type: Array.&lt;<a href="Promise.md">Promise</a>>)<br>An array of promises.

#### Return Value

A promise that is resolved when all promises have resolved. (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.GraphicsPath_arc'></a>
### H3DU.GraphicsPath#arc(x, y, radius, startAngle, endAngle, ccw)

Adds path segments in the form of a circular arc to this path,
using the parameterization specified in the "arc" method of the
HTML Canvas 2D Context.

#### Parameters

* `x` (Type: number)<br>X coordinate of the center of the circle that the arc forms a part of.
* `y` (Type: number)<br>Y coordinate of the circle's center.
* `radius` (Type: number)<br>Radius of the circle.
* `startAngle` (Type: number)<br>Starting angle of the arc, in radians. 0 means the positive X axis, &pi;/2 means the positive Y axis, &pi; means the negative X axis, and &pi;\*1.5 means the negative Y axis.
* `endAngle` (Type: number)<br>Ending angle of the arc, in radians.
* `ccw` (Type: boolean)<br>Whether the arc runs counterclockwise (assuming the X axis points right and the Y axis points down under the coordinate system).

#### Return Value

This object. (Type: GraphicsPath)

<a name='extras_evaluators_Hypotrochoid_arcLength'></a>
### module:extras/evaluators~Hypotrochoid#arcLength(u)

Finds an approximate arc length (distance) between the start of this
curve and the point at the given U coordinate of this curve.

#### Parameters

* `u` (Type: number)<br>U coordinate of a point on the curve.

#### Return Value

The approximate arc length of this curve at the given U coordinate. (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_arcShape'></a>
### H3DU.GraphicsPath#arcShape(x, y, w, h, start, sweep, type)

Adds path segments to this path that form an arc running along an axis-aligned
ellipse, or a shape based on that arc and ellipse, given the ellipse's center
and dimensions, start angle, and sweep angle.

#### Parameters

* `x` (Type: number)<br>X coordinate of the ellipse's center.
* `y` (Type: number)<br>Y coordinate of the ellipse's center.
* `w` (Type: number)<br>Width of the ellipse's bounding box.
* `h` (Type: number)<br>Height of the ellipse's bounding box.
* `start` (Type: number)<br>Starting angle of the arc, in degrees. 0 means the positive X axis, 90 means the positive Y axis, 180 means the negative X axis, and 270 means the negative Y axis.
* `sweep` (Type: number)<br>Length of the arc in degrees. Can be positive or negative. Can be greater than 360 or less than -360, in which case the arc will wrap around the ellipse multiple times. Assuming the coordinate system's X axis points right and the Y axis down, positive angles run clockwise and negative angles counterclockwise.
* `type` (Type: number)<br>Type of arc to append to the path. If 0, will append an unclosed arc. If 1, will append an elliptical segment to the path (the arc and a line segment connecting its ends). If 2, will append a "pie slice" to the path (the arc and two line segments connecting each end of the arc to the ellipse's center).

#### Return Value

This object. If "w" or "h" is 0, no path segments will be appended. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_arcShapeForBox'></a>
### H3DU.GraphicsPath#arcShapeForBox(x, y, w, h, start, sweep, type)

Adds path segments to this path that form an arc running along an axis-aligned
ellipse, or a shape based on that arc and ellipse, given the ellipse's corner point
and dimensions, start angle, and sweep angle.

#### Parameters

* `x` (Type: number)<br>X coordinate of the ellipse's bounding box's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `y` (Type: number)<br>Y coordinate of the ellipse's bounding box's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `w` (Type: number)<br>Width of the ellipse's bounding box.
* `h` (Type: number)<br>Height of the ellipse's bounding box.
* `start` (Type: number)<br>Starting angle of the arc, in degrees. 0 means the positive X axis, 90 means the positive Y axis, 180 means the negative X axis, and 270 means the negative Y axis.
* `sweep` (Type: number)<br>Length of the arc in degrees. Can be greater than 360 or less than -360, in which case the arc will wrap around the ellipse multiple times. Assuming the coordinate system's X axis points right and the Y axis down, positive angles run clockwise and negative angles counterclockwise.
* `type` (Type: number)<br>Type of arc to append to the path. If 0, will append an unclosed arc. If 1, will append an elliptical segment to the path (the arc and a line segment connecting its ends). If 2, will append a "pie slice" to the path (the arc and two line segments connecting each end of the arc to the ellipse's center).

#### Return Value

This object. If "w" or "h" is 0, no path segments will be appended. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_arcSvgTo'></a>
### H3DU.GraphicsPath#arcSvgTo(rx, ry, rot, largeArc, sweep, x2, y2)

Adds path segments in the form of an elliptical arc to this path,
using the parameterization used by the SVG specification.

#### Parameters

* `rx` (Type: number)<br>X axis radius of the ellipse that the arc will be formed from.
* `ry` (Type: number)<br>Y axis radius of the ellipse that the arc will be formed from.
* `rot` (Type: number)<br>Rotation of the ellipse in degrees (clockwise assuming the X axis points right and the Y axis points down under the coordinate system).
* `largeArc` (Type: boolean)<br>In general, there are four possible solutions for arcs given the start and end points, rotation, and x- and y-radii. If true, chooses an arc solution with the larger arc length; if false, smaller.
* `sweep` (Type: boolean)<br>If true, the arc solution chosen will run clockwise (assuming the X axis points right and the Y axis points down under the coordinate system); if false, counterclockwise.
* `x2` (Type: number)<br>X coordinate of the arc's end point.
* `y2` (Type: number)<br>Y coordinate of the arc's end point.

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_arcTo'></a>
### H3DU.GraphicsPath#arcTo(x1, y1, x2, y2, radius)

Adds path segments in the form of a circular arc to this path,
using the parameterization specified in the "arcTo" method of the
HTML Canvas 2D Context.

#### Parameters

* `x1` (Type: number)<br>X coordinate of a point that, along with the current end point, forms a tangent line. The point where the circle touches this tangent line is the start point of the arc, and if the point isn't the same as the current end point, this method adds a line segment connecting the two points. (Note that the start point of the arc is not necessarily the same as (x1, y1) or the current end point.)
* `y1` (Type: number)<br>Y coordinate of the point described under "x1".
* `x2` (Type: number)<br>X coordinate of a point that, along with the point (x1, y1), forms a tangent line. The point where the circle touches this tangent line is the end point of the arc. (Note that the end point of the arc is not necessarily the same as (x1, y1) or (x2, y2).) When this method returns, the current end point will be set to the end point of the arc.
* `y2` (Type: number)<br>Y coordinate of the point described under "x2".
* `radius` (Type: number)<br>Radius of the circle the arc forms a part of.

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_arrow'></a>
### H3DU.GraphicsPath#arrow(x0, y0, x1, y1, headWidth, headLength, tailWidth)

Adds path segments to this path in the form of an arrow shape.

#### Parameters

* `x0` (Type: number)<br>X coordinate of the arrow's tail, at its very end.
* `y0` (Type: number)<br>Y coordinate of the arrow's tail, at its very end.
* `x1` (Type: number)<br>X coordinate of the arrow's tip.
* `y1` (Type: number)<br>Y coordinate of the arrow's tip.
* `headWidth` (Type: number)<br>Width of the arrowhead's base from side to side.
* `headLength` (Type: number)<br>Length of the arrowhead from its tip to its base.
* `tailWidth` (Type: number)<br>Width of the arrow's tail from side to side

#### Return Value

This object. Nothing will be added to the path if the distance
from (x0, y0) and (x1, y1) is 0 or extremely close to 0. (Type: GraphicsPath)

<a name='H3DU.SurfaceBuilder_attribute'></a>
### H3DU.SurfaceBuilder#attribute(surface, semantic, [semanticIndex], [size])

Sets the parametric surface used to generate vertex attribute values.

#### Parameters

* `surface` (Type: Object)<br>A surface evaluator object that describes the parametric surface used to generate attribute values. U and V coordinates for the given surface correspond to U and V coordinates, respectively, for the surface used to generate vertex positions.
* `semantic` (Type: number | string)<br>An attribute semantic, such as <a href="Semantic.md#Semantic.POSITION">Semantic.POSITION</a>, "POSITION", or "TEXCOORD_0". Throws an error if this value is a string and the string is invalid.
* `semanticIndex` (Type: number) (optional)<br>The set index of the attribute for the given semantic. 0 is the first index of the attribute, 1 is the second, and so on. This is ignored if "name" is a string. If null or undefined, this value is 0.
* `size` (Type: number) (optional)<br>The number of elements in each position and normal. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 3. Throws an error if this value is 0 or less.

#### Return Value

This object. (Type: SurfaceBuilder)

#### Examples

The following example sets the surface
function for texture coordinates to a linear evaluator. Thus, coordinates passed to the
evalSurface method will be interpolated as direct
texture coordinates.

    surface.attribute({"evaluate":function(u,v) {
    "use strict"; return [u,v] }},Semantic.TEXCOORD);

<a name='H3DU.GraphicsPath_bevelRect'></a>
### H3DU.GraphicsPath#bevelRect(x, y, w, h, arccx, arccy)

Adds path segments to this path that form an axis-aligned rectangle with beveled corners.

#### Parameters

* `x` (Type: number)<br>X coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `y` (Type: number)<br>Y coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `w` (Type: number)<br>Width of the rectangle.
* `h` (Type: number)<br>Height of the rectangle.
* `arccx` (Type: number)<br>Horizontal extent (from end to end) of the rectangle's corners. Will be adjusted to be not less than 0 and not greater than "w".
* `arccy` (Type: number)<br>Vertical extent (from end to end) of the rectangle's corners. Will be adjusted to be not less than 0 and not greater than "h".

#### Return Value

This object. If "w" or "h" is less than 0, no path segments will be appended. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_bezierCurveTo'></a>
### H3DU.GraphicsPath#bezierCurveTo(x, y, x2, y2, x3, y3)

Adds a cubic B&eacute;zier curve to this path starting
at this path's current position. The current position will be
the curve's first control point.

#### Parameters

* `x` (Type: number)<br>X coordinate of the curve's second control point.
* `y` (Type: number)<br>X coordinate of the curve's second control point.
* `x2` (Type: number)<br>Y coordinate of the curve's third control point.
* `y2` (Type: number)<br>Y coordinate of the curve's third control point.
* `x3` (Type: number)<br>X coordinate of the curve's end point (fourth control point).
* `y3` (Type: number)<br>Y coordinate of the curve's end point (fourth control point).

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.BSplineSurface_bitangent'></a>
### H3DU.BSplineSurface#bitangent(u, v)

Finds the bitangent vector at the
given point on the surface.

#### Parameters

* `u` (Type: number)<br>U coordinate of the surface to evaluate.
* `v` (Type: number)<br>V coordinate of the surface to evaluate.

#### Return Value

An array giving the bitangent vector.
It will have as many elements as a control point (or one fewer
if DIVIDE_BIT is set), as specified in the constructor. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.boxCenter'></a>
### (static) H3DU.MathUtil.boxCenter(box)

Finds the center of a 3D bounding box.

#### Parameters

* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box, which is an array of six values. The first three values are the smallest X, Y, and Z coordinates, and the last three values are the largest X, Y, and Z coordinates.

#### Return Value

A 3-element array containing the
X, Y, and Z coordinates, respectively, of the bounding box's
center. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.boxDimensions'></a>
### (static) H3DU.MathUtil.boxDimensions(box)

Finds the dimensions of a 3D bounding box. This is done by subtracting
the first three values of the given array with its last three values.

#### Parameters

* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box, which is an array of six values. The first three values are the smallest X, Y, and Z coordinates, and the last three values are the largest X, Y, and Z coordinates.

#### Return Value

A 3-element array containing the
width, height, and depth of the bounding box, respectively. If
at least one of the minimum coordinates is greater than its
corresponding maximum coordinate, the array can contain
negative values. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.boxIsEmpty'></a>
### (static) H3DU.MathUtil.boxIsEmpty(box)

Determines whether a 3D bounding box is empty.
This is determined if the minimum coordinate
is larger than the corresponding maximum coordinate.

#### Parameters

* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box, which is an array of six values. The first three values are the smallest X, Y, and Z coordinates, and the last three values are the largest X, Y, and Z coordinates.

#### Return Value

<code>true</code> if at least one
of the minimum coordinates is greater than its
corresponding maximum coordinate; otherwise, <code>false</code>. (Type: boolean)

<a name='Promise_Promise$1_catch'></a>
### Promise#Promise$1#catch(onRejected)

Creates a promise that calls a function if
this promise is rejected.

#### Parameters

* `onRejected` (Type: function)<br>To be called once this promise gets rejected

#### Return Value

A promise. (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.Curve_changeEnds'></a>
### H3DU.Curve#changeEnds(ep1, ep2)

Creates a curve evaluator object for a curve that is generated using
the same formula as this one (and uses the same U coordinates),
but has a different set of end points.
For example, this method can be used to shrink the path of a curve
from [0, &pi;] to [0, &pi;/8].

Note, however, that in general, shrinking
the range of a curve will not shrink the length of a curve
in the same proportion, unless the curve's path runs at
constant speed with respect to time. For example, shrinking the range of a curve
from [0, 1] to [0, 0.5] will not generally result in a curve that's exactly half as
long as the original curve.

For some curves, this method can
also be used to grow the path of the curve.

#### Parameters

* `ep1` (Type: number)<br>New start point of the curve.
* `ep2` (Type: number)<br>New end point of the curve.

#### Return Value

Return value. (Type: Curve)

<a name='H3DU.BSplineSurface.clamped'></a>
### (static) H3DU.BSplineSurface.clamped(controlPoints, [degreeU], [degreeV], [bits])

Creates a B-spline surface with uniform knots, except that
the surface's edges lie on the edges of the control point array.

#### Parameters

* `controlPoints` (Type: Array.&lt;Array.&lt;Array.&lt;number>>>)<br>Array of control point arrays as specified in the BSplineSurface constructor.
* `degreeU` (Type: number) (optional)<br>Degree of the B-spline surface along the U axis. For example, 3 means a degree-3 (cubic) curve. If null, undefined, or omitted, the default is 3.
* `degreeV` (Type: number) (optional)<br>Degree of the B-spline surface along the V axis If null, undefined, or omitted, the default is 3.
* `bits` (Type: number) (optional)<br>Bits as specified in the BSplineSurface constructor.

#### Return Value

Return value. The first
knot of the curve will be 0 and the last knot will be 1. (Type: BSplineSurface)

<a name='H3DU.BSplineCurve.clampedKnots'></a>
### (static) H3DU.BSplineCurve.clampedKnots(controlPoints, [degree])

Generates a knot vector with uniform knots, to be
passed to the BSplineCurve or BSplineCurve constructor,
except that with the knot vector the curve will start and end at the first and last control points and will
be tangent to the line between the first and second control points
and to the line between the next-to-last and last control points.

#### Parameters

* `controlPoints` (Type: number | Object)<br>Number of control points the curve will have, or an array of control points.
* `degree` (Type: number) (optional)<br>Degree of the B-spline curve. For example, 3 means a degree-3 (cubic) curve. If null, undefined, or omitted, the default is 3.

#### Return Value

A clamped uniform knot vector.
The first knot will be 0 and the last knot will be 1. (Type: Array.&lt;number>)

<a name='H3DU.SurfaceBuilder_clearVertices'></a>
### H3DU.SurfaceBuilder#clearVertices()

Clears the arrays of attribute values (such as positions and normals)
and vertex indices generated so far. The attributes themselves will remain.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='H3DU.GraphicsPath_closePath'></a>
### H3DU.GraphicsPath#closePath()

Makes this path closed. Adds a line segment to the
path's start position, if necessary.

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.MathUtil.colorToLinear'></a>
### (static) H3DU.MathUtil.colorToLinear(srgb)

Converts a color from companded sRGB to linear sRGB using the sRGB transfer function, and returns
a new vector with the result.

Linear RGB is linear because of its linear relationship of light emitted
by a surface of the given color.

#### Parameters

* `srgb` (Type: Array.&lt;number>)<br>A three- or four-element vector giving the red, green, and blue components, in that order, of an sRGB color. The alpha component is either the fourth element in the case of a four-element vector, or 1.0 in the case of a three-element vector. Each element in the vector ranges from 0 through 1.

#### Return Value

A three-element vector giving
the red, green, and blue components, in that order, of the given color
in linear sRGB. The alpha component will be as specified
in the "srgb" parameter. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.colorTosRGB'></a>
### (static) H3DU.MathUtil.colorTosRGB(lin)

Converts a color from linear sRGB to companded sRGB using the sRGB transfer function, and returns
a new vector with the result.

Linear RGB is linear because of its linear relationship of light emitted
by a surface of the given color.

#### Parameters

* `lin` (Type: Array.&lt;number>)<br>A three- or four-element vector giving the red, green, and blue components, in that order, of a linear RGB color. The alpha component is either the fourth element in the case of a four-element vector, or 1.0 in the case of a three-element vector. Each element in the vector ranges from 0 through 1.

#### Return Value

lin A four-element vector giving
the red, green, blue, and alpha components, in that order, of the given color
in companded sRGB. The alpha component will be as specified
in the "lin" parameter. (Type: Array.&lt;number>)

<a name='H3DU.SurfaceBuilder_constantAttribute'></a>
### H3DU.SurfaceBuilder#constantAttribute(constantValue, semantic, [semanticIndex])

Sets a value for an attribute semantic that will be the same for all
future vertices generated by the "evalSurface" method.

#### Parameters

* `constantValue` (Type: Object | number)<br>A constant value for the attribute semantic.
* `semantic` (Type: number | string)<br>An attribute semantic, such as <a href="Semantic.md#Semantic.POSITION">Semantic.POSITION</a>, "POSITION", or "TEXCOORD_0". Throws an error if this value is a string and the string is invalid.
* `semanticIndex` (Type: number) (optional)<br>The set index of the attribute for the given semantic. 0 is the first index of the attribute, 1 is the second, and so on. This is ignored if "name" is a string. If null or undefined, this value is 0.

#### Return Value

This object. (Type: SurfaceBuilder)

#### Examples

This example sets the color to use for future
vertices to be generated for the surface.

    // Set color to red
    curve.constantAttribute([1,0,0],"COLOR");

<a name='extras_drawingtoy_DrawingToy_continuousHypo'></a>
### module:extras/drawingtoy~DrawingToy#continuousHypo(ringTeeth, wheelTeeth, hole, phase, offset, holeStep, offsetStep, count)

Adds line segments that approximate one or more curves drawn by rolling a wheel inside a fixed ring (<i>hypotrochoids</i>), where each additional curve may be drawn from a different hole position, a different ring position, or both.

#### Parameters

* `ringTeeth` (Type: number)<br>Number of teeth in the fixed ring.
* `wheelTeeth` (Type: number)<br>Number of teeth in the rolling wheel.
* `hole` (Type: number)<br>Integer, starting from 1, identifying the hole within the wheel in which the drawing pen is placed. The greater the number, the closer the hole is to the center of the wheel.
* `phase` (Type: number)<br>Phase, in degrees, of the angle where the ring's and wheel's teeth are engaged. If null, undefined, or omitted, the default value is 0. TODO: Document this parameter more exactly.
* `offset` (Type: number)<br>X coordinate of the center of the fixed ring.
* `holeStep` (Type: number)<br>TODO: Not documented yet.
* `offsetStep` (Type: number)<br>TODO: Not documented yet.
* `count` (Type: number)<br>TODO: Not documented yet.

#### Return Value

This object. (Type: DrawingToy)

<a name='extras_contourlines.contourLines'></a>
### (static) module:extras/contourlines.contourLines(func, levels, u1, u2, v1, v2, usize, vsize)

Generates contour lines for two-dimensional data.

#### Parameters

* `func` (Type: function)<br>A function that takes two parameters--a U coordinate and a V coordinate--and returns a number at that point.
* `levels` (Type: Array.&lt;number>)<br>An array of values at which to draw contour lines. For example, if levels is `[20, 25]`, this function will draw contour lines along the values 20 and 25.
* `u1` (Type: number)<br>Starting U coordinate to sample.
* `u2` (Type: number)<br>Ending U coordinate to sample.
* `v1` (Type: number)<br>Starting V coordinate to sample.
* `v2` (Type: number)<br>Ending V coordinate to sample.
* `usize` (Type: number)<br>The number of levels between grid points along the U axis. This method will sample (usize+1)\*(vsize+1) grid points in total.
* `vsize` (Type: number)<br>The number of levels between grid points along the V axis.

#### Return Value

A mesh buffer of line segments for the contour lines. (Type: MeshBuffer)

#### Examples

This example generates contour lines for a simple
function. This method samples the function at integer grid points.

    var mesh=contourLines((u,v)=>(Math.sin((u+v)/6)),
    [0, 1, 2, 3],
    0,10,0,10,10,10);

<a name='H3DU.ShapeGroup_copy'></a>
### H3DU.ShapeGroup#copy()

Makes a copy of this shape group and the objects contained
in it. The copied object will
will have its own version of the transform and
visibility flag, and any objects contained in this one
will be copied using their <code>copy()</code> method.
The copied shape group won't have a parent.

#### Return Value

A copy of this shape group. (Type: ShapeGroup)

<a name='H3DU.BufferAccessor_count'></a>
### H3DU.BufferAccessor#count()

Gets the number of values defined for this accessor.

#### Return Value

The number of values defined in this accessor's buffer. (Type: number)

<a name='H3DU.Meshes.createBox'></a>
### (static) H3DU.Meshes.createBox(xSize, ySize, zSize, [inward])

Creates a mesh of a box (rectangular prism), which
will be centered at the origin.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.
Will create texture coordinates such that the same texture
is used on each face of the box. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner. The resulting mesh buffer
will use 36 vertex indices divided into 12 triangles, with each
face using two triangles. The faces will be ordered as follows:
Negative X face, positive X face, negative Y face,
positive Y face, negative Z face, positive Z face.

#### Parameters

* `xSize` (Type: number)<br>Width of the box.
* `ySize` (Type: number)<br>Height of the box.
* `zSize` (Type: number)<br>Depth of the box.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the box will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createCapsule'></a>
### (static) H3DU.Meshes.createCapsule([radius], [length], [slices], [stacks], [middleStacks], [flat], [inside])

Creates a mesh of a capsule, centered at the origin.
The length of the capsule will run along the Z axis. (If the capsule
has a high length and a very low radius, it will resemble a 3D line
with rounded corners.)

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive Z axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive X axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

If the "length" parameter is 0, the X, Y, and Z coordinates of a point on the solid
are as described in Meshes.createSphere.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of each spherical end of the capsule. May be null or omitted, in which case the default is 1.
* `length` (Type: number) (optional)<br>Length of the middle section. May be null or omitted, in which case the default is 1. If this value is 0, an approximation to a sphere will be generated.
* `slices` (Type: number) (optional)<br>Number of vertical sections the capsule consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections each spherical half consists of. May be null or omitted, in which case the default is 8.
* `middleStacks` (Type: number) (optional)<br>Number of vertical sections the middle of the capsule consists of. May be null or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the capsule will be flat shaded; otherwise, will generate normals such that the capsule will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the capsule will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createClosedCylinder'></a>
### (static) H3DU.Meshes.createClosedCylinder(baseRad, topRad, height, slices, stacks, [flat], [inside])

Creates a mesh of a closed cylinder. The cylinder's base will
be centered at the origin and its height will run along the
positive Z axis. The base and top will be included in the mesh if
their radius is greater than 0. Will generate texture coordinates for
the cylinder and for the base and top.
The base's and top's texture coordinates will be such that the
texture will be flat as seen from either. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

See Meshes.createCylinder for information on how texture
coordinates for the cylinder (other than the base and top) are generated and how
to find the coordinates of a particular point on the cylinder.

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. See Meshes.createCylinder.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. See Meshes.createCylinder.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number)<br>Number of lengthwise "slices" the cylinder consists of. See Meshes.createCylinder.
* `stacks` (Type: number)<br>Number of vertical stacks the cylinder consists of. May be null or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

#### Examples

The following method creates a cone that's closed at its base.
<img src="mesh1.png">

    function createClosedCone(radius,height,slices) {
    return Meshes.createClosedCylinder(radius,0,height,slices,1);
    }

<a name='extras_convex.createConvexHull'></a>
### (static) module:extras/convex.createConvexHull(points, [flat], [inside])

Generates the convex hull of a set of 3-dimensional points, that is, the smallest convex set
that contains all the points given.

#### Parameters

* `points` (Type: Array.&lt;number>)<br>An array of 3-element vectors each identifying a 3-dimensional point.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the figure will be flat shaded; otherwise, will generate normals such that the figure will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the figure will be viewed from the inside.

#### Return Value

The generated convex hull. (Type: MeshBuffer)

<a name='H3DU.Meshes.createCylinder'></a>
### (static) H3DU.Meshes.createCylinder(baseRad, topRad, height, [slices], [stacks], [flat], [inside])

Creates a mesh of a cylinder. The cylinder's base will
be centered at the origin and its height will run along the
positive Z axis. The base and top themselves will not be
included in the mesh.

Texture coordinates for the cylinder (other than the base) will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase from the origin
to the positive Z axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive X axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The X, Y, and Z coordinates of a point on the cylinder are
<code>(-R\*cos(&lambda;), -R\*sin(&lambda;), H\*&phi;)</code>,
where &phi; = <code>(&pi;/2 + L)/&pi;</code>, L is the latitude in radians,
&lambda; is the longitude in radians, H = <code>height</code>,
R = <code>baseRad + (topRad - baseRad) \* &phi;</code>,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the cylinder.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `baseRad` (Type: number)<br>Radius of the base of the cylinder. If 0, this function will create an approximation to a downward pointing cone.
* `topRad` (Type: number)<br>Radius of the top of the cylinder. If 0, this function will create an approximation to an upward pointing cone.
* `height` (Type: number)<br>Height of the cylinder.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the cylinder consists of, each slice going through the center of the cylinder. This function will create a triangular prism if "slices" is 3 and both radiuses are the same; a triangular pyramid if "slices" is 3 and either radius is zero; a rectangular prism if "slices" is 4 and both radiuses are the same; and a rectangular pyramid if "slices" is 4 and either radius is zero. Must be 3 or greater. May be null or omitted, in which case the default is 32.
* `stacks` (Type: number) (optional)<br>Number of vertical stacks the cylinder consists of. May be null or omitted, in which case the default is 1.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the cylinder will be flat shaded; otherwise, will generate normals such that the cylinder will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the cylinder will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createDisk'></a>
### (static) H3DU.Meshes.createDisk(inner, outer, [slices], [loops], [inward])

Creates a mesh of a 2D disk.
Assuming the Y axis points up, the X axis right,
and the Z axis toward the viewer, the first vertex in the outer edge
of the 2D disk will be at the 12 o'clock position.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole in the middle of the disk. If 0, no hole is created and the method will generate a regular polygon with n sides, where n is the value of "slices". For example, if "inner" is 0 and "slices" is 3, the result will be an equilateral triangle; a square for 4 "slices", a regular pentagon for 5 "slices", and so on.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the disk. May be null or omitted; default is 16.
* `loops` (Type: number) (optional)<br>Number of concentric rings the disk makes up. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive Z axis; otherwise, in the same direction of the positive Z axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='extras_createfloor.createFloor'></a>
### (static) module:extras/createfloor.createFloor(xStart, yStart, width, height, tileSize, [z])

Generates a mesh buffer of a tiled floor. Texture coordinates
of each tile will range from [0,1] across the width and height
of that tile. Thus, any texture used to render the mesh buffer should
entirely be of a square tile.

#### Parameters

* `xStart` (Type: number)<br>X coordinate of the start of the floor.
* `yStart` (Type: number)<br>Y coordinate of the start of the floor.
* `width` (Type: number)<br>Total width of the floor.
* `height` (Type: number)<br>Total height of the floor.
* `tileSize` (Type: number)<br>Width and height of each floor tile.
* `z` (Type: number) (optional)<br>Z coordinate where the floor will be placed. If null, undefined, or omitted, the default is 0.

#### Return Value

The resulting mesh buffer. (Type: MeshBuffer)

<a name='extras_gearmesh.createGear'></a>
### (static) module:extras/gearmesh.createGear(innerRadius, outerRadius, thickness, teeth, toothDepth)

Builds a mesh buffer representing a gear centered at the origin.

#### Parameters

* `innerRadius` (Type: number)<br>Inner radius of the gear wheel
* `outerRadius` (Type: number)<br>Outer radius of the gear wheel, at the valleys between teeth.
* `thickness` (Type: number)<br>Thickness of the gear
* `teeth` (Type: number)<br>Number of teeth.
* `toothDepth` (Type: number)<br>Depth of each gear tooth.

#### Return Value

Return value. (Type: MeshBuffer)

<a name='H3DU.Meshes.createLathe'></a>
### (static) H3DU.Meshes.createLathe(points, [slices], [flat], [inside])

Creates a mesh of a figure generated by revolving a path of 2-dimensional
points about the Z axis.

Texture coordinates will
be generated such that the V (vertical)
coordinates start from the bottom of the texture and increase along the Z axis in the direction
of the given path, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive X axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: Array.&lt;number>)<br>Array of alternating X and Z coordinates describing a two-dimensional path that will revolve around the Z axis to generate the figure (the first number is an X coordinate, the second is a Z coordinate, and so on). Each Z coordinate is a Z coordinate of the point where the path lies, and each X coordinate is the radius of the figure at that point. The Z coordinates should be given in increasing order and should not be the same from one point to the next. This parameter's length must be 4 or greater and be an even number.
* `slices` (Type: number) (optional)<br>Number of lengthwise "slices" the figure consists of. Must be 3 or greater. May be null or omitted; default is 32.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the figure will be flat shaded; otherwise, will generate normals such that the figure will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the figure will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='extras_arrow.createMultiColoredArrow'></a>
### (static) module:extras/arrow.createMultiColoredArrow(shaftLength, pointerLength, shaftRadius, pointerRadius, shaftColor, pointerColor)

TODO: Not documented yet.

#### Parameters

* `shaftLength` (Type: number)
* `pointerLength` (Type: number)
* `shaftRadius` (Type: number)
* `pointerRadius` (Type: number)
* `shaftColor` (Type: Array.&lt;number> | number | string)<br>A color vector or string specifying the color of the shaft.
* `pointerColor` (Type: Array.&lt;number> | number | string)<br>A color vector or string specifying the color of the pointer.

#### Return Value

A mesh buffer of the resulting shape. (Type: MeshBuffer)

<a name='H3DU.Meshes.createPartialDisk'></a>
### (static) H3DU.Meshes.createPartialDisk(inner, outer, [slices], [loops], [start], [sweep], [inward])

Creates a mesh of a 2D disk or an arc of a 2D disk.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Radius of the hole where the middle of the complete disk would be. If 0, no hole is created.
* `outer` (Type: number)<br>Outer radius of the disk.
* `slices` (Type: number) (optional)<br>Number of slices going around the partial disk. May be null or omitted; default is 32.
* `loops` (Type: number) (optional)<br>Number of concentric rings the partial disk makes up. May be null or omitted; default is 1.
* `start` (Type: number) (optional)<br>Starting angle of the partial disk, in degrees. May be null or omitted; default is 0. 0 degrees is at the positive Y axis, and 90 degrees at the positive X axis. Assuming the Y axis points up, the X axis right, and the Z axis toward the viewer, 0 degrees is at the 12 o'clock position, and 90 degrees at the 3 o'clock position.
* `sweep` (Type: number) (optional)<br>Arc length of the partial disk, in degrees. May be null or omitted; default is 360. May be negative.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive Z axis; otherwise, in the same direction of the positive Z axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createPlane'></a>
### (static) H3DU.Meshes.createPlane([width], [height], [widthDiv], [heightDiv], [inward])

Creates a mesh of a 2D rectangle, centered at the origin.
The plane's Z coordinate will be 0.
Will also generate texture coordinates that increase toward
the positive X and Y axes. The texture coordinates will range
from 0 to 1 on each end of the 2D rectangle. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `width` (Type: number) (optional)<br>Width of the rectangle. May be null or omitted; default is 1.
* `height` (Type: number) (optional)<br>Height of the rectangle. May be null or omitted; default is 1.
* `widthDiv` (Type: number) (optional)<br>Number of horizontal subdivisions. May be null or omitted; default is 1.
* `heightDiv` (Type: number) (optional)<br>Number of vertical subdivisions. May be null or omitted; default is 1.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive Z axis; otherwise, in the same direction of the positive Z axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createPointedStar'></a>
### (static) H3DU.Meshes.createPointedStar(points, firstRadius, secondRadius, [inward])

Creates a mesh in the form of a two-dimensional n-pointed star.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

#### Parameters

* `points` (Type: number)<br>Number of points in the star. Must be 2 or greater.
* `firstRadius` (Type: number)<br>First radius of the star. Must be 0 or greater; this parameter and secondRadius can't both be 0.
* `secondRadius` (Type: number)<br>Second radius of the star. Must be 0 or greater; this parameter and firstRadius can't both be 0.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point in the opposite direction of the positive Z axis; otherwise, in the same direction of the positive Z axis. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createSphere'></a>
### (static) H3DU.Meshes.createSphere([radius], [slices], [stacks], [flat], [inside])

Creates a mesh of a sphere, centered at the origin.

Will also generate texture coordinates such that the V (vertical)
coordinates start from the bottom of the texture and increase from the negative
to positive Z axis, and the U (horizontal) coordinates start from the left of the
texture and increase from the positive X to positive Y to negative X to negative
Y to positive X axis. Texture coordinates are generated assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.

The X, Y, and Z coordinates of a point on the sphere are
<code>(-R\*cos(&delta;)\*cos(&lambda;), -R\*cos(&delta;)\*sin(&lambda;), R\*sin(&delta;))</code>,
where &delta; and &lambda; are the latitude and longitude, respectively, in radians, R is the sphere's radius,
and west and south latitudes and
longitudes are negative. (The formula for converting latitude
and longitude is mentioned here because their meaning depends on
exactly how the texture coordinates are generated on the sphere.
It assumes that in the texture, longitudes range from -180&deg; to 0&deg; to 180&deg; from
left to right, and latitudes range from 90&deg; to 0&deg; to -90&deg; from top to bottom.)

See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `radius` (Type: number) (optional)<br>Radius of the sphere. May be null or omitted, in which case the default is 1.
* `slices` (Type: number) (optional)<br>Number of vertical sections the sphere consists of. This function will create an octahedron if "slices" is 4 and "stacks" is 2. Must be 3 or greater. May be null or omitted, in which case the default is 16.
* `stacks` (Type: number) (optional)<br>Number of horizontal sections the sphere consists of. May be null or omitted, in which case the default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the sphere will be flat shaded; otherwise, will generate normals such that the sphere will be smooth shaded.
* `inside` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Should normally be false unless the sphere will be viewed from the inside.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='H3DU.Meshes.createTorus'></a>
### (static) H3DU.Meshes.createTorus(inner, outer, [lengthwise], [crosswise], [flat], [inward])

Creates a mesh of a torus (donut), centered at the origin.
Will also generate texture coordinates, assuming that the coordinate (0,0)
is at the lower-left corner of the texture and (1,1) is at the upper-right
corner.
See the "<a href="tutorial-shapes.md">Creating Shapes</a>" tutorial.

#### Parameters

* `inner` (Type: number)<br>Inner radius (thickness) of the torus.
* `outer` (Type: number)<br>Outer radius of the torus (distance from the center to the innermost part of the torus).
* `lengthwise` (Type: number) (optional)<br>Number of lengthwise subdivisions. May be null or omitted; default is 16.
* `crosswise` (Type: number) (optional)<br>Number of crosswise subdivisions. May be null or omitted; default is 16.
* `flat` (Type: boolean) (optional)<br>If true, will generate normals such that the torus will be flat shaded; otherwise, will generate normals such that it will be smooth shaded.
* `inward` (Type: boolean) (optional)<br>If true, the normals generated by this method will point inward; otherwise, outward. Default is false.

#### Return Value

The generated mesh. (Type: MeshBuffer)

<a name='extras_createwasher.createWasher'></a>
### (static) module:extras/createwasher.createWasher(inner, outer, height, slices)

TODO: Not documented yet.

#### Parameters

* `inner` (Type: *)
* `outer` (Type: *)
* `height` (Type: *)
* `slices` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveCatacaustic'></a>
### (static) module:extras/derivedcurves.curveCatacaustic(evaluator, ox, oy)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)
* `ox` (Type: *)
* `oy` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveEvolute'></a>
### (static) module:extras/derivedcurves.curveEvolute(evaluator)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveInverse'></a>
### (static) module:extras/derivedcurves.curveInverse(evaluator, ox, oy, radius)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)
* `ox` (Type: *)
* `oy` (Type: *)
* `radius` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveInvolute'></a>
### (static) module:extras/derivedcurves.curveInvolute(evaluator)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveOrthotomic'></a>
### (static) module:extras/derivedcurves.curveOrthotomic(evaluator, ox, oy)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)
* `ox` (Type: *)
* `oy` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curvePedalCurve'></a>
### (static) module:extras/derivedcurves.curvePedalCurve(evaluator, ox, oy)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)
* `ox` (Type: *)
* `oy` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_derivedcurves.curveRadialCurve'></a>
### (static) module:extras/derivedcurves.curveRadialCurve(evaluator, ox, oy)

TODO: Not documented yet.

#### Parameters

* `evaluator` (Type: *)
* `ox` (Type: *)
* `oy` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.CurveBuilder.curveToBuffer'></a>
### (static) H3DU.CurveBuilder.curveToBuffer(curve, [mode], [n], [u1], [u2])

Convenience method for creating a mesh buffer from a parametric
curve. The mesh buffer will contain positions and vertex normals that
cover the given surface.

#### Parameters

* `curve` (Type: Object)<br>A curve evaluator object that describes the parametric curve used to generate positions.
* `mode` (Type: number) (optional)<br>If this value is MeshBuffer.LINES, or is null, undefined, or omitted, generates a series of lines defining the curve. If this value is MeshBuffer.POINTS, generates a series of points along the curve. For any other value, this method has no effect.
* `n` (Type: number) (optional)<br>Number of subdivisions of the curve to be drawn. If null or undefined, a default is determined automatically based on the position curve's arc length, or the distance taken by its path (or the default is 24 if no position curve was defined). If 0, this method has no effect. Throws an error if this value is less than 0.
* `u1` (Type: number) (optional)<br>Starting point of the curve. Default is the starting coordinate given by the curve evaluator object, or 0 if not given.
* `u2` (Type: number) (optional)<br>Ending point of the curve. Default is the ending coordinate given by the curve evaluator object, or 1 if not given.

#### Return Value

The generated mesh buffer. (Type: MeshBuffer)

<a name='H3DU.GraphicsPath_difference'></a>
### H3DU.GraphicsPath#difference(path, [flatness])

Computes the difference between this path's shape and another
path's shape. The points given in the GraphicsPath#union method
apply to this method.

#### Parameters

* `path` (Type: GraphicsPath)<br>A path to combine with this one.
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

The difference between this path
and the other path. (Type: GraphicsPath)

<a name='extras_camera_InputTracker_dispose'></a>
### module:extras/camera~InputTracker#dispose()

Disposes all resources used by this input tracker.

#### Return Value

Return value. (Type: Object)

<a name='extras_polyhedra_Polyhedra.dodecahedron'></a>
### (static) module:extras/polyhedra~Polyhedra.dodecahedron(radius, level)

Generates a mesh of a regular dodecahedron or a sphere based on that solid.

#### Parameters

* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The generated solid. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.dodecahedronFaces'></a>
### (static) module:extras/polyhedra~Polyhedra.dodecahedronFaces()

Gets the vertices of a dodecahedron with maximum radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_polyhedra_Polyhedra.dodecahedronFacesCompact'></a>
### (static) module:extras/polyhedra~Polyhedra.dodecahedronFacesCompact()

Gets a more compact representation of the vertices of a dodecahedron
with maximum radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.GraphicsPath_ellipse'></a>
### H3DU.GraphicsPath#ellipse(cx, cy, w, h)

Adds path segments to this path that form an axis-aligned ellipse given its center
and dimensions.

#### Parameters

* `cx` (Type: number)<br>X coordinate of the ellipse's center.
* `cy` (Type: number)<br>Y coordinate of the ellipse's center.
* `w` (Type: number)<br>Width of the ellipse's bounding box.
* `h` (Type: number)<br>Height of the ellipse's bounding box.

#### Return Value

This object. If "w" or "h" is 0, no path segments will be appended. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_ellipseForBox'></a>
### H3DU.GraphicsPath#ellipseForBox(x, y, w, h)

Adds path segments to this path that form an axis-aligned ellipse, given the ellipse's corner point
and dimensions.

#### Parameters

* `x` (Type: number)<br>X coordinate of the ellipse's bounding box's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `y` (Type: number)<br>Y coordinate of the ellipse's bounding box's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `w` (Type: number)<br>Width of the ellipse's bounding box.
* `h` (Type: number)<br>Height of the ellipse's bounding box.

#### Return Value

This object. If "w" or "h" is 0, no path segments will be appended. (Type: GraphicsPath)

<a name='extras_evaluators_Epitrochoid_endPoints'></a>
### module:extras/evaluators~Epitrochoid#endPoints()

Gets the endpoints of this curve.
For this curve evaluator object, the curve
starts at 0 and ends at &pi;\*2.

#### Return Value

An array containing the two
endpoints of the curve. The first number is the start of the curve,
and the second number is the end of the curve. \* (Type: Array.&lt;number>)

<a name='extras_drawingtoy_DrawingToy_epi'></a>
### module:extras/drawingtoy~DrawingToy#epi(ringTeeth, wheelTeeth, hole, [phase])

Adds line segments that approximate a curve drawn by rolling a wheel outside a fixed ring (an <i>epitrochoid</i>).

#### Parameters

* `ringTeeth` (Type: number)<br>Number of teeth in the fixed ring.
* `wheelTeeth` (Type: number)<br>Number of teeth in the rolling wheel.
* `hole` (Type: number)<br>Integer, starting from 1, identifying the hole within the wheel in which the drawing pen is placed. The greater the number, the closer the hole is to the center of the wheel.
* `phase` (Type: number) (optional)<br>Phase, in degrees, of the angle where the ring's and wheel's teeth are engaged. If null, undefined, or omitted, the default value is 0. TODO: Document this parameter more exactly.

#### Return Value

This object. (Type: DrawingToy)

<a name='H3DU.CurveBuilder_evalCurve'></a>
### H3DU.CurveBuilder#evalCurve([mode], [n], [u1], [u2])

Generates the vertex attributes of the parametric curves.

#### Parameters

* `mode` (Type: number) (optional)<br>If this value is MeshBuffer.LINES, or is null, undefined, or omitted, generates a series of lines defining the curve. If this value is MeshBuffer.POINTS, generates a series of points along the curve. For any other value, this method has no effect.
* `n` (Type: number) (optional)<br>Number of subdivisions of the curve to be drawn. If null or undefined, a default is determined automatically based on the position curve's arc length, or the distance taken by its path (or the default is 24 if no position curve was defined). If 0, this method has no effect. Throws an error if this value is less than 0.
* `u1` (Type: number) (optional)<br>Starting point of the curve. Default is the starting coordinate given by the curve evaluator object, or 0 if not given.
* `u2` (Type: number) (optional)<br>Ending point of the curve. Default is the ending coordinate given by the curve evaluator object, or 1 if not given.

#### Return Value

This object. (Type: CurveBuilder)

<a name='H3DU.SurfaceBuilder_evalSurface'></a>
### H3DU.SurfaceBuilder#evalSurface([mode], [un], [vn], [u1], [u2], [v1], [v2])

Generates the vertex attributes of the parametric surfaces.

#### Parameters

* `mode` (Type: number) (optional)<br>If this value is MeshBuffer.TRIANGLES, or is null, undefined, or omitted, generates a series of triangles defining the surface. If this value is MeshBuffer.LINES, generates a series of lines defining the surface. If this value is MeshBuffer.POINTS, generates a series of points along the surface. For any other value, this method has no effect.
* `un` (Type: number) (optional)<br>Number of subdivisions along the U axis. Default is 24. If 0, this method has no effect. Throws an error if this value is less than 0.
* `vn` (Type: number) (optional)<br>Number of subdivisions along the V axis. Default is 24. If 0, this method has no effect. Throws an error if this value is less than 0.
* `u1` (Type: number) (optional)<br>Starting U coordinate of the surface to evaluate. Default is the starting U coordinate given by the surface evaluator object, or 0 if not given.
* `u2` (Type: number) (optional)<br>Ending U coordinate of the surface to evaluate. Default is the ending U coordinate given by the surface evaluator object, or 1 if not given.
* `v1` (Type: number) (optional)<br>Starting V coordinate of the surface to evaluate. Default is the starting V coordinate given by the surface evaluator object, or 0 if not given.
* `v2` (Type: number) (optional)<br>Ending V coordinate of the surface to evaluate. Default is the ending V coordinate given by the surface evaluator object, or 1 if not given.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='extras_evaluators_Epitrochoid_evaluate'></a>
### module:extras/evaluators~Epitrochoid#evaluate(u)

Generates a point on the curve from the given U coordinate.

#### Parameters

* `u` (Type: number)<br>U coordinate.

#### Return Value

A 3-element array specifying a 3D point.
Only the X and Y coordinates will be other than 0. (Type: Array.&lt;number>)

<a name='H3DU.Curve_fitRange'></a>
### H3DU.Curve#fitRange(ep1, ep2)

Creates a curve evaluator object for a curve that follows the same
path as this one but has its U coordinates remapped to fit the given range.
For example, this method can be used to shrink the range of U coordinates
from [-&pi;, &pi;] to [0, 1] without shortening the path of the curve.
Here, -&pi; now maps to 0, and &pi; now maps to 1.

#### Parameters

* `ep1` (Type: number)<br>New value to use as the start point of the curve.
* `ep2` (Type: number)<br>New value to use as the end point of the curve.

#### Return Value

Return value. (Type: Curve)

<a name='extras_fragmentshaderlib.fragmentShaderLib'></a>
### (static) module:extras/fragmentshaderlib.fragmentShaderLib()

TODO: Not documented yet.

#### Return Value

Return value. (Type: *)

<a name='H3DU.BSplineCurve.fromBezierCurve'></a>
### (static) H3DU.BSplineCurve.fromBezierCurve(controlPoints, [bits])

Creates a B-spline curve from the control points of a B&eacute;zier curve.

#### Parameters

* `controlPoints` (Type: Array.&lt;Array.&lt;number>>)<br>An array of control points. Each control point is an array with the same length as the other control points. It is assumed that:<ul> <li>The length of this parameter minus 1 represents the degree of the B&eacute;zier curve. For example, a degree-3 (cubic) curve contains 4 control points. A degree of 1 (two control points) results in a straight line segment. <li>The first control point's length represents the size of all the control points. </ul>
* `bits` (Type: number) (optional)<br>Bits as specified in the BSplineCurve constructor.

#### Return Value

Return value. (Type: BSplineCurve)

#### Examples

The following function generates a polygon curve using linear B&eacute;zier
curves.

    function polygonCurve(points) {
    var curves=[]
    for(var i=0;i < points.length;i++) {
    var cp=points[i]
    var np=(i==points.length-1) ? points[0] : points[i+1]
    curves.push(BSplineCurve.fromBezierCurve([cp,np]))
    }
    return new PiecewiseCurve(curves)
    }

<a name='H3DU.BSplineSurface.fromBezierSurface'></a>
### (static) H3DU.BSplineSurface.fromBezierSurface(controlPoints, [bits])

Creates a B-spline surface from the control points of a B&eacute;zier surface.

#### Parameters

* `controlPoints` (Type: Array.&lt;Array.&lt;Array.&lt;number>>>)<br>An array of control point arrays, which in turn contain a number of control points. Each control point is an array with the same length as the other control points. It is assumed that:<ul> <li>The length of this parameter minus 1 represents the degree of the B&eacute;zier surface along the V axis. For example, a degree-3 (cubic) surface along the V axis contains 4 control points, one in each control point array. A degree of 1 on both the U and V axes results in a flat surface. <li>The length of the first control point array minus 1 represents the degree of the B&eacute;zier surface along the U axis. <li>The number of elements in the first control point represents the number of elements in all the control points. </ul>
* `bits` (Type: number) (optional)<br>Bits as specified in the BSplineSurface constructor.

#### Return Value

Return value. (Type: BSplineSurface)

<a name='H3DU.PiecewiseCurve.fromCatmullRomSpline'></a>
### (static) H3DU.PiecewiseCurve.fromCatmullRomSpline(spline, [param], [closed])

Creates a piecewise curve made up of B-spline curves from the control points of a
cubic Catmull&ndash;Rom spline. A Catmull&ndash;Rom spline is defined by
a collection of control points that the spline
will go through, and the shape of each curve segment is also determined by the positions
of neighboring points on the spline.

#### Parameters

* `spline` (Type: Array.&lt;Array.&lt;number>>)<br>An array of control points, each with the same number of values, that the curve will pass through. Throws an error if there are fewer than two control points.
* `param` (Type: number) (optional)<br>A value that describes the curve's parameterization. Ranges from 0 to 1. A value of 0 indicates a uniform parameterization, 0.5 indicates a centripetal parameterization, and 1 indicates a chordal parameterization. Default is 0.5.
* `closed` (Type: number) (optional)<br>If true, connects the last control point of the curve with the first. Default is false.

#### Return Value

A piecewise curve made up of cubic B-spline curves describing the same path as the Catmull&ndash;Rom spline. (Type: PiecewiseCurve)

<a name='H3DU.PiecewiseCurve.fromEllipseArc'></a>
### (static) H3DU.PiecewiseCurve.fromEllipseArc(x, y, radiusX, radiusY, start, sweep)

TODO: Not documented yet.

#### Parameters

* `x` (Type: number)
* `y` (Type: number)
* `radiusX` (Type: number)
* `radiusY` (Type: number)
* `start` (Type: number)
* `sweep` (Type: number)

#### Return Value

Return value. (Type: PiecewiseCurve)

<a name='extras_evaluators_SurfaceOfRevolution.fromFunction'></a>
### (static) module:extras/evaluators~SurfaceOfRevolution.fromFunction(func, minval, maxval, [axis])

Creates a surface evaluator object for a surface of revolution
whose curve is the graph of a single-variable function.
The resulting surface will have a circular cross section
along its length.
Examples of surfaces generated by this technique are
cones, frustums, cylinders, spheres, and spheroids (the
bases of these surfaces won't be generated).

#### Parameters

* `func` (Type: function)<br>Function whose graph will be rotated about the axis of rotation, as specified in the "axis" parameter. The function takes a number as a single parameter and returns a number. The return value is effectively the radius of each part of the surface from beginning to end.
* `minval` (Type: number)<br>Smallest parameter of the function. This is a number of units from the origin along the axis of rotation.
* `maxval` (Type: number)<br>Largest parameter of the function. This is a number of units from the origin along the axis of rotation. If _minval_ is greater than _maxval_, both values will be swapped.
* `axis` (Type: Array.&lt;number>) (optional)<br>Axis of rotation, around which the function graph will be rotated to generate the surface of revolution. If null, undefined, or omitted, the positive Z axis (0, 0, 1) will be the axis of rotation. This parameter is a 3-element array describing the X, Y, and Z coordinates, respectively, of a 3D point. The axis of rotation will run in the direction from the origin to the point given in this parameter. This parameter need not be a <a href="tutorial-glmath.md">unit vector</a>.

#### Return Value

Return value. (Type: SurfaceOfRevolution)

#### Examples

The following creates an evaluator for a cone
which starts at the origin and runs 10 units along the Z axis.

    var surf=SurfaceOfRevolution.fromFunction(
    function(x) {
    "use strict"; return x/2; }, // use a constantly increasing function
    0, 10);

This is an evaluator for the same cone, but
shifted 3 units back.

    var surf=SurfaceOfRevolution.fromFunction(
    function(x) {
    "use strict"; x+=3; return x/2; },
    -3,7);

The following creates an evaluator for a cylinder
which runs from 5 to 10 units, and with a radius of 2 units.

    var surf=SurfaceOfRevolution.fromFunction(
    function(x) {
    "use strict"; return 2; }, // use a constant radius
    5, 10);

<a name='H3DU.PiecewiseCurve.fromHermiteSpline'></a>
### (static) H3DU.PiecewiseCurve.fromHermiteSpline(spline)

Creates a piecewise curve made up of B-spline curves from the control points of a
Hermite spline. A Hermite spline is a collection of points that the curve will go through,
together with the velocity vectors (derivatives or instantaneous rates of change) at
those points.

Hermite splines are useful for representing an approximate polynomial form
of a function or curve whose derivative is known; however, Hermite splines are not
guaranteed to preserve the increasing or decreasing nature of the function or curve.

#### Parameters

* `spline` (Type: Array.&lt;Array.&lt;number>>)<br>An array of control points, each with the same number of values, that describe a Hermite spline. Each pair of control points takes up two elements of the array and consists of the coordinates of that point followed by the velocity vector (derivative) at that point. The array must have an even number of control points and at least four control points.

#### Return Value

A piecewise curve made up of cubic B-spline curves describing the
same path as the Hermite spline. (Type: PiecewiseCurve)

<a name='H3DU.MeshBuffer.fromPositions'></a>
### (static) H3DU.MeshBuffer.fromPositions(vertices, [indices])

Creates a new mesh buffer with the given array of vertex positions.

#### Parameters

* `vertices` (Type: Array.&lt;number> | Float32Array)<br>An array of vertex positions. This array's length must be divisible by 3; every 3 elements are the X, Y, and Z coordinates, in that order, of one vertex.
* `indices` (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.

#### Return Value

A new mesh buffer. (Type: MeshBuffer)

<a name='H3DU.MeshBuffer.fromPositionsNormals'></a>
### (static) H3DU.MeshBuffer.fromPositionsNormals(vertices, [indices])

Creates a new mesh buffer with the given array of vertex positions
and vertex normals.

#### Parameters

* `vertices` (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 6; every 6 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>X, Y, and Z components, in that order, of the vertex normal.</ol>
* `indices` (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.

#### Return Value

A new mesh buffer. (Type: MeshBuffer)

<a name='H3DU.MeshBuffer.fromPositionsNormalsUV'></a>
### (static) H3DU.MeshBuffer.fromPositionsNormalsUV(vertices, [indices])

Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.

#### Parameters

* `vertices` (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 8; every 8 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>X, Y, and Z components, in that order, of the vertex normal. <li>U and V texture coordinates, in that order, of the vertex.</ol>
* `indices` (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.

#### Return Value

A new mesh buffer. (Type: MeshBuffer)

<a name='H3DU.MeshBuffer.fromPositionsUV'></a>
### (static) H3DU.MeshBuffer.fromPositionsUV(vertices, [indices])

Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.

#### Parameters

* `vertices` (Type: Array.&lt;number> | Float32Array)<br>An array of vertex data. This array's length must be divisible by 5; every 5 elements describe one vertex and are in the following order:<ol> <li>X, Y, and Z coordinates, in that order, of the vertex position. <li>U and V texture coordinates, in that order, of the vertex.</ol>
* `indices` (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null | undefined) (optional)<br>Array of vertex indices that the mesh buffer will use. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.

#### Return Value

A new mesh buffer. (Type: MeshBuffer)

<a name='extras_stl.fromStlString'></a>
### (static) module:extras/stl.fromStlString(str)

TODO: Not documented yet.

#### Parameters

* `str` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.GraphicsPath.fromString'></a>
### (static) H3DU.GraphicsPath.fromString(str)

Creates a graphics path from a string whose format follows
the SVG (Scalable Vector Graphics) specification.

#### Parameters

* `str` (Type: string)<br>A string, in the SVG path format, representing a two-dimensional path. An SVG path consists of a number of path segments, starting with a single letter, as follows: <ul> <li>M/m (x y) - Moves the current position to (x, y). Further XY pairs specify line segments. <li>L/l (x y) - Specifies line segments to the given XY points. <li>H/h (x) - Specifies horizontal line segments to the given X points. <li>V/v (y) - Specifies vertical line segments to the given Y points. <li>Q/q (cx cx x y) - Specifies quadratic B&eacute;zier curves (see quadraticCurveTo). <li>T/t (x y) - Specifies quadratic curves tangent to the previous quadratic curve. <li>C/c (c1x c1y c2x c2y x y) - Specifies cubic B&eacute;zier curves (see bezierCurveTo). <li>S/s (c2x c2y x y) - Specifies cubic curves tangent to the previous cubic curve. <li>A/a (rx ry rot largeArc sweep x y) - Specifies arcs (see arcSvgTo). "largeArc" and "sweep" are flags, "0" for false and "1" for true. "rot" is in degrees. <li>Z/z - Closes the current path; similar to adding a line segment to the first XY point given in the last M/m command. </ul> Lower-case letters mean any X and Y coordinates are relative to the current position of the path. Each group of parameters can be repeated in the same path segment. Each parameter after the starting letter is separated by whitespace and/or a single comma, and the starting letter can be separated by whitespace. This separation can be left out as long as doing so doesn't introduce ambiguity. All commands set the current point to the end of the path segment (including Z/z, which adds a line segment if needed). Examples of this parameter are "M50,50L100,100,100,150,150,200", "M50,20C230,245,233,44,22,44", and "M50,50H80V60H50V70H50"

#### Return Value

The resulting path. If an error
occurs while parsing the path, the path's "isIncomplete()" method
will return <code>true</code>. (Type: GraphicsPath)

#### Examples

The following example creates a graphics path
from an SVG string describing a polyline.

    var path=GraphicsPath.fromString("M10,20L40,30,24,32,55,22")

The following example creates a graphics path
from an SVG string describing a curved path.

    var path=GraphicsPath.fromString("M50,20C230,245,233,44,22,44")

<a name='H3DU.PiecewiseCurve.fromTCBSpline'></a>
### (static) H3DU.PiecewiseCurve.fromTCBSpline(spline, [tension], [continuity], [bias], [closed], [rigidEnds])

Creates a piecewise curve made up of B-spline curves from the control points of a
cubic TCB spline (tension/continuity/bias spline, also known as Kochanek&ndash;Bartels spline).
(If tension, continuity, and bias are all 0, the result is a cubic Catmull&ndash;Rom spline
in uniform parameterization.)

#### Parameters

* `spline` (Type: Array.&lt;Array.&lt;number>>)<br>An array of control points, each with the same number of values, that the curve will pass through. Throws an error if there are fewer than two control points.
* `tension` (Type: number) (optional)<br>A parameter that adjusts the length of the starting and ending tangents of each curve segment. Ranges from -1 for double-length tangents to 1 for zero-length tangents. A value of 1 results in straight line segments. Default is 0.
* `continuity` (Type: number) (optional)<br>A parameter that adjusts the direction of the starting and ending tangents of each curve segment. Ranges from -1 to 1, where values closer to -1 or closer to 1 result in tangents that are closer to perpendicular. A value of -1 results in straight line segments. Default is 0.
* `bias` (Type: number) (optional)<br>A parameter that adjusts the influence of the starting and ending tangents of each curve segment. The greater this number, the greater the ending tangents influence the direction of the next curve segment in comparison to the starting tangents. Ranges from -1 to 1. Default is 0.
* `closed` (Type: number) (optional)<br>If true, connects the last control point of the curve with the first. Default is false.
* `rigidEnds` (Type: number) (optional)<br>If true, the start and end of the piecewise curve will, by default, more rigidly follow the direction to the next or previous control point, respectively. This makes the curve compatible with GDI+ cardinal splines with 0 continuity, 0 bias, and tension equal to <code>-((T\*2)-1)</code>, where T is the GDI+ cardinal spline tension parameter. Default is false.

#### Return Value

A piecewise curve made up of cubic B-spline curves describing the
same path as the TCB spline. (Type: PiecewiseCurve)

<a name='extras_matrixstack_MatrixStack_frustum'></a>
### module:extras/matrixstack~MatrixStack#frustum(l, r, b, t, n, f)

Modifies the matrix at the top of this stack by multiplying it by
a frustum matrix.
This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.

#### Parameters

* `l` (Type: number)<br>X coordinate of the point where the left clipping plane meets the near clipping plane.
* `r` (Type: number)<br>X coordinate of the point where the right clipping plane meets the near clipping plane.
* `b` (Type: number)<br>Y coordinate of the point where the bottom clipping plane meets the near clipping plane.
* `t` (Type: number)<br>Y coordinate of the point where the top clipping plane meets the near clipping plane.
* `n` (Type: number)<br>The distance from the camera to the near clipping plane. Objects closer than this distance won't be seen. This should be slightly greater than 0.
* `f` (Type: number)<br>The distance from the camera to the far clipping plane. Objects beyond this distance will be too far to be seen.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.MathUtil.frustumHasBox'></a>
### (static) H3DU.MathUtil.frustumHasBox(frustum, box)

Determines whether an axis-aligned bounding box
is at least partially inside a view frustum.

#### Parameters

* `frustum` (Type: Array.&lt;Array.&lt;number>>)<br>An array of six 4-element arrays representing the six clipping planes of the view frustum. In order, they are the left, right, top, bottom, near, and far clipping planes.
* `box` (Type: Array.&lt;number>)<br>An axis-aligned bounding box in world space, which is an array of six values. The first three values are the smallest X, Y, and Z coordinates, and the last three values are the largest X, Y, and Z coordinates.

#### Return Value

<code>true</code> if the box
may be partially or totally
inside the frustum; <code>false</code> if the box is
definitely outside the frustum, or if the box is empty
(see "boxIsEmpty"). (Type: boolean)

<a name='H3DU.MathUtil.frustumHasPoint'></a>
### (static) H3DU.MathUtil.frustumHasPoint(frustum, x, y, z)

Determines whether a point is
outside or inside a view frustum.

#### Parameters

* `frustum` (Type: Array.&lt;Array.&lt;number>>)<br>An array of six 4-element arrays representing the six clipping planes of the view frustum. In order, they are the left, right, top, bottom, near, and far clipping planes.
* `x` (Type: number)<br>X coordinate of a point in world space.
* `y` (Type: number)<br>Y coordinate of a point in world space.
* `z` (Type: number)<br>Z coordinate of a point in world space.

#### Return Value

true if the point is inside;
otherwise false; (Type: boolean)

<a name='H3DU.MathUtil.frustumHasSphere'></a>
### (static) H3DU.MathUtil.frustumHasSphere(frustum, x, y, z, radius)

Determines whether a sphere is at least
partially inside a view frustum.

#### Parameters

* `frustum` (Type: Array.&lt;Array.&lt;number>>)<br>An array of six 4-element arrays representing the six clipping planes of the view frustum. In order, they are the left, right, top, bottom, near, and far clipping planes.
* `x` (Type: number)<br>X coordinate of the sphere's center in world space.
* `y` (Type: number)<br>Y coordinate of the sphere's center in world space.
* `z` (Type: number)<br>Z coordinate of the sphere's center in world space.
* `radius` (Type: number)<br>Radius of the sphere in world-space units.

#### Return Value

<code>true</code> if the sphere
is partially or totally
inside the frustum; <code>false</code> otherwise. (Type: boolean)

<a name='extras_matrixstack_MatrixStack_get'></a>
### module:extras/matrixstack~MatrixStack#get()

Gets a copy of the matrix at the top of this stack.

#### Return Value

. (Type: Array.&lt;number>)

<a name='H3DU.MeshBuffer_getAttribute'></a>
### H3DU.MeshBuffer#getAttribute(name, [semanticIndex])

Gets a vertex attribute included in this mesh buffer.

#### Parameters

* `name` (Type: number | string)<br>An attribute semantic, such as <a href="Semantic.md#Semantic.POSITION">Semantic.POSITION</a>, "POSITION", or "TEXCOORD_0". Throws an error if this value is a string and the string is invalid.
* `semanticIndex` (Type: number) (optional)<br>The set index of the attribute for the given semantic. 0 is the first index of the attribute, 1 is the second, and so on. This is ignored if "name" is a string. Otherwise, if null or omitted, the default value is 0.

#### Return Value

A vertex buffer accessor, or null
if the attribute doesn't exist. (Type: BufferAccessor)

#### Examples

The following function gets the positions,
normals, texture coordinates, and colors of each primitive
(line, text, or point) in the mesh buffer. A point will have one
vertex per primitive, a line two vertices and a triangle three.
The attributes, if present, will be stored in the "position",
"normal", "uv", and "color" properties of each vertex.

    function getPrimitives(mesh) {
    var p=mesh.getAttribute("POSITION")
    var n=mesh.getAttribute("NORMAL")
    var t=mesh.getAttribute("TEXCOORD_0")
    var c=mesh.getAttribute("COLOR")
    var ind=mesh.getIndices()
    var primSize = 3;
    if(mesh.primitiveType() === MeshBuffer.LINES)
    primSize = 2;
    if(mesh.primitiveType() === MeshBuffer.POINTS)
    primSize = 1;
    var ret=[]
    for(var i=0;i<ind.length;i+=primSize) {
    var prim=[]
    var index=ind[i]
    for(var j=0;j<primSize;j++) {
    var info={}
    if(p)info.position=p.getVec(index,[])
    if(n)info.normal=n.getVec(index,[])
    if(t)info.uv=t.getVec(index,[])
    if(c)info.color=c.getVec(index,[])
    }
    ret.push(prim)
    }
    return ret
    }

<a name='H3DU.ShapeGroup_getBounds'></a>
### H3DU.ShapeGroup#getBounds()

Finds a bounding box that holds all vertices in this shape group.
The bounding box is not guaranteed to be the
tightest, and the box will be in world space coordinates.

#### Return Value

An array of six numbers describing an
axis-aligned bounding box
that fits all vertices in the shape group. The first three numbers
are the smallest-valued X, Y, and Z coordinates, and the
last three are the largest-valued X, Y, and Z coordinates.
If the shape group has no vertices, returns the array [Inf, Inf, Inf, -Inf,
-Inf, -Inf]. (Type: Array.&lt;number>)

<a name='extras_colormatrixshader.getColorMatrix'></a>
### (static) module:extras/colormatrixshader.getColorMatrix(kind)

Gets a specific kind of color matrix for the color
matrix shader.

#### Parameters

* `kind` (Type: string)<br>One of the following:<ul> <li>"grayscale" - Filter that averages the red, green, and blue components to result in black, white, or a shade of gray. <li>"boosted-red" - Filter that boosts the red component of the input. <li>"boosted-blue" - Filter that boosts the blue component of the input. <li>"sepia" or "sepia2" - One of two filters that adjust the colors of the image to achieve a sepia coloring. <li>"invert" - Filter that inverts the colors of the input so the effect looks like a film negative. </ul>

#### Return Value

4x4 color matrix. (Type: Array.&lt;number>)

<a name='H3DU.BSplineSurface_getControlPoints'></a>
### H3DU.BSplineSurface#getControlPoints()

Gets a reference to the array of control point arrays used
in this surface object.

#### Return Value

An object described in the constructor to BSplineCurve. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.GraphicsPath_getCurrentPoint'></a>
### H3DU.GraphicsPath#getCurrentPoint()

Gets the current point stored in this path.

#### Return Value

A two-element array giving the X and Y coordinates of the current point. (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_getCurves'></a>
### H3DU.GraphicsPath#getCurves()

Gets a curve evaluator object for
the curves described by this path. The return value doesn't track changes to the path.

#### Return Value

A curve evaluator object that implements
the following additional method:<ul>
<li><code>getCurves()</code> - Returns a list of curve evaluator objects
described by this path. The list will contain one curve evaluator object for each disconnected
portion of the path. For example, if the path contains one polygon, the list will contain
one curve object. And if the path is empty, the list will be empty too. Each curve
takes U coordinates that range from 0 to 1, depending on how far the point is from the start or
the end of the path (similar to arc-length parameterization). Each curve
returns a 3-element array containing
the X, Y, and Z coordinates of the point lying on the curve at the given
"u" position (however, the z will always be 0 since paths can currently
only be 2-dimensional).
</ul> (Type: Object)

<a name='extras_camera_Camera_getDistance'></a>
### module:extras/camera~Camera#getDistance()

Finds the distance from the camera's position to the reference point.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MeshBuffer_getIndices'></a>
### H3DU.MeshBuffer#getIndices()

Gets the array of vertex indices used by this mesh buffer.

#### Return Value

Return value. (Type: Uint16Array | Uint32Array | Uint8Array)

<a name='extras_kernelmatrixshader.getKernelMatrix'></a>
### (static) module:extras/kernelmatrixshader.getKernelMatrix(kind)

TODO: Not documented yet.

#### Parameters

* `kind` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_camera_InputTracker_getKey'></a>
### module:extras/camera~InputTracker#getKey()

Gets whether a key is pressed, as detected by this
input tracker.

#### Return Value

key Key code of the key to check. (Type: number)

<a name='H3DU.BSplineSurface_getKnots'></a>
### H3DU.BSplineSurface#getKnots()

Gets a reference to the array of knot vectors used
in this curve object.

#### Return Value

An object described in the constructor to BSplineSurface. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.Curve_getLength'></a>
### H3DU.Curve#getLength()

Convenience method for getting the total length of this curve.

#### Return Value

The distance from the start of the curve to its end. (Type: number)

<a name='H3DU.GraphicsPath_getLinePoints'></a>
### H3DU.GraphicsPath#getLinePoints([flatness])

Gets an array of the end points of
line segments approximating the path.

#### Parameters

* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

Array of the end points of
line segments approximating the path. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.GraphicsPath_getLinePointsAsObjects'></a>
### H3DU.GraphicsPath#getLinePointsAsObjects([flatness])

Gets an array of the end points of
line segments approximating the path. The positions will be in the form of objects with
two properties: x and y retrieve the X or Y coordinate of each position, respectively.

#### Parameters

* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

Array of the end points of
line segments approximating the path. (Type: Array.&lt;Array.&lt;number>>)

#### Examples

The following example initializes a three.js BufferGeometry with the points retrieved by this method. This example requires the three.js library.

    var points=path.getLinePointsAsObjects()
    var buffer=new THREE.BufferGeometry()
    .setFromPoints(points);

<a name='H3DU.GraphicsPath_getLines'></a>
### H3DU.GraphicsPath#getLines([flatness])

Gets an array of line segments approximating
the path.

#### Parameters

* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

Array of line segments.
Each line segment is an array of four numbers: the X and
Y coordinates of the start point, respectively, then the X and
Y coordinates of the end point, respectively. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.ShapeGroup_getMatrix'></a>
### H3DU.ShapeGroup#getMatrix()

Gets a copy of the transformation needed to transform
this shape group's coordinates to world coordinates.

#### Return Value

A 4x4 matrix. (Type: Transform)

<a name='H3DU.Shape_getMeshBuffer'></a>
### H3DU.Shape#getMeshBuffer()

Returns a reference to the mesh buffer used by this shape.

#### Return Value

Return value. (Type: MeshBuffer)

<a name='H3DU.GraphicsPath_getPoints'></a>
### H3DU.GraphicsPath#getPoints(numPoints)

Gets an array of points evenly spaced across the length
of the path.

#### Parameters

* `numPoints` (Type: number)<br>Number of points to return.

#### Return Value

Array of points lying on
the path and evenly spaced across the length of the path,
starting and ending with the path's endPoints. Returns
an empty array if <i>numPoints</i> is less than 1. Returns
an array consisting of the start point if <i>numPoints</i>
is 1. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.GraphicsPath_getPointsAsObjects'></a>
### H3DU.GraphicsPath#getPointsAsObjects(numPoints)

Gets an array of points evenly spaced across the length
of the path. The positions will be in the form of objects with
two properties: x and y retrieve the X or Y coordinate of each position, respectively.

#### Parameters

* `numPoints` (Type: number)<br>Number of points to return.

#### Return Value

Array of points lying on
the path and evenly spaced across the length of the path,
starting and ending with the path's endPoints. Returns
an empty array if <i>numPoints</i> is less than 1. Returns
an array consisting of the start point if <i>numPoints</i>
is 1. (Type: Array.&lt;Array.&lt;number>>)

#### Examples

The following example initializes a three.js BufferGeometry with the points retrieved by this method. This example requires the three.js library.

    var points=path.getPointsAsObjects(50)
    var buffer=new THREE.BufferGeometry()
    .setFromPoints(points);

<a name='extras_camera_Camera_getPosition'></a>
### module:extras/camera~Camera#getPosition()

Gets the position of the camera.

#### Return Value

An array of three numbers giving
the X, Y, and Z coordinates of the camera's position, respectively. (Type: Array.&lt;number>)

<a name='H3DU.MeshBuffer_getPositions'></a>
### H3DU.MeshBuffer#getPositions()

Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.
Only values with the attribute semantic <code>POSITION_0</code> are returned.

#### Return Value

An array of primitives,
each of which holds the vertices that make up that primitive.
If this mesh holds triangles, each primitive will contain three
vertices; if lines, two; and if points, one. Each vertex is an at least 3-element
array containing that vertex's X, Y, and Z coordinates, in that order. (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.getPromiseResults'></a>
### (static) H3DU.getPromiseResults(promises, [progressResolve], [progressReject])

Utility function that returns a promise that
resolves after the given list of promises finishes
its work.

#### Parameters

* `promises` (Type: Array.&lt;<a href="Promise.md">Promise</a>>)<br>an array containing promise objects
* `progressResolve` (Type: function) (optional)<br>A function called as each individual promise is resolved.
* `progressReject` (Type: function) (optional)<br>A function called as each individual promise is rejected.

#### Return Value

A promise that is never rejected and resolves when
all of the promises are each resolved or rejected. The result
of the promise will be an object with
three keys:<ul>
 <li>"successes" - contains a list of results from the
promises that succeeded, in the order in which those promises were listed.
 <li>"failures" - contains a list of results from the
promises that failed, in the order in which those promises were listed.
 <li>"results" - contains a list of boolean values for each
promise, in the order in which the promises were listed.
True means success, and false means failure.</ul> (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.getPromiseResultsAll'></a>
### (static) H3DU.getPromiseResultsAll(promises, [progressResolve], [progressReject])

Utility function that returns a promise that
resolves or is rejected after the given list of promises finishes
its work.

#### Parameters

* `promises` (Type: Array.&lt;<a href="Promise.md">Promise</a>>)<br>an array containing promise objects
* `progressResolve` (Type: function) (optional)<br>a function called as each individual promise is resolved; optional
* `progressReject` (Type: function) (optional)<br>a function called as each individual promise is rejected; optional

#### Return Value

A promise that is resolved when
all of the promises are each resolved; the result will
be an array of results from those promises,
in the order in which those promises were listed.
Will be rejected if any of the promises is rejected; the result
will be an object as specified in getPromiseResults.</ul> (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.Transform_getQuaternion'></a>
### H3DU.Transform#getQuaternion()

Returns a copy of the rotation of an object in the form of a <a href="tutorial-glmath.md">quaternion</a>.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.Transform_getScale'></a>
### H3DU.Transform#getScale()

Returns a copy of a three-element array giving the scaling for an object's width,
height, and depth, respectively.
For each component, 1 means no scaling.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.ShapeGroup_getShape'></a>
### H3DU.ShapeGroup#getShape(index)

Gets the shape or shape group located
in this shape group at the given index.

#### Parameters

* `index` (Type: number)<br>Integer index, starting from 0, of the shape or shape group to set.

#### Return Value

The shape or shape group located
in this shape group at the given index, or null if none is found there. (Type: Shape | ShapeGroup)

<a name='H3DU.GraphicsPath_getSubpaths'></a>
### H3DU.GraphicsPath#getSubpaths()

TODO: Not documented yet.

#### Return Value

Return value. (Type: *)

<a name='H3DU.getTimePosition'></a>
### (static) H3DU.getTimePosition(timer, timeInMs, intervalInMs)

Gets the position of a time value within an interval.
This is useful for doing animation cycles lasting a certain number
of seconds, such as rotating a shape in a 5-second cycle.
This method may be called any number of times each frame.

#### Parameters

* `timer` (Type: Object)<br>An object that will hold two properties:<ul> <li>"time" - initial time value, in milliseconds. <li>"lastTime" - last known time value, in milliseconds. Will be set to the value given in "timeInMs" before returning. </ul> The object should be initialized using the idiom <code>{}</code> or <code>new Object()</code>.
* `timeInMs` (Type: number)<br>A time value, in milliseconds. This could be the parameter received in a <code>requestAnimationFrame()</code> callback method.
* `intervalInMs` (Type: number)<br>The length of the interval (animation cycle), in milliseconds.

#### Return Value

A value in the range [0, 1), where closer
to 0 means "timeInMs" lies
closer to the start, and closer to 1 means closer
to the end of the interval. If an initial time wasn't set, returns 0. (Type: number)

#### Examples

The following code sets an angle of
rotation, in degrees, such that an object rotated with the
angle does a 360-degree turn in 5 seconds (5000 milliseconds).
The variable <code>time</code> is assumed to be a time
value in milliseconds, such as the parameter of a
<code>requestAnimationFrame()</code> callback method.

    var angle = 360 * getTimePosition(timer, time, 5000);

<a name='H3DU.ShapeGroup_getTransform'></a>
### H3DU.ShapeGroup#getTransform()

Gets a reference to the transform used by this shape group object.

#### Return Value

Return value. (Type: Transform)

<a name='H3DU.GraphicsPath_getTriangles'></a>
### H3DU.GraphicsPath#getTriangles([flatness])

Converts the subpaths in this path to triangles.
Treats each subpath as a polygon even if it isn't closed.
Each subpath should not contain self-intersections or
duplicate vertices, except duplicate vertices that appear
consecutively or at the start and end.

The path can contain holes. In this case, subpaths
whose winding order (counterclockwise or clockwise)
differs from the first subpath's winding order can be holes.

#### Parameters

* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

Array of six-element
arrays each describing a single triangle. For each six-element
array, the first two, next two, and last two numbers each
describe a vertex position of that triangle (X and Y coordinates
in that order). (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.BufferAccessor_getVec'></a>
### H3DU.BufferAccessor#getVec(index, vec)

Gets the elements of a vertex attribute value.

Note that currently, this method does no bounds checking beyond the
checking naturally done when accessing the attribute's buffer.

#### Parameters

* `index` (Type: number)<br>A numeric index, starting from 0, that identifies a value stored in the attribute's buffer. For example, 0 identifies the first value, 1 identifies the second, and so on.
* `vec` (Type: Array.&lt;number>)<br>An array whose elements will be set to those of the value at the given index. The number of elements copied to this array is the attribute's count per value (see BufferAccessor#countPerValue).

#### Return Value

The parameter "vec". (Type: Array.&lt;number>)

<a name='extras_camera_Camera_getVectorFromCenter'></a>
### module:extras/camera~Camera#getVectorFromCenter()

Gets the 3-element vector that points from the reference
point to the camera's position.

#### Return Value

The return value as a unit
vector (a "normalized" vector with a length of 1).
Returns (0,0,0) if the reference point is the same as the camera's position. (Type: Array.&lt;number>)

<a name='H3DU.ShapeGroup_getVisible'></a>
### H3DU.ShapeGroup#getVisible()

Gets whether this shape group will be drawn on rendering.

#### Return Value

value True if this shape group will be visible; otherwise, false. (Type: boolean)

<a name='H3DU.Surface_gradient'></a>
### H3DU.Surface#gradient(u, v)

Finds an approximate gradient vector of this surface at the given U and V coordinates.

The implementation in Surface calls the evaluator's <code>gradient</code>
method if it implements it; otherwise uses the surface's tangent and bitangent vectors to implement the gradient
(however, this approach is generally only meaningful for a surface in three-dimensional space).

The <b>gradient</b> is a vector pointing up and away from the surface.
If the evaluator describes a regular three-dimensional surface (usually
a continuous, unbroken surface such as a sphere, an open
cylinder, or a disk rotated in three dimensions), this can be the cross product
of the tangent vector
and bitangent vector,
in that order. The gradient returned by this method <i>should not</i> be "normalized" to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `u` (Type: number)<br>U coordinate of a point on the surface.
* `v` (Type: number)<br>V coordinate of a point on the surface.

#### Return Value

An array describing a gradient vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number>)

#### Examples

The following example is a surface evaluator
object for a parametric surface with a gradient method. To illustrate how the gradient method is derived
from the vector calculation method, that method is also given below. To
derive the normal calculation, first look at the vector function:

<b>F</b>(u, v) = (cos(u), sin(u), sin(u)\*cos(v))

Then, find the partial derivatives with respect to <i>u</i> and to <i>v</i>:

&#x2202;<b>F</b>/&#x2202;<i>u</i> = (-sin(u), cos(u), cos(u)\*cos(v))<br>
&#x2202;<b>F</b>/&#x2202;<i>v</i> = (0, 0, -sin(v)\*sin(u))

Next, take their cross product:

<b>&Del;F</b>(u, v) = (-sin(v)\*cos(u)\*sin(u), -sin(v)\*sin(u)\*sin(u), 0)<br>

The result is the gradient, which will point up and away from the surface.

    var surface=new Surface({"evaluate":function(u,v) {
    "use strict";
    return [Math.cos(u),Math.sin(u),Math.sin(u)*Math.cos(v)];
    },
    "gradient":function(u,v) {
    "use strict";
    return [
    Math.cos(u)*-Math.sin(v)*Math.sin(u),
    Math.sin(u)*-Math.sin(v)*Math.sin(u),
    0];
    }})

<a name='extras_polyhedra_Polyhedra.hexahedron'></a>
### (static) module:extras/polyhedra~Polyhedra.hexahedron(radius, level)

Generates a mesh of a regular hexahedron (cube) or a sphere based on that solid.

#### Parameters

* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The generated solid. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.hexahedronFaces'></a>
### (static) module:extras/polyhedra~Polyhedra.hexahedronFaces()

Gets the vertices of a hexahedron (cube) with maximum radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_polyhedra_Polyhedra.hexahedronFacesCompact'></a>
### (static) module:extras/polyhedra~Polyhedra.hexahedronFacesCompact()

Gets a more compact representation of the vertices of a hexahedron
(cube) with maximum radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_gradients.horizontalGradient'></a>
### (static) module:extras/gradients.horizontalGradient(color1, color2)

Generates a 32x32 bitmap of a linear gradient in the horizontal direction. This function demonstrates generating a custom texture.

#### Parameters

* `color1` (Type: Array.&lt;number> | number | string)<br>A color vector or string identifying the color at the left edge of the gradient.
* `color2` (Type: Array.&lt;number> | number | string)<br>A color vector or string identifying the color at the right edge of the gradient.

#### Return Value

An array with 32x32x4 bytes, arranged in 32 rows of 32 pixels
of 4 bytes each. For each pixel, the four bytes are color components
in the following order: red, green, blue, alpha. (Type: UInt8Array)

<a name='extras_drawingtoy_DrawingToy_hypo'></a>
### module:extras/drawingtoy~DrawingToy#hypo(ringTeeth, wheelTeeth, hole, [phase], [offset])

Adds line segments that approximate a curve drawn by rolling a wheel inside a fixed ring (a <i>hypotrochoid</i>).

#### Parameters

* `ringTeeth` (Type: number)<br>Number of teeth in the fixed ring.
* `wheelTeeth` (Type: number)<br>Number of teeth in the rolling wheel.
* `hole` (Type: number)<br>Integer, starting from 1, identifying the hole within the wheel in which the drawing pen is placed. The greater the number, the closer the hole is to the center of the wheel.
* `phase` (Type: number) (optional)<br>Phase, in degrees, of the angle where the ring's and wheel's teeth are engaged. If null, undefined, or omitted, the default value is 0. TODO: Document this parameter more exactly.
* `offset` (Type: number) (optional)<br>X coordinate of the center of the fixed ring. If null, undefined, or omitted, the default value is 0.

#### Return Value

This object. (Type: DrawingToy)

<a name='extras_polyhedra_Polyhedra.icosahedron'></a>
### (static) module:extras/polyhedra~Polyhedra.icosahedron(radius, level)

Generates a mesh of a regular icosahedron or a sphere based on that solid.

#### Parameters

* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The generated solid. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.icosahedronFaces'></a>
### (static) module:extras/polyhedra~Polyhedra.icosahedronFaces()

Gets the vertices of a regular icosahedron with maximum radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_torusknot_TorusKnot.interlaced'></a>
### (static) module:extras/torusknot~TorusKnot.interlaced(p, q, r1, s1)

TODO: Not documented yet.

#### Parameters

* `p` (Type: number)<br>Integer greater than 0 giving the number of revolutions.
* `q` (Type: number)<br>Integer greater than 0 giving the number of loop crossings.
* `r1` (Type: *)
* `s1` (Type: *)

#### Return Value

The resulting torus knot evaluator. (Type: TorusKnot)

<a name='H3DU.MathUtil.interpCubicBezier'></a>
### (static) H3DU.MathUtil.interpCubicBezier(a, b, c, d, t)

An interpolation timing function based on the path of a
cubic B&eacute;zier
curve with end points (0, 0) and (1, 1) and with two
configurable control points. The X coordinates of the
curve indicate time, and the Y coordinates of the curve
indicate how far the interpolation has reached.

#### Parameters

* `a` (Type: number)<br>X coordinate of the first configurable control point of the curve. Should be within the range 0 through 1.
* `b` (Type: number)<br>Y coordinate of the first configurable control point of the curve. Should be within the range 0 through 1, but may exceed this range.
* `c` (Type: number)<br>X coordinate of the second configurable control point of the curve. Should be within the range 0 through 1.
* `d` (Type: number)<br>Y coordinate of the second configurable control point of the curve. Should be within the range 0 through 1, but may exceed this range.
* `t` (Type: number)<br>Number ranging from 0 through 1 that indicates time.

#### Return Value

Number ranging from 0 through 1 that indicates
how far the interpolation has reached. Returns 0 if <code>t</code>
is 0 or less, and 1 if <code>t</code> is 1 or greater. (Type: number)

<a name='H3DU.GraphicsPath_interpolate'></a>
### H3DU.GraphicsPath#interpolate(other, t)

Does a linear interpolation between two graphics paths.

#### Parameters

* `other` (Type: GraphicsPath)<br>The second graphics path.
* `t` (Type: number)<br>An interpolation factor, generally ranging from 0 through 1. Closer to 0 means closer to this path, and closer to 1 means closer to "other". If the input paths contain arc segments that differ in the large arc and sweep flags, the flags from the first path's arc are used if "t" is less than 0.5; and the flags from the second path's arc are used otherwise.

For a nonlinear interpolation, define a function that takes a value that usually ranges from 0 through 1 and generally returns a value that usually ranges from 0 through 1, and pass the result of that function to this method. See the documentation for MathUtil.vec3lerp for examples of interpolation functions.

#### Return Value

The interpolated path. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_intersection'></a>
### H3DU.GraphicsPath#intersection(path, [flatness])

Computes the intersection, or the area common to both this path's shape
and another path's shape. The points given in the GraphicsPath#union method
apply to this method.

#### Parameters

* `path` (Type: GraphicsPath)<br>A path to combine with this one.
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

A path whose shape is contained in
both paths. (Type: GraphicsPath)

<a name='H3DU.Transform_isIdentity'></a>
### H3DU.Transform#isIdentity()

Returns whether this transform is the identity transform.

#### Return Value

Return value. (Type: boolean)

<a name='H3DU.GraphicsPath_isIncomplete'></a>
### H3DU.GraphicsPath#isIncomplete()

Returns whether the curve path is incomplete
because of an error in parsing the curve string.
This flag will be reset if a moveTo command,
closePath command, or another path segment
is added to the path.

#### Return Value

Return value. (Type: boolean)

<a name='H3DU.Curve_jerk'></a>
### H3DU.Curve#jerk(u)

Finds an approximate jerk vector at the given U coordinate of this curve.
The implementation in Curve calls the evaluator's <code>jerk</code>
method if it implements it; otherwise, does a numerical differentiation using
the acceleration vector.

The <b>jerk</b> of a curve is a vector which is the third-order derivative of the curve's position at the given coordinate. The vector returned by this method <i>should not</i> be "normalized" to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `u` (Type: number)<br>U coordinate of a point on the curve.

#### Return Value

An array describing a jerk vector. It should have at least as many
elements as the number of dimensions of the underlying curve. (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_line'></a>
### H3DU.GraphicsPath#line(x0, y0, x1, y1)

Adds a line segment to this path.

#### Parameters

* `x0` (Type: number)<br>X coordinate of the line segment's starting point. The <code>moveTo</code> method will be called on the starting point.
* `y0` (Type: number)<br>Y coordinate of the line segment's starting point.
* `x1` (Type: number)<br>X coordinate of the line segment's ending point. The <code>lineTo</code> method will be called on the ending point.
* `y1` (Type: number)<br>X coordinate of the line segment's ending point.

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_lineTo'></a>
### H3DU.GraphicsPath#lineTo(x, y)

Adds a line segment to the path, starting
at the path's end position, then
sets the end position to the end of the segment.

#### Parameters

* `x` (Type: number)<br>X coordinate of the end of the line segment.
* `y` (Type: number)<br>Y coordinate of the end of the line segment.

#### Return Value

This object. (Type: GraphicsPath)

<a name='extras_text_H3DU.TextureAtlas.load'></a>
### (static) module:extras/text~H3DU.TextureAtlas.load(data, atlasFileName)

Loads a texture atlas definition from a file.
Note that this method only loads the texture atlas data and not the bitmaps
used by the texture atlas.

#### Parameters

* `data` (Type: ArrayBuffer)<br>Data containing a texture atlas definition.
* `atlasFileName` (Type: string)<br>The URL of the texture atlas to load.

#### Return Value

A texture atlas if the texture atlas data is loaded successfully, and null if an error occurs. (Type: <a href="H3DU.TextureAtlas.md">H3DU.TextureAtlas</a> | null)

<a name='extras_text_H3DU.TextFont.loadData'></a>
### (static) module:extras/text~H3DU.TextFont.loadData(data, fontFileName)

Loads a bitmap font definition from a file.
Note that this method only loads the font data and not the bitmaps
used to represent the font.

#### Parameters

* `data` (Type: ArrayBuffer)<br>The data containing a bitmap font definition.
* `fontFileName` (Type: string)<br>The URL of the font data file to load. The following file extensions are read as the following formats:<ul> <li>".xml": XML</li> <li>".json": JSON</li> <li>".bin": Binary</li> <li>".fnt": Text or binary</li> <li>All others: Text</li></ul>

#### Return Value

Text font data, or null if an error occurs. (Type: TextFont | null)

<a name='extras_matrixstack_MatrixStack_loadIdentity'></a>
### module:extras/matrixstack~MatrixStack#loadIdentity()

Modifies the matrix at the top of this stack by replacing it with the identity matrix.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_matrixstack_MatrixStack_loadMatrix'></a>
### module:extras/matrixstack~MatrixStack#loadMatrix(mat)

Modifies the matrix at the top of this stack by replacing it with the given matrix.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A matrix to replace the top of the stack with.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_text_H3DU.TextureAtlas_loadTextures'></a>
### module:extras/text~H3DU.TextureAtlas#loadTextures(textureLoader)

Loads the texture files used by this texture atlas.

#### Parameters

* `textureLoader` (Type: H3DU.TextureLoader)<br>Texture loader object to use when loading the textures.

#### Return Value

A promise as described in
<a href="H3DU.md#H3DU.getPromiseResultsAll">H3DU.getPromiseResultsAll</a>. If the promise
resolves, each item in the resulting array will be a loaded
H3DU.Texture object. (Type: <a href="Promise.md">Promise</a>.&lt;Array.&lt;H3DU.Texture>>)

<a name='extras_tga.loadTga'></a>
### (static) module:extras/tga.loadTga(data)

TODO: Not documented yet.

#### Parameters

* `data` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_matrixstack_MatrixStack_loadTransposeMatrix'></a>
### module:extras/matrixstack~MatrixStack#loadTransposeMatrix(mat)

Modifies the matrix at the top of this stack by replacing it with the
transpose of the given matrix.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A matrix whose transpose will replace the top of the stack.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_text_H3DU.TextureAtlas.loadWithTextures'></a>
### (static) module:extras/text~H3DU.TextureAtlas.loadWithTextures(atlasFileName, textureLoader)

Loads a texture atlas definition from a file along with the textures
it uses.

#### Parameters

* `atlasFileName` (Type: string)<br>The URL of the texture atlas to load.
* `textureLoader` (Type: H3DU.TextureLoader)<br>Texture loader object to use when loading the textures.

#### Return Value

A promise that is resolved
when the texture atlas data and textures are loaded successfully,
and is rejected when an error occurs.
If the promise is resolved, the result will be an object with the
following keys:<ul>
<li><code>url</code> - The URL of the texture atlas data file.
<li><code>atlas</code> - The texture atlas data in the form of an <a href="H3DU.TextureAtlas.md">H3DU.TextureAtlas</a> object.
<li><code>textures</code> - An array of H3DU.Texture objects used by the font,
in the order in which they are declared in the font data file.
</ul> (Type: <a href="Promise.md">Promise</a>)

<a name='extras_matrixstack_MatrixStack_lookAt'></a>
### module:extras/matrixstack~MatrixStack#lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz)

Modifies the matrix at the top of this stack by multiplying it by
a matrix representing a camera view.
This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.

#### Parameters

* `ex` (Type: number)<br>X coordinate of the camera position in world space.
* `ey` (Type: number)<br>Y coordinate of the camera position.
* `ez` (Type: number)<br>Z coordinate of the camera position.
* `cx` (Type: number)<br>X coordinate of the position in world space that the camera is looking at.
* `cy` (Type: number)<br>Y coordinate of the position looked at.
* `cz` (Type: number)<br>Z coordinate of the position looked at.
* `ux` (Type: number)<br>X coordinate of the up direction vector. This vector must not point in the same or opposite direction as the camera's view direction.
* `uy` (Type: number)<br>Y coordinate of the up vector.
* `uz` (Type: number)<br>Z coordinate of the up vector.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.BufferAccessor.makeBlank'></a>
### (static) H3DU.BufferAccessor.makeBlank(count, countPerValue)

Generates a vertex attribute buffer, with each value set to all zeros.

#### Parameters

* `count` (Type: number)<br>The number of values the buffer will hold. For example, (10, 20, 5) is a 3-element value.
* `countPerValue` (Type: number)<br>The number of elements each value will take in the buffer.

#### Return Value

A blank vertex attribute buffer. (Type: BufferAccessor)

<a name='H3DU.BufferAccessor.makeIndices'></a>
### (static) H3DU.BufferAccessor.makeIndices(numIndices)

Generates an array of increasing vertex indices.

#### Parameters

* `numIndices` (Type: number)<br>The number of vertex indices to generate. The array will range from 0 to the number of vertex indices minus 1.

#### Return Value

An array of vertex indices. (Type: Uint16Array | Uint32Array)

<a name='extras_polyhedra_Polyhedra.makeSphere'></a>
### (static) module:extras/polyhedra~Polyhedra.makeSphere(vi, radius, level)

Modifies the vertices and indices of a solid to
generate an approximation of a sphere.

#### Parameters

* `vi` (Type: Array.&lt;Array.&lt;number>>)<br>A two-element array. The first element contains an array of the vertices that make up the solid (each vertex's X, Y, and Z coordinates are stored as three elements of that array), and the second element contains an array of vertex indices (multiplying each element by 3 will get the index to the first coordinate of the corresponding vertex in the first array).
* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The "vi" parameter, which will likely be modified. (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_text_H3DU.TextureAtlas_makeSprites'></a>
### module:extras/text~H3DU.TextureAtlas#makeSprites(sprites)

Makes a shape group used to display one or more sprites.
For the sprites to show upright, the coordinate system should have the
X axis pointing right and the Y axis pointing down (for example, an
orthographic projection where the left and top coordinates are less
than the right and bottom coordinates, respectively). The size of each
sprite will be in pixels; therefore, for best results, the coordinate system
should be scaled so that one unit equals one pixel.

#### Parameters

* `sprites` (Type: Array.&lt;Object>)<br>An array of objects whose keys have the possibilities given below, and whose values are those allowed for each key.<ul> <li><code>name</code> - Name of the sprite, as listed in this texture atlas. <li><code>index</code> - If a sprite has multiple versions, use this index parameter to distinguish them. Index can't be less than 0. If a sprite doesn't have multiple versions, this value is not required. <li><code>x</code> - X coordinate of the sprite. <li><code>y</code> - Y coordinate of the sprite. </ul>

#### Return Value

The generated group of shapes. (Type: <a href="H3DU.ShapeGroup.md">H3DU.ShapeGroup</a>)

<a name='extras_text_H3DU.TextFont_makeTextMeshes'></a>
### module:extras/text~H3DU.TextFont#makeTextMeshes(str, params)

Creates an array of meshes containing the primitives
needed to draw text with this font.

#### Parameters

* `str` (Type: string)<br>The text to draw. Line breaks ("\n", "\r", "\r\n") are recognized by this method.
* `params` (Type: Object)<br>An object whose keys have the possibilities given below, and whose values are those allowed for each key.<ul> <li><code>x</code> - X coordinate of the top left corner of the text. If null, undefined, or omitted, uses 0. For the text to show upright, the coordinate system should have the X axis pointing right and the Y axis pointing down (for example, an orthographic projection where the left and top coordinates are less than the right and bottom coordinates, respectively). <li><code>y</code> - Y coordinate of the top left corner of the text. If null, undefined, or omitted, uses 0. <li><code>lineHeight</code> - Height of each line of the text in units. If null, undefined, or omitted, uses the line height given in the font. <li><code>width</code> - Maximum width of each line. Lines that exceed this width will be wrapped. <li><code>align</code> - Horizontal text alignment. Can be "left", "center", or "right" (all strings). </ul>

#### Return Value

An array of meshes representing the text.
There is one mesh for each texture page of the font. If none of the
text uses a given page, the corresponding mesh will be null. (Type: Array.&lt;<a href="H3DU.MeshBuffer.md">H3DU.MeshBuffer</a>>)

<a name='H3DU.MathUtil.mat3copy'></a>
### (static) H3DU.MathUtil.mat3copy(mat)

Returns a copy of a 3x3 matrix.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 3x3atrix.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3identity'></a>
### (static) H3DU.MathUtil.mat3identity()

Returns the identity 3x3 matrix (a matrix that keeps
vectors unchanged when they are transformed with this matrix).

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3invert'></a>
### (static) H3DU.MathUtil.mat3invert(m)

Finds the inverse of a 3x3 matrix, describing a transformation that undoes the given transformation.

#### Parameters

* `m` (Type: Array.&lt;number>)<br>A 3x3 matrix.

#### Return Value

The resulting 3x3 matrix.
Returns the identity matrix if this matrix's determinant, or overall scaling factor, is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3multiply'></a>
### (static) H3DU.MathUtil.mat3multiply(a, b)

Multiplies two 3x3 matrices. A new matrix is returned.
The matrices are multiplied such that the transformations
they describe happen in reverse order. For example, if the first
matrix (input matrix) describes a translation and the second
matrix describes a scaling, the multiplied matrix will describe
the effect of scaling then translation.

The matrix multiplication is effectively done by breaking up matrix <code>b</code>
into three 3-element vectors (the first 3 elements make up the first vector, and so on),
transforming each vector with
matrix <code>a</code>, and putting the vectors back together into a new matrix.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first matrix.
* `b` (Type: Array.&lt;number>)<br>The second matrix.

#### Return Value

The resulting 3x3 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3transform'></a>
### (static) H3DU.MathUtil.mat3transform(mat, v, [vy], [vz])

Transforms a 3-element vector with a 3x3 matrix and returns
the transformed vector.

Transforming a vector (<code>v</code>) with a matrix (<code>mat</code>)
is effectively done by breaking up <code>mat</code> into three 3-element vectors
(the first 3 elements make up the first vector, and so on), multiplying
each vector in <code>mat</code> by the corresponding component in
<code>v</code>, and adding up the resulting vectors (except <code>v</code>) to
get the transformed vector.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 3x3 matrix.
* `v` (Type: Array.&lt;number> | number)<br>X coordinate. If "vy", and "vz" are omitted, this value can instead be a 4-element array giving the X, Y, and Z coordinates.
* `vy` (Type: number) (optional)<br>Y coordinate.
* `vz` (Type: number) (optional)<br>Z coordinate. To transform a 2D point, set Z to 1, and divide the result's X and Y by the result's Z.

#### Return Value

The transformed vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3transpose'></a>
### (static) H3DU.MathUtil.mat3transpose(m3)

Returns the transpose of a 3x3 matrix. (A transpose is a
matrix whose rows are converted to columns and vice versa.)

#### Parameters

* `m3` (Type: Array.&lt;number>)<br>A 3x3 matrix.

#### Return Value

The resulting 3x3 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat3transposeInPlace'></a>
### (static) H3DU.MathUtil.mat3transposeInPlace(mat)

Transposes a 3x3 matrix in place without creating
a new matrix. (A transpose is a matrix whose rows
are converted to columns and vice versa.)

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 3x3 matrix.

#### Return Value

The parameter "mat". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4copy'></a>
### (static) H3DU.MathUtil.mat4copy(mat)

Returns a copy of a 4x4 matrix.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4frustum'></a>
### (static) H3DU.MathUtil.mat4frustum(l, r, b, t, near, far)

Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>
in the form of a view frustum, or the limits in the "camera"'s view.

When just this matrix is used to transform vertices, the X, Y, and Z coordinates within the
view volume (as is the case in WebGL) will range from -W to W (where W is the fourth
component of the transformed vertex). For a matrix in which Z coordinates
range from 0 to W, divide the 15th element of the result (zero-based index 14) by 2.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
To adjust the result of this method for a left-handed system,
reverse the sign of the 9th, 10th, 11th, and 12th
elements of the result (zero-based indices 8, 9, 10, and 11).

#### Parameters

* `l` (Type: number)<br>X coordinate of the point in eye space where the left clipping plane meets the near clipping plane.
* `r` (Type: number)<br>X coordinate of the point in eye space where the right clipping plane meets the near clipping plane. ("l" is usually less than "r", so that X coordinates increase from left to right. If "l" is greater than "r", X coordinates increase in the opposite direction.)
* `b` (Type: number)<br>Y coordinate of the point in eye space where the bottom clipping plane meets the near clipping plane.
* `t` (Type: number)<br>Y coordinate of the point in eye space where the top clipping plane meets the near clipping plane. ("b" is usually less than "t", so that Y coordinates increase upward, as they do in WebGL when just this matrix is used to transform vertices. If "b" is greater than "t", Y coordinates increase in the opposite direction.)
* `near` (Type: number)<br>The distance, in eye space, from the "camera" to the near clipping plane. Objects closer than this distance won't be seen.

This value should be greater than 0, and should be set to the highest distance from the "camera" that the application can afford to clip out for being too close, for example, 0.5, 1, or higher.
* `far` (Type: number)<br>The distance, in eye space, from the "camera" to the far clipping plane. Objects farther than this distance won't be seen.<br>This value should be greater than 0 and should be set so that the absolute ratio of "far" to "near" is as small as the application can accept. ("near" is usually less than "far", so that Z coordinates increase from near to far in the direction from the back to the front of the "eye", as they do in WebGL when just this matrix is used to transform vertices. If "near" is greater than "far", Z coordinates increase in the opposite direction.)<br> In the usual case that "far" is greater than "near", depth buffer values will be more concentrated around the near plane than around the far plane due to the perspective projection. The greater the ratio of "far" to "near", the more concentrated the values will be around the near plane, and the more likely two objects close to the far plane will have identical depth values. (Most WebGL implementations support 24-bit depth buffers, meaning they support 16,777,216 possible values per pixel.)

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4identity'></a>
### (static) H3DU.MathUtil.mat4identity()

Returns the identity 4x4 matrix (a matrix that keeps
vectors unchanged when they are transformed with this matrix).

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4inverseTranspose3'></a>
### (static) H3DU.MathUtil.mat4inverseTranspose3(m4)

Returns the transposed result of the inverted 3x3 upper left corner of
the given 4x4 matrix.

This is usually used to convert a model-view matrix (view matrix multiplied by model or world matrix) to a matrix
for transforming surface normals in order to keep them perpendicular
to a surface transformed by the model-view matrix. Normals are then
transformed by this matrix and then converted to <a href="tutorial-glmath.md">unit vectors</a>. But if the
input matrix uses only rotations, translations, and/or uniform scaling
(same scaling in X, Y, and Z), the 3x3 upper left of the input matrix can
be used instead of the inverse-transpose matrix to transform the normals.

#### Parameters

* `m4` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The resulting 3x3 matrix. If the matrix
can't be inverted, returns the identity 3x3 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4invert'></a>
### (static) H3DU.MathUtil.mat4invert(m)

Finds the inverse of a 4x4 matrix, describing a transformation that undoes the given transformation.

#### Parameters

* `m` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The resulting 4x4 matrix.
Returns the identity matrix if this matrix's determinant, or overall scaling factor, is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4isIdentity'></a>
### (static) H3DU.MathUtil.mat4isIdentity(mat)

Returns whether a 4x4 matrix is the identity matrix.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

Return value. (Type: boolean)

<a name='H3DU.MathUtil.mat4lookat'></a>
### (static) H3DU.MathUtil.mat4lookat(viewerPos, [lookingAt], [up])

Returns a 4x4 matrix that represents a camera view,
transforming world space coordinates, shared by every object in a scene, to coordinates in <i>eye space</i>
(also called <i>camera space</i> or <i>view space</i>). This essentially rotates a "camera"
and moves it to somewhere in the scene. In eye space:<ul>
<li>The "camera" is located at the origin (0,0,0), or
at <code>viewerPos</code> in world space,
and points away from the viewer toward the <code>lookingAt</code>
position in world space. This generally
puts <code>lookingAt</code> at the center of the view.
<li>The X axis points rightward from the "camera"'s viewpoint.
<li>The Y axis points upward from the center of the "camera" to its top. The
<code>up</code> vector guides this direction.
<li>The Z axis is parallel to the direction from the "camera"
to the <code>lookingAt</code> point.</ul>

This method is designed for use in a <a href="tutorial-glmath.md">right-handed coordinate system</a>
(the Z axis's direction will be from the "camera" to the point looked at).
To adjust the result of this method for a left-handed system,
reverse the sign of the 1st, 3rd, 5th, 7th, 9th, 11th,
13th, and 15th elements of the result (zero-based indices 0, 2, 4, 6, 8,
10, 12, and 14); the Z axis's direction will thus be from the point looked at to the "camera".

#### Parameters

* `viewerPos` (Type: Array.&lt;number>)<br>A 3-element vector specifying the "camera" position in world space.<br> When used in conjunction with an orthographic projection, set this parameter to the value of <code>lookingAt</code> plus a <a href="tutorial-glmath.md">unit vector</a> (for example, using MathUtil.vec3add) to form an <i>axonometric projection</i> (if the unit vector is <code>[sqrt(1/3),sqrt(1/3),sqrt(1/3)]</code>, the result is an <i>isometric projection</i>). See the examples below.
* `lookingAt` (Type: Array.&lt;number>) (optional)<br>A 3-element vector specifying the point in world space that the "camera" is looking at. May be null or omitted, in which case the default is the coordinates (0,0,0).
* `up` (Type: Array.&lt;number>) (optional)<br>A 3-element vector specifying the direction from the center of the "camera" to its top. This parameter may be null or omitted, in which case the default is the vector (0, 1, 0), the vector that results when the "camera" is held upright.<br> This vector must not be parallel to the view direction (the direction from "viewerPos" to "lookingAt"). (See the example for one way to ensure this.)<br>

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

#### Examples

The following example calls this method with an
up vector of (0, 1, 0) except if the view direction is parallel to that
vector or nearly so.

    var upVector=[0,1,0]; // Y axis
    var viewdir=MathUtil.vec3sub(lookingAt, viewerPos);
    var par=MathUtil.vec3length(MathUtil.vec3cross(viewdir,upVector));
    if(par<0.00001)upVector=[0,0,1]; // view is almost parallel, so use Z axis
    var matrix=MathUtil.mat4lookat(viewerPos,lookingAt,upVector);

The following example creates an
isometric projection for a right-handed coordinate system. The Y
axis will point up, the Z axis toward the bottom left, and the X axis toward
the bottom right.

    // Assumes an orthographic projection matrix is used. Example:
    // var projectionMatrix=MathUtil.mat4ortho(-10,10,-10,10,-50,50);
    // Camera will be at (1,1,1) -- actually (sqrt(1/3),sqrt(1/3),sqrt(1/3)) --
    // and point toward [0,0,0]
    var lookPoint=[0,0,0];
    var cameraPoint=MathUtil.vec3normalize([1,1,1]);
    cameraPoint=MathUtil.vec3add(cameraPoint,lookPoint);
    var matrix=MathUtil.mat4lookat(cameraPoint,lookPoint);

The following example is like the previous
example, but with the Z axis pointing up.

    var lookPoint=[0,0,0];
    var cameraPoint=MathUtil.vec3normalize([1,1,1]);
    cameraPoint=MathUtil.vec3add(cameraPoint,lookPoint);
    // Positive Z axis is the up vector
    var matrix=MathUtil.mat4lookat(cameraPoint,lookPoint,[0,0,1]);

The following example creates a camera view matrix using the
viewer position, the viewing direction, and the up vector (a "look-to" matrix):

    var viewDirection=[0,0,1]
    var viewerPos=[0,0,0]
    var upVector=[0,1,0]
    var lookingAt=MathUtil.vec3add(viewerPos,viewDirection);
    var matrix=MathUtil.mat4lookat(viewerPos,lookingAt,upVector);

<a name='H3DU.MathUtil.mat4multiply'></a>
### (static) H3DU.MathUtil.mat4multiply(a, b)

Multiplies two 4x4 matrices. A new matrix is returned.
The matrices are multiplied such that the transformations
they describe happen in reverse order. For example, if the first
matrix (input matrix) describes a translation and the second
matrix describes a scaling, the multiplied matrix will describe
the effect of scaling then translation.

The matrix multiplication is effectively done by breaking up matrix <code>b</code>
into four 4-element vectors (the first 4 elements make up the first vector, and so on),
transforming each vector with
matrix <code>a</code>, and putting the vectors back together into a new matrix.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first matrix.
* `b` (Type: Array.&lt;number>)<br>The second matrix.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4oblique'></a>
### (static) H3DU.MathUtil.mat4oblique(alpha, phi)

Returns a 4x4 view matrix representing an oblique projection,
when used in conjunction with an orthographic projection.

This method works the same way in right-handed and left-handed
coordinate systems.

#### Parameters

* `alpha` (Type: number)<br>Controls how much the Z axis is stretched. In degrees. A value of 45 (<code>arctan(1)</code>) indicates a cabinet projection, and a value of 63.435 (<code>arctan(2)</code>) indicates a cavalier projection.
* `phi` (Type: number)<br>Controls the apparent angle of the negative Z axis in relation to the positive X axis. In degrees. 0 means the negative Z axis appears to point in the same direction as the positive X axis, and 90, in the same direction as the positive Y axis.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4ortho'></a>
### (static) H3DU.MathUtil.mat4ortho(l, r, b, t, n, f)

Returns a 4x4 matrix representing an <a href="tutorial-camera.md">orthographic projection</a>.
In this projection, the left clipping plane is parallel to the right clipping
plane and the top to the bottom.

The projection returned by this method only scales and/or shifts the view, so that
objects with the same size won't appear smaller as they get more distant from the "camera".

When just this matrix is used to transform vertices, the X, Y, and Z coordinates within the
view volume (as is the case in WebGL) will range from -1 to 1.
For a matrix in which Z coordinates range from 0 to 1, divide the 11th and 15th elements
of the result (zero-based indices 10 and 14) by 2, then add 0.5 to the 15th element.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
To adjust the result of this method for a left-handed system,
reverse the sign of the 11th element of the result (zero-based index 10).

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the orthographic view.
* `r` (Type: number)<br>Rightmost coordinate of the orthographic view. ("l" is usually less than "r", so that X coordinates increase from left to right. If "l" is greater than "r", X coordinates increase in the opposite direction.)
* `b` (Type: number)<br>Bottommost coordinate of the orthographic view.
* `t` (Type: number)<br>Topmost coordinate of the orthographic view. ("b" is usually less than "t", so that Y coordinates increase upward, as they do in WebGL when just this matrix is used to transform vertices. If "b" is greater than "t", Y coordinates increase in the opposite direction.)
* `n` (Type: number)<br>Distance from the "camera" to the near clipping plane. A positive value means the plane is in front of the viewer.
* `f` (Type: number)<br>Distance from the "camera" to the far clipping plane. A positive value means the plane is in front of the viewer. ("n" is usually less than "f", so that Z coordinates increase from near to far in the direction from the back to the front of the "eye", as they do in WebGL when just this matrix is used to transform vertices. If "n" is greater than "f", Z coordinates increase in the opposite direction.) The absolute difference between n and f should be as small as the application can accept.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4ortho2d'></a>
### (static) H3DU.MathUtil.mat4ortho2d(l, r, b, t)

Returns a 4x4 matrix representing a 2D <a href="tutorial-camera.md">orthographic projection</a>.

This is the same as mat4ortho() with the near clipping plane
set to -1 and the far clipping plane set to 1.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
See mat4ortho() for information on the meaning of coordinates
when using this matrix and on adjusting the matrix for other conventions.

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the orthographic view.
* `r` (Type: number)<br>Rightmost coordinate of the orthographic view. ("l" is usually less than "r", so that X coordinates increase from left to right. If "l" is greater than "r", X coordinates increase in the opposite direction.)
* `b` (Type: number)<br>Bottommost coordinate of the orthographic view.
* `t` (Type: number)<br>Topmost coordinate of the orthographic view. ("b" is usually less than "t", so that Y coordinates increase upward, as they do in WebGL when just this matrix is used to transform vertices. If "b" is greater than "t", Y coordinates increase in the opposite direction.)

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4ortho2dAspect'></a>
### (static) H3DU.MathUtil.mat4ortho2dAspect(l, r, b, t, aspect)

Returns a 4x4 matrix representing a 2D <a href="tutorial-camera.md">orthographic projection</a>,
retaining the view rectangle's aspect ratio.

If the view rectangle's aspect ratio doesn't match the desired aspect
ratio, the view rectangle will be centered on the viewport
or otherwise moved and scaled so as to keep the entire view rectangle visible without stretching
or squishing it.

This is the same as mat4orthoAspect() with the near clipping plane
set to -1 and the far clipping plane set to 1.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
See mat4ortho() for information on the meaning
of coordinates when using this matrix and on adjusting the matrix for other conventions.

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the view rectangle.
* `r` (Type: number)<br>Rightmost coordinate of the orthographic view. ("l" is usually less than "r", so that X coordinates increase from left to right. If "l" is greater than "r", X coordinates increase in the opposite direction.)
* `b` (Type: number)<br>Bottommost coordinate of the orthographic view.
* `t` (Type: number)<br>Topmost coordinate of the orthographic view. ("b" is usually less than "t", so that Y coordinates increase upward, as they do in WebGL when just this matrix is used to transform vertices. If "b" is greater than "t", Y coordinates increase in the opposite direction.)
* `aspect` (Type: number)<br>The ratio of width to height of the viewport, usually the scene's aspect ratio.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4orthoAspect'></a>
### (static) H3DU.MathUtil.mat4orthoAspect(l, r, b, t, n, f, aspect)

Returns a 4x4 matrix representing an <a href="tutorial-camera.md">orthographic projection</a>,
retaining the view rectangle's aspect ratio.

If the view rectangle's aspect ratio doesn't match the desired aspect
ratio, the view rectangle will be centered on the viewport
or otherwise moved and scaled so as to keep the entire view rectangle visible without stretching
or squishing it.

The projection returned by this method only scales and/or shifts the view, so that
objects with the same size won't appear smaller as they get more distant from the "camera".

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
See mat4ortho() for information on the meaning of coordinates
when using this matrix and on adjusting the matrix for other conventions.

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the view rectangle.
* `r` (Type: number)<br>Rightmost coordinate of the orthographic view. ("l" is usually less than "r", so that X coordinates increase from left to right. If "l" is greater than "r", X coordinates increase in the opposite direction.)
* `b` (Type: number)<br>Bottommost coordinate of the orthographic view.
* `t` (Type: number)<br>Topmost coordinate of the orthographic view. ("b" is usually less than "t", so that Y coordinates increase upward, as they do in WebGL when just this matrix is used to transform vertices. If "b" is greater than "t", Y coordinates increase in the opposite direction.)
* `n` (Type: number)<br>Distance from the "camera" to the near clipping plane. A positive value means the plane is in front of the viewer.
* `f` (Type: number)<br>Distance from the "camera" to the far clipping plane. A positive value means the plane is in front of the viewer. ("n" is usually less than "f", so that Z coordinates increase from near to far in the direction from the back to the front of the "eye", as they do in WebGL when just this matrix is used to transform vertices. If "n" is greater than "f", Z coordinates increase in the opposite direction.) The absolute difference between n and f should be as small as the application can accept.
* `aspect` (Type: number)<br>The ratio of width to height of the viewport, usually the scene's aspect ratio.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4perspective'></a>
### (static) H3DU.MathUtil.mat4perspective(fovY, aspectRatio, near, far)

Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>.

When just this matrix is used to transform vertices, the X, Y, and Z coordinates within the
view volume (as is the case in WebGL) will range from -W to W (where W is the fourth
component of the transformed vertex) and
increase from left to right and bottom to top. For a matrix in which Z coordinates
range from 0 to W, divide the 15th element of the result (zero-based index 14) by 2.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
To adjust the result of this method for a left-handed system,
reverse the sign of the 9th, 10th, 11th, and 12th
elements of the result (zero-based indices 8, 9, 10, and 11).

#### Parameters

* `fovY` (Type: number)<br>Y axis field of view, in degrees, that is, the shortest angle between the top and bottom clipping planes. Should be less than 180 degrees. (The smaller this number, the bigger close objects appear to be. As a result, zooming out can be implemented by raising this value, and zooming in by lowering it.)
* `aspectRatio` (Type: number)<br>The ratio of width to height of the viewport, usually the scene's aspect ratio.
* `near` (Type: number)<br>The distance, in eye space, from the "camera" to the near clipping plane. Objects closer than this distance won't be seen.

This value should be greater than 0, and should be set to the highest distance from the "camera" that the application can afford to clip out for being too close, for example, 0.5, 1, or higher.
* `far` (Type: number)<br>The distance, in eye space, from the "camera" to the far clipping plane. Objects farther than this distance won't be seen.<br>This value should be greater than 0 and should be set so that the absolute ratio of "far" to "near" is as small as the application can accept. ("near" is usually less than "far", so that Z coordinates increase from near to far in the direction from the back to the front of the "eye", as they do in WebGL when just this matrix is used to transform vertices. If "near" is greater than "far", Z coordinates increase in the opposite direction.)<br> In the usual case that "far" is greater than "near", depth buffer values will be more concentrated around the near plane than around the far plane due to the perspective projection. The greater the ratio of "far" to "near", the more concentrated the values will be around the near plane, and the more likely two objects close to the far plane will have identical depth values. (Most WebGL implementations support 24-bit depth buffers, meaning they support 16,777,216 possible values per pixel.)

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4perspectiveHorizontal'></a>
### (static) H3DU.MathUtil.mat4perspectiveHorizontal(fovX, aspectRatio, near, far)

Returns a 4x4 matrix representing a <a href="tutorial-camera.md">perspective projection</a>,
given an X axis field of view.
When just this matrix is used to transform vertices, the X, Y, and Z coordinates within the
view volume (as is the case in WebGL) will range from -W to W (where W is the fourth
component of the transformed vertex) and
increase from left to right and bottom to top. For a matrix in which Z coordinates
range from 0 to W, divide the 15th element of the result (zero-based index 14) by 2.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.
To adjust the result of this method for a left-handed system,
reverse the sign of the 9th, 10th, 11th, and 12th
elements of the result (zero-based indices 8, 9, 10, and 11).

#### Parameters

* `fovX` (Type: number)<br>X axis field of view, in degrees, that is, the shortest angle between the left and right clipping planes. Should be less than 180 degrees. (The smaller this number, the bigger close objects appear to be. As a result, zooming out can be implemented by raising this value, and zooming in by lowering it.)
* `aspectRatio` (Type: number)<br>The ratio of width to height of the viewport, usually the scene's aspect ratio.
* `near` (Type: number)<br>The distance, in eye space, from the "camera" to the near clipping plane. Objects closer than this distance won't be seen.

This value should be greater than 0, and should be set to the highest distance from the "camera" that the application can afford to clip out for being too close, for example, 0.5, 1, or higher.
* `far` (Type: number)<br>The distance, in eye space, from the "camera" to the far clipping plane. Objects farther than this distance won't be seen.<br>This value should be greater than 0 and should be set so that the absolute ratio of "far" to "near" is as small as the application can accept. ("near" is usually less than "far", so that Z coordinates increase from near to far in the direction from the back to the front of the "eye", as they do in WebGL when just this matrix is used to transform vertices. If "near" is greater than "far", Z coordinates increase in the opposite direction.)<br> In the usual case that "far" is greater than "near", depth buffer values will be more concentrated around the near plane than around the far plane due to the perspective projection. The greater the ratio of "far" to "near", the more concentrated the values will be around the near plane, and the more likely two objects close to the far plane will have identical depth values. (Most WebGL implementations support 24-bit depth buffers, meaning they support 16,777,216 possible values per pixel.)

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4projectVec3'></a>
### (static) H3DU.MathUtil.mat4projectVec3(mat, v, [vy], [vz])

Transforms a 3-element vector with a 4x4 matrix and returns
a perspective-correct version of the vector as a 3D point.

The transformation involves transforming a 4-element vector with the same X,
Y, and Z coordinates, but with a W coordinate equal to 1, with the 4x4 matrix, and
then dividing X, Y, and Z of the transformed 4-element
vector by that vector's W (a <i>perspective divide</i>),
then returning that vector's new X, Y, and Z.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix to use to transform the vector. This will generally be a projection-view matrix (projection matrix multiplied by the view matrix, in that order), if the vector to transform is in <i>world space</i>, or a model-view-projection matrix, that is, (projection-view matrix multiplied by the model [world] matrix, in that order), if the vector is in <i>model (object) space</i>.<br> If the matrix includes a projection transform returned by MathUtil.mat4ortho, MathUtil.mat4perspective, or similar Math methods, the X, Y, and Z coordinates within the view volume (as is the case in WebGL) will range from -1 to 1 and increase from left to right, front to back, and bottom to top, unless otherwise specified in those methods' documentation.
* `v` (Type: Array.&lt;number> | number)<br>X coordinate of a 3D point to transform. If "vy" and "vz" are omitted, this value can instead be a 3-element array giving the X, Y, and Z coordinates.
* `vy` (Type: number) (optional)<br>Y coordinate.
* `vz` (Type: number) (optional)<br>Z coordinate. To transform a 2D point, set Z to 0.

#### Return Value

The transformed 3-element vector.
The elements, in order, are
the transformed vector's X, Y, and Z coordinates. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4rotate'></a>
### (static) H3DU.MathUtil.mat4rotate(mat, angle, v, vy, vz)

Multiplies a 4x4 matrix by a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>,
and returns a new matrix.
The effect will be that the rotation transformation will
happen before the transformation described in the given matrix,
when applied in the global coordinate frame.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix to multiply.
* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. If "v", "vy", and "vz" are omitted, this can instead be a 4-element array giving the <a href="tutorial-glmath.md">axis of rotation</a> as the first three elements, followed by the angle in degrees as the fourth element.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4rotated'></a>
### (static) H3DU.MathUtil.mat4rotated(angle, v, vy, vz)

Returns a 4x4 matrix representing a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>.

#### Parameters

* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. If "v", "vy", and "vz" are omitted, this can instead be a 4-element array giving the axis of rotation as the first three elements, followed by the angle in degrees as the fourth element.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

#### Examples

The following example rotates a vector,
"vec", about the Z axis by the given angle, "angle".

    var newVector H3DU.MathUtil.mat4projectVec3(
    H3DU.MathUtil.mat4rotated(angle, 0, 0, 1), vec);

<a name='H3DU.MathUtil.mat4scale'></a>
### (static) H3DU.MathUtil.mat4scale(mat, v3, v3y, v3z)

Multiplies a 4x4 matrix by a scaling transformation.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>4x4 matrix to multiply.
* `v3` (Type: Array.&lt;number> | number)<br>Scale factor along the X axis. A scale factor can be negative, in which case the transformation also causes reflection about the corresponding axis. If "v3y" and "v3z" are omitted, this value can instead be a 3-element array giving the scale factors along the X, Y, and Z axes.
* `v3y` (Type: number)<br>Scale factor along the Y axis.
* `v3z` (Type: number)<br>Scale factor along the Z axis.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4scaleInPlace'></a>
### (static) H3DU.MathUtil.mat4scaleInPlace(mat, v3, [v3y], [v3z])

Modifies a 4x4 matrix by multiplying it by a
scaling transformation.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.
* `v3` (Type: Array.&lt;number> | number)<br>Scale factor along the X axis. A scale factor can be negative, in which case the transformation also causes reflection about the corresponding axis. If "v3y" and "v3z" are omitted, this value can instead be a 3-element array giving the scale factors along the X, Y, and Z axes.
* `v3y` (Type: number) (optional)<br>Scale factor along the Y axis.
* `v3z` (Type: number) (optional)<br>Scale factor along the Z axis.

#### Return Value

The same parameter as "mat". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4scaled'></a>
### (static) H3DU.MathUtil.mat4scaled(v3, v3y, v3z)

Returns a 4x4 matrix representing a scaling transformation.

#### Parameters

* `v3` (Type: Array.&lt;number> | number)<br>Scale factor along the X axis. A scale factor can be negative, in which case the transformation also causes reflection about the corresponding axis. If "v3y" and "v3z" are omitted, this value can instead be a 3-element array giving the scale factors along the X, Y, and Z axes.
* `v3y` (Type: number)<br>Scale factor along the Y axis.
* `v3z` (Type: number)<br>Scale factor along the Z axis.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4toFrustumPlanes'></a>
### (static) H3DU.MathUtil.mat4toFrustumPlanes(matrix)

Finds the six clipping planes of a view frustum defined
by a 4x4 matrix. These six planes together form the
shape of a "chopped-off" pyramid (or frustum).

In this model, the eye, or camera, is placed at the top
of the pyramid (before being chopped off), four planes are placed at the pyramid's
sides, one plane (the far plane) forms its base, and a
final plane (the near plane) is the pyramid's chopped
off top.

#### Parameters

* `matrix` (Type: Array.&lt;number>)<br>A 4x4 matrix. This will usually be a projection-view matrix (projection matrix multiplied by view matrix, in that order).

#### Return Value

An array of six
4-element arrays representing the six clipping planes of the
view frustum. In order, they are the left, right, top,
bottom, near, and far clipping planes. All six planes
will be normalized (see MathUtil.planeNormalizeInPlace). (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.MathUtil.mat4toMat3'></a>
### (static) H3DU.MathUtil.mat4toMat3(m4)

Returns the upper-left part of a 4x4 matrix as a new
3x3 matrix.

#### Parameters

* `m4` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The resulting 3x3 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4transform'></a>
### (static) H3DU.MathUtil.mat4transform(mat, v, [vy], [vz], [vw])

Transforms a 4-element vector with a 4x4 matrix and returns
the transformed vector.

Transforming a vector (<code>v</code>) with a matrix (<code>mat</code>)
is effectively done by breaking up <code>mat</code> into four 4-element vectors
(the first 4 elements make up the first vector, and so on), multiplying
each vector in <code>mat</code> by the corresponding component in
<code>v</code>, and adding up the resulting vectors (except <code>v</code>) to
get the transformed vector.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.
* `v` (Type: Array.&lt;number> | number)<br>X coordinate. If "vy", "vz", and "vw" are omitted, this value can instead be a 4-element array giving the X, Y, Z, and W coordinates.
* `vy` (Type: number) (optional)<br>Y coordinate.
* `vz` (Type: number) (optional)<br>Z coordinate.
* `vw` (Type: number) (optional)<br>W coordinate. To transform a 3D point, set W to 1 and divide the result's X, Y, and Z by the result's W. To transform a 2D point, set Z to 0 and W to 1 and divide the result's X and Y by the result's W.

#### Return Value

The transformed vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4transformVec3'></a>
### (static) H3DU.MathUtil.mat4transformVec3(mat, v, [vy], [vz])

Transforms a 3-element vector with a 4x4 matrix as though it were
an affine transformation matrix (without perspective) and returns the transformed vector.
The effect is as though elements
3, 7, 11, and 15 (counting from 0) of the matrix
were assumed to be (0, 0, 0, 1) instead of their actual values and as though the 3-element
vector had a fourth element valued at 1.

For most purposes, use
the MathUtil.mat4projectVec3 method instead, which supports
4x4 matrices that may be in a perspective
projection (whose last row is not necessarily (0, 0, 0, 1)).

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.
* `v` (Type: Array.&lt;number> | number)<br>X coordinate. If "vy" and "vz" are omitted, this value can instead be a 4-element array giving the X, Y, and Z coordinates.
* `vy` (Type: number) (optional)<br>Y coordinate.
* `vz` (Type: number) (optional)<br>Z coordinate. To transform a 2D point, set Z to 0.

#### Return Value

The transformed 3-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4translate'></a>
### (static) H3DU.MathUtil.mat4translate(mat, v3, v3y, v3z)

Multiplies a 4x4 matrix by a translation transformation.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>The matrix to multiply.
* `v3` (Type: Array.&lt;number> | number)<br>Translation along the X axis. If "v3y" and "v3z" are omitted, this value can instead be a 3-element array giving the translations along the X, Y, and Z axes.
* `v3y` (Type: number)<br>Translation along the Y axis.
* `v3z` (Type: number)<br>Translation along the Z axis.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4translated'></a>
### (static) H3DU.MathUtil.mat4translated(v3, v3y, v3z)

Returns a 4x4 matrix representing a translation.

#### Parameters

* `v3` (Type: Array.&lt;number> | number)<br>Translation along the X axis. If "v3y" and "v3z" are omitted, this value can instead be a 3-element array giving the translations along the X, Y, and Z axes.
* `v3y` (Type: number)<br>Translation along the Y axis.
* `v3z` (Type: number)<br>Translation along the Z axis.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4transpose'></a>
### (static) H3DU.MathUtil.mat4transpose(m4)

Returns the transpose of a 4x4 matrix. (A transpose is a
matrix whose rows are converted to columns and vice versa.)

#### Parameters

* `m4` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The resulting 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.mat4transposeInPlace'></a>
### (static) H3DU.MathUtil.mat4transposeInPlace(mat)

Transposes a 4x4 matrix in place without creating
a new matrix. (A transpose is a matrix whose rows
are converted to columns and vice versa.)

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The parameter "mat". (Type: Array.&lt;number>)

<a name='extras_text_H3DU.TextFont_measure'></a>
### module:extras/text~H3DU.TextFont#measure(str, params)

Calculates the width and height of a text string when
drawn using this font.

#### Parameters

* `str` (Type: string)<br>The text string to measure. Line breaks ("\n", "\r", "\r\n") are recognized by this method.
* `params` (Type: Object)<br>An object described in H3DU.TextFont#makeTextMeshes.

#### Return Value

An array of two numbers;
the first is the width of the string, and the second is the
height of the string (taking into account line feed characters,
U+000A, that break lines). (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_merge'></a>
### H3DU.GraphicsPath#merge(path)

Merges the path segments in another path onto this one.

#### Parameters

* `path` (Type: GraphicsPath)<br>Another graphics path. Can be null.

#### Return Value

This object. (Type: GraphicsPath)

<a name='extras_camera_InputTracker_mousePos'></a>
### module:extras/camera~InputTracker#mousePos()

Returns the current mouse position, delta
mouse position, and delta mouse wheel
position (see the "update" method).

#### Return Value

An object containing the following keys:<ul>
<li><code>cx</code> - X coordinate of the current mouse
position.
<li><code>cx</code> - Y coordinate of the current mouse
position.
<li><code>x</code> - X component of the delta mouse position.
<li><code>y</code> - Y component of the delta mouse position.
<li><code>ticks</code> - The delta mouse wheel position.
</ul>
If this object's update method wasn't called, all these values
will be 0. (Type: Object)

<a name='extras_camera_InputTracker_mousewheel'></a>
### module:extras/camera~InputTracker#mousewheel(func)

**Deprecated: Will be removed in the future. Use the
mousePos method to find out whether the user
has rotated the mouse wheel.**

Sets a function to handle mouse wheel events.

#### Parameters

* `func` (Type: function)<br>A function.

#### Return Value

Return value. (Type: Object)

<a name='extras_camera_Camera_moveAngleHorizontal'></a>
### module:extras/camera~Camera#moveAngleHorizontal(angleDegrees)

Moves the camera to the left or right so that it faces
the same reference point at the same distance.

#### Parameters

* `angleDegrees` (Type: number)<br>The angle to rotate the camera, in degrees. If the coordinate-system is right-handed, positive values rotate the camera leftward, and negative values rightward. If the coordinate-system is left-handed, vice versa.

#### Return Value

This object. (Type: Camera)

<a name='extras_camera_Camera_moveAngleVertical'></a>
### module:extras/camera~Camera#moveAngleVertical(angleDegrees)

Moves the camera upward or downward so that it faces
the same reference point at the same distance.

#### Parameters

* `angleDegrees` (Type: number)<br>The angle to rotate the camera, in degrees. If the coordinate-system is right-handed, positive values rotate the camera upward, and negative values downward. If the coordinate-system is left-handed, vice versa.

#### Return Value

This object. (Type: Camera)

<a name='extras_camera_Camera_moveClose'></a>
### module:extras/camera~Camera#moveClose(dist)

Moves the camera the given distance, but not too close
to the reference point.

#### Parameters

* `dist` (Type: number)<br>The distance to move. Positive values mean forward, and negative distances mean back.

#### Return Value

This object. (Type: Camera)

<a name='extras_camera_Camera_moveForward'></a>
### module:extras/camera~Camera#moveForward(dist)

Moves the camera forward the given distance.

#### Parameters

* `dist` (Type: number)<br>The distance to move. Positive values mean forward, and negative distances mean back.

#### Return Value

This object. (Type: Camera)

<a name='extras_camera_Camera_moveHorizontal'></a>
### module:extras/camera~Camera#moveHorizontal(dist)

Moves the camera horizontally relative to the camera's up vector.

#### Parameters

* `dist` (Type: number)<br>Distance to move the camera.

#### Return Value

This object. (Type: Camera)

<a name='H3DU.Transform_movePosition'></a>
### H3DU.Transform#movePosition(x, y, z)

Moves the relative position of an object from its original
position. Has no effect if a matrix was defined with Transform#setMatrix
and the transform wasn't reset yet with Transform#resetTransform.

#### Parameters

* `x` (Type: Array.&lt;number> | number)<br>Number to add to the X coordinate, If "y" and "z" are null or omitted, this is instead a 3-element array giving the numbers to add to the X, Y, and Z coordinates, or a single number to add to all three coordinates.
* `y` (Type: number)<br>Number to add to the Y coordinate. If "x" is an array, this parameter may be omitted.
* `z` (Type: number)<br>Number to add to the Z coordinate. If "x" is an array, this parameter may be omitted.

#### Return Value

This object. (Type: Transform)

<a name='H3DU.GraphicsPath_moveTo'></a>
### H3DU.GraphicsPath#moveTo(x, y)

Moves the current start position and end position to the given position.

#### Parameters

* `x` (Type: number)<br>X coordinate of the position.
* `y` (Type: number)<br>Y coordinate of the position.

#### Return Value

This object. (Type: GraphicsPath)

<a name='extras_camera_Camera_moveVertical'></a>
### module:extras/camera~Camera#moveVertical(dist)

Moves the camera toward or away from the camera's up vector.

#### Parameters

* `dist` (Type: number)<br>Distance to move the camera.

#### Return Value

This object. (Type: Camera)

<a name='extras_matrixstack_MatrixStack_multMatrix'></a>
### module:extras/matrixstack~MatrixStack#multMatrix(mat)

Modifies the matrix at the top of this stack by multiplying it by another matrix.
The matrices are multiplied such that the transformations
they describe happen in reverse order. For example, if the matrix
at the top of the stack describes a translation and the matrix
passed to this method describes a scaling, the multiplied matrix will describe
the effect of scaling then translation.

#### Parameters

* `mat` (Type: Array.&lt;number>)<br>A matrix to multiply the current one by.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.Transform_multQuaternion'></a>
### H3DU.Transform#multQuaternion(quat)

Combines an object's current rotation with another rotation
described by a <a href="tutorial-glmath.md">quaternion</a> (a 4-element array
for describing 3D rotations). The combined rotation will have the
same effect as the new rotation followed by the existing rotation.
Has no effect if a matrix was defined with Transform#setMatrix
and the transform wasn't reset yet with Transform#resetTransform.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A four-element array describing the rotation. A quaternion is returned from the methods MathUtil.quatFromAxisAngle or MathUtil.quatFromTaitBryan.

#### Return Value

This object. (Type: Transform)

#### Examples

    // Combine an object's rotation with a rotation 20 degrees about the X axis
    transform.multQuaternion(MathUtil.quatFromAxisAngle(20,1,0,0));
    // Combine an object's rotation with identity
    transform.multQuaternion(MathUtil.quatIdentity());
    // Combine an object's rotation with 30 degree pitch multiplied
    // by 40 degree roll
    transform.multQuaternion(MathUtil.quatFromTaitBryan(30,0,40));

<a name='H3DU.Transform_multRotation'></a>
### H3DU.Transform#multRotation(angle, v, vy, vz)

Combines an object's current rotation with another rotation
in the form of an angle and an axis of
rotation. The combined rotation will have the
same effect as the new rotation followed by the existing rotation.
Has no effect if a matrix was defined with Transform#setMatrix
and the transform wasn't reset yet with Transform#resetTransform.

#### Parameters

* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. See Transform#setRotation.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation in x, y, and z, respectively.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

This object. (Type: Transform)

<a name='H3DU.newFrames'></a>
### (static) H3DU.newFrames(timer, timeInMs)

Returns the number of frame-length intervals that occurred since
the last known time, where a frame's length is 1/60 of a second.
This method should be called only once each frame.

#### Parameters

* `timer` (Type: Object)<br>An object described in getTimePosition.
* `timeInMs` (Type: number)<br>A time value, in milliseconds. This could be the parameter received in a <code>requestAnimationFrame()</code> callback method. </code>.

#### Return Value

The number of frame-length intervals relative to
the last known time held in the parameter "timer".
The number can include fractional frames. If an
initial time or last known time wasn't set, returns 0. (Type: number)

<a name='extras_polyhedra_Polyhedra.normDistances'></a>
### (static) module:extras/polyhedra~Polyhedra.normDistances(vertices, radius)

Normalizes the distance from the origin to each vertex in the given
array to a fixed radius.

#### Parameters

* `vertices` (Type: Array.&lt;number>)<br>An array of vertices, where each vertex's X, Y, and Z coordinates are stored as three elements of that array.
* `radius` (Type: number)<br>Distance from the origin where each vertex will be normalized to.

#### Return Value

Return value. (Type: Object)

<a name='H3DU.Surface_normal'></a>
### H3DU.Surface#normal(u, v)

Convenience method for finding an approximate normal vector of this surface at the given U and V coordinates.
The <b>normal vector</b> is the same as the gradient vector, but "normalized" to a unit vector.

#### Parameters

* `u` (Type: number)<br>U coordinate of a point on the surface.
* `v` (Type: number)<br>V coordinate of a point on the surface.

#### Return Value

An array describing a normal vector. It should have at least as many
elements as the number of dimensions of the underlying surface. (Type: Array.&lt;number>)

<a name='extras_kernelmatrixshader.normalizeKernelInPlace'></a>
### (static) module:extras/kernelmatrixshader.normalizeKernelInPlace(matrix)

TODO: Not documented yet.

#### Parameters

* `matrix` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.MeshBuffer_normalizeNormals'></a>
### H3DU.MeshBuffer#normalizeNormals()

Modifies this mesh buffer by converting the normals it defines to <a href="tutorial-glmath.md">unit vectors</a>
("normalized" vectors with a length of 1).
Has no effect if this mesh buffer doesn't define any normals.
All attributes with the semantic <code>NORMAL</code>,
regardless of semantic index, are affected.

#### Return Value

This object. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.octahedron'></a>
### (static) module:extras/polyhedra~Polyhedra.octahedron(radius, level)

Generates a mesh of a regular octahedron or a sphere based on that solid.

#### Parameters

* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The generated solid. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.octahedronFaces'></a>
### (static) module:extras/polyhedra~Polyhedra.octahedronFaces()

Gets the vertices of a regular octahedron with radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='extras_matrixstack_MatrixStack_ortho'></a>
### module:extras/matrixstack~MatrixStack#ortho(l, r, b, t, n, f)

Modifies the matrix at the top of this stack by multiplying it by
an orthographic projection.
In this projection, the left clipping plane is parallel to the right clipping
plane and the top to the bottom.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the 3D view.
* `r` (Type: number)<br>Rightmost coordinate of the 3D view. (Note that r can be greater than l or vice versa.)
* `b` (Type: number)<br>Bottommost coordinate of the 3D view.
* `t` (Type: number)<br>Topmost coordinate of the 3D view. (Note that t can be greater than b or vice versa.)
* `n` (Type: number)<br>Distance from the camera to the near clipping plane. A positive value means the plane is in front of the viewer.
* `f` (Type: number)<br>Distance from the camera to the far clipping plane. A positive value means the plane is in front of the viewer.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_matrixstack_MatrixStack_ortho2d'></a>
### module:extras/matrixstack~MatrixStack#ortho2d(l, r, b, t)

Modifies the matrix at the top of this stack by multiplying it by
a 2D orthographic projection.
This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.

#### Parameters

* `l` (Type: number)<br>Leftmost coordinate of the 2D view.
* `r` (Type: number)<br>Rightmost coordinate of the 2D view. (Note that r can be greater than l or vice versa.)
* `b` (Type: number)<br>Bottommost coordinate of the 2D view.
* `t` (Type: number)<br>Topmost coordinate of the 2D view. (Note that t can be greater than b or vice versa.)

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.GraphicsPath_pathLength'></a>
### H3DU.GraphicsPath#pathLength([flatness])

Finds the approximate length of this path.

#### Parameters

* `flatness` (Type: number) (optional)<br>No longer used by this method.

#### Return Value

Approximate length of this path
in units. (Type: number)

<a name='extras_matrixstack_MatrixStack_perspective'></a>
### module:extras/matrixstack~MatrixStack#perspective(fov, aspect, n, f)

Modifies the matrix at the top of this stack by multiplying it by
a matrix that defines a perspective projection.

This method is designed for enabling a <a href="tutorial-glmath.md">right-handed coordinate system</a>.

#### Parameters

* `fov` (Type: number)<br>Vertical field of view, in degrees. Should be less than 180 degrees. (The smaller this number, the bigger close objects appear to be. As a result, zoom can be implemented by multiplying field of view by an additional factor.)
* `aspect` (Type: number)<br>The ratio of width to height of the viewport, usually the scene's aspect ratio.
* `n` (Type: number)<br>The distance from the camera to the near clipping plane. Objects closer than this distance won't be seen. This should be slightly greater than 0.
* `f` (Type: number)<br>The distance from the camera to the far clipping plane. Objects beyond this distance will be too far to be seen.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_matrixstack_MatrixStack_pickMatrix'></a>
### module:extras/matrixstack~MatrixStack#pickMatrix(wx, wy, ww, wh, vp)

Modifies the matrix at the top of this stack by multiplying it by
a matrix that transforms the view to a portion of the viewport.

#### Parameters

* `wx` (Type: number)<br>X coordinate of the center of the desired viewport portion.
* `wy` (Type: number)<br>Y coordinate of the center of the desired viewport portion.
* `ww` (Type: number)<br>Width of the desired viewport portion.
* `wh` (Type: number)<br>Height of the desired viewport portion.
* `vp` (Type: Array.&lt;number>)<br>A 4-element array giving the X and Y coordinates of the lower left corner followed by the width and height of a rectangle indicating the current viewport.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.MathUtil.planeFromNormalAndPoint'></a>
### (static) H3DU.MathUtil.planeFromNormalAndPoint(normal, point)

Creates a plane from a normal vector and a point on the plane.

#### Parameters

* `normal` (Type: Array.&lt;number>)<br>A three-element array identifying the plane's normal vector.
* `point` (Type: Array.&lt;number>)<br>A three-element array identifying a point on the plane.

#### Return Value

A four-element array describing the plane. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.planeNormalize'></a>
### (static) H3DU.MathUtil.planeNormalize(plane)

Normalizes this plane so that its normal is a <a href="tutorial-glmath.md">unit vector</a>,
unless all the normal's components are 0, and returns a new plane with the result.
The plane's distance will be divided by the
normal's length. Returns a new plane.

#### Parameters

* `plane` (Type: Array.&lt;number>)<br>A four-element array defining the plane. The first three elements of the array are the X, Y, and Z components of the plane's normal vector, and the fourth element is the shortest distance from the plane to the origin, or if negative, from the origin to the plane, divided by the normal's length.

#### Return Value

A normalized version of
the plane.
Note that due to rounding error, the length of the plane's normal might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.planeNormalizeInPlace'></a>
### (static) H3DU.MathUtil.planeNormalizeInPlace(plane)

Normalizes this plane so that its normal is a <a href="tutorial-glmath.md">unit vector</a>,
unless all the normal's components are 0, and sets this plane to the result.
The plane's distance will be divided by the
current normal's length.

#### Parameters

* `plane` (Type: Array.&lt;number>)<br>A four-element array defining the plane. The first three elements of the array are the X, Y, and Z components of the plane's normal vector, and the fourth element is the shortest distance from the plane to the origin, or if negative, from the origin to the plane, divided by the normal's length.

#### Return Value

The parameter "plane". (Type: Array.&lt;number>)

<a name='extras_convex.planePointsToConvexHull'></a>
### (static) module:extras/convex.planePointsToConvexHull(planepoints)

Generates a convex hull of the half-space representation
of several planes. Each plane is defined by the triangle it lies on.

#### Parameters

* `planepoints` (Type: Array.&lt;Array.&lt;number>>)<br>An array of planes. Each plane is defined by three points that form a triangle that lies on the plane. The triangle's normal vector will point outward, meaning all points on the side pointed to by the normal vector will be "outside" the plane, and other points will be "inside" the plane.

#### Return Value

The generated convex hull. (Type: MeshBuffer)

<a name='extras_derivedcurves.polarCurve'></a>
### (static) module:extras/derivedcurves.polarCurve(func, phase)

TODO: Not documented yet.

#### Parameters

* `func` (Type: *)
* `phase` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.GraphicsPath_polyline'></a>
### H3DU.GraphicsPath#polyline(pointCoords, closed)

Adds path segments to this path that form a polygon or a connected line segment strand.

#### Parameters

* `pointCoords` (Type: Array.&lt;number>)<br>An array of numbers containing the X and Y coordinates of each point in the sequence of line segments. Each pair of numbers gives the X and Y coordinates, in that order, of one of the points in the sequence. The number of elements in the array must be even. If two or more pairs of numbers are given, line segments will connect each point given (except the last) to the next point given.
* `closed` (Type: number)<br>If "true", the sequence of points describes a closed polygon and a command to close the path will be added to the path (even if only one pair of numbers is given in "pointCoords").

#### Return Value

This object. If "pointCoords" is empty, no path segments will be appended.
Throws an error if "pointCoords" has an odd length. (Type: GraphicsPath)

<a name='extras_matrixstack_MatrixStack_popMatrix'></a>
### module:extras/matrixstack~MatrixStack#popMatrix()

Removes the matrix at the top of this stack, making
the matrix beneath it the new top matrix. Has no
effect if the stack has only one matrix.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.SurfaceBuilder_position'></a>
### H3DU.SurfaceBuilder#position(surface, [size])

Sets the parametric surface used to generate vertex positions.

#### Parameters

* `surface` (Type: Object)<br>A surface evaluator object that describes the parametric surface used to generate position values.
* `size` (Type: number) (optional)<br>The number of elements in each position value. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 3. Throws an error if this value is 0 or less.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='H3DU.SurfaceBuilder_positionNormal'></a>
### H3DU.SurfaceBuilder#positionNormal(surface, [size])

Sets the parametric surface used to generate vertex positions and normals.

#### Parameters

* `surface` (Type: Object)<br>A surface evaluator object that describes the parametric surface used to generate positions.
* `size` (Type: number) (optional)<br>The number of elements in each position and normal. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 3. Throws an error if this value is 0 or less.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='H3DU.SurfaceBuilder_positionNormalTexCoord'></a>
### H3DU.SurfaceBuilder#positionNormalTexCoord(surface, [size])

Sets the parametric surface used to generate vertex positions and normals, and
sets a surface evaluator that generates texture coordinates in the interval [0, 1] along the U and V axes of the surface.

#### Parameters

* `surface` (Type: Object | null)<br>A surface evaluator object that describes the parametric surface used to generate positions. U and V texture coordinates, which will each be in the interval [0, 1] by this method, correspond to U and V coordinates, respectively, for the given surface.
* `size` (Type: number) (optional)<br>The number of elements in each position and normal. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 3. The texture coordinates will be 2-dimensional.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='H3DU.SurfaceBuilder_positionTexCoord'></a>
### H3DU.SurfaceBuilder#positionTexCoord(surface, [size])

Sets the parametric surface used to generate vertex positions, and
sets a surface evaluator that generates texture coordinates in the interval [0, 1] along the U and V axes of the surface.

#### Parameters

* `surface` (Type: Object | null)<br>A surface evaluator object that describes the parametric surface used to generate positions. U and V texture coordinates, which will each be in the interval [0, 1] by this method, correspond to U and V coordinates, respectively, for the given surface.
* `size` (Type: number) (optional)<br>The number of elements in each position. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 3. The texture coordinates will be 2-dimensional. Throws an error if this value is 0 or less.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='H3DU.ShapeGroup_primitiveCount'></a>
### H3DU.ShapeGroup#primitiveCount()

Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this shape group.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MeshBuffer_primitiveType'></a>
### H3DU.MeshBuffer#primitiveType()

Gets the type of primitive stored in this mesh buffer.

#### Return Value

Either MeshBuffer.TRIANGLES,
MeshBuffer.LINES, or MeshBuffer.POINTS. (Type: number)

<a name='extras_matrixstack_MatrixStack_pushMatrix'></a>
### module:extras/matrixstack~MatrixStack#pushMatrix()

Makes a copy of the matrix at the top of this stack
and puts the copy on top of the stack.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.GraphicsPath_quadraticCurveTo'></a>
### H3DU.GraphicsPath#quadraticCurveTo(x, y, x2, y2)

Adds a quadratic B&eacute;zier curve to this path starting
at this path's current position. The current position will be
the curve's first control point.

#### Parameters

* `x` (Type: number)<br>X coordinate of the curve's second control point.
* `y` (Type: number)<br>Y coordinate of the curve's second control point.
* `x2` (Type: number)<br>X coordinate of the curve's end point (third control point).
* `y2` (Type: number)<br>Y coordinate of the curve's end point (third control point).

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.MathUtil.quatConjugate'></a>
### (static) H3DU.MathUtil.quatConjugate(quat)

Returns a quaternion that describes a rotation that undoes the given rotation (an "inverted" rotation); this is done by reversing the sign of the X, Y, and Z components (which describe the quaternion's <a href="tutorial-glmath.md">axis of rotation</a>). The return value won't necessarily be a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatCopy'></a>
### (static) H3DU.MathUtil.quatCopy(a)

Returns a copy of a quaternion.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A quaternion.

#### Return Value

Return value. (Type: Array.&lt;number>)

#### See Also

MathUtil.vec4copy

<a name='H3DU.MathUtil.quatDot'></a>
### (static) H3DU.MathUtil.quatDot(a, b)

Finds the dot product of two quaternions.
It's equal to the sum of the products of
their components (for example, <b>a</b>'s X times <b>b</b>'s X).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first quaternion.
* `b` (Type: Array.&lt;number>)<br>The second quaternion.

#### Return Value

Return value. (Type: number)

#### See Also

MathUtil.vec4dot

<a name='H3DU.MathUtil.quatFromAxisAngle'></a>
### (static) H3DU.MathUtil.quatFromAxisAngle(angle, v, vy, vz)

Generates a quaternion from a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>,

#### Parameters

* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. If "v", "vy", and "vz" are omitted, this can instead be a 4-element array giving the axis of rotation as the first three elements, followed by the angle in degrees as the fourth element.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

The generated quaternion.
A quaternion's first three elements (X, Y, Z) describe an
<a href="tutorial-glmath.md">axis of rotation</a> whose length is the sine of half of "angle",
and its fourth element (W) is the cosine of half of "angle". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatFromMat4'></a>
### (static) H3DU.MathUtil.quatFromMat4(m)

Generates a quaternion from the vector rotation described in a 4x4 matrix.
The upper 3x3 portion of the matrix is used for this calculation.
The results are undefined if the matrix includes any transformation
other than rotation.

#### Parameters

* `m` (Type: Array.&lt;number>)<br>A 4x4 matrix.

#### Return Value

The resulting quaternion. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatFromTaitBryan'></a>
### (static) H3DU.MathUtil.quatFromTaitBryan(pitchDegrees, yawDegrees, rollDegrees, [mode])

Generates a quaternion from pitch, yaw and roll angles (or <i>Tait&ndash;Bryan angles</i>).
See "Axis of Rotation" in "<a href="tutorial-glmath.md">H3DU's Math Functions</a>" for the meaning of each angle.

#### Parameters

* `pitchDegrees` (Type: number)<br>Vector rotation about the X axis (upward or downward turn), in degrees. This can instead be a 3-element array giving the rotation about the X axis, Y axis, and Z axis, respectively.
* `yawDegrees` (Type: number)<br>Vector rotation about the Y axis (left or right turn), in degrees. May be null or omitted if "pitchDegrees" is an array.
* `rollDegrees` (Type: number)<br>Vector rotation about the Z axis (swaying side by side), in degrees. May be null or omitted if "pitchDegrees" is an array.
* `mode` (Type: number) (optional)<br>Specifies the order in which the rotations will occur (in terms of their effect). This is one of the Math constants such as MathUtil.LocalPitchYawRoll and MathUtil.GlobalYawRollPitch. If null, undefined, or omitted, the default is MathUtil.GlobalRollPitchYaw. The constants starting with <code>Global</code> describe a vector rotation in the order given, each about the original axes (these angles are also called <i>extrinsic</i> angles). The constants starting with <code>Local</code> describe a vector rotation in the order given, where the second and third rotations occur around the rotated object's new axes and not necessarily the original axes (these angles are also called <i>intrinsic</i> angles). The order of <code>Local</code> rotations has the same result as the reversed order of <code>Global</code> rotations and vice versa.

#### Return Value

The generated quaternion. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatFromVectors'></a>
### (static) H3DU.MathUtil.quatFromVectors(vec1, vec2)

Generates a quaternion describing a rotation between
two 3-element vectors. The quaternion
will describe the rotation required to rotate
the ray described in the first vector toward the ray described
in the second vector. The vectors need not be <a href="tutorial-glmath.md">unit vectors</a>.

#### Parameters

* `vec1` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `vec2` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The generated quaternion, which
will be a unit vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatIdentity'></a>
### (static) H3DU.MathUtil.quatIdentity()

Returns the identity quaternion of multiplication, (0, 0, 0, 1).

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatInvert'></a>
### (static) H3DU.MathUtil.quatInvert(quat)

Returns a quaternion that describes a rotation that undoes the given rotation (an "inverted" rotation) and is converted to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

Return value. (Type: Array.&lt;number>)

#### See Also

MathUtil.quatConjugate

<a name='H3DU.MathUtil.quatIsIdentity'></a>
### (static) H3DU.MathUtil.quatIsIdentity(quat)

Returns whether this quaternion is the identity quaternion, (0, 0, 0, 1).

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

Return value. (Type: boolean)

<a name='H3DU.MathUtil.quatLength'></a>
### (static) H3DU.MathUtil.quatLength(quat)

Returns the distance of this quaternion from the origin.
It's the same as the square root of the sum of the squares
of its components.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>The quaternion.

#### Return Value

Return value. (Type: number)

#### See Also

MathUtil.vec4length

<a name='H3DU.MathUtil.quatMultiply'></a>
### (static) H3DU.MathUtil.quatMultiply(a, b)

Multiplies two quaternions, creating a composite rotation.
The quaternions are multiplied such that the second quaternion's
rotation happens before the first quaternion's rotation when applied
in the global coordinate frame.

If both quaternions are <a href="tutorial-glmath.md">unit vectors</a>, the resulting
quaternion will also be a unit vector. However, for best results, you should
normalize the quaternions every few multiplications (using
MathUtil.quatNormalize or MathUtil.quatNormalizeInPlace), since successive
multiplications can cause rounding errors.

Quaternion multiplication is not commutative except in the last component
of the resulting quaternion, since the definition of quaternion multiplication
includes taking a cross product of <code>a</code>'s and <code>b</code>'s first three components,
in that order, and the cross product is not commutative (see also MathUtil.vec3cross).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first quaternion.
* `b` (Type: Array.&lt;number>)<br>The second quaternion.

#### Return Value

The resulting quaternion. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatNlerp'></a>
### (static) H3DU.MathUtil.quatNlerp(q1, q2, factor)

Returns a quaternion that lies along the shortest path between the
given two quaternion rotations, using a linear interpolation function, and converts
it to a <a href="tutorial-glmath.md">unit vector</a>.
This is called a normalized linear interpolation, or "nlerp".

Because the shortest path is curved, not straight, this method
will generally not interpolate at constant velocity;
however, the difference in this velocity when interpolating is
rarely noticeable and this method is generally faster than
the MathUtil.quatSlerp method.

#### Parameters

* `q1` (Type: Array.&lt;number>)<br>The first quaternion. Must be a unit vector.
* `q2` (Type: Array.&lt;number>)<br>The second quaternion. Must be a unit vector.
* `factor` (Type: number)<br>A value that usually ranges from 0 through 1. Closer to 0 means closer to q1, and closer to 1 means closer to q2.

#### Return Value

The interpolated quaternion,
which will be a unit vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatNormalize'></a>
### (static) H3DU.MathUtil.quatNormalize(quat)

Converts a quaternion to a <a href="tutorial-glmath.md">unit vector</a>; returns a new quaternion.
When a quaternion is normalized, the distance from the origin
to that quaternion becomes 1 (unless all its components are 0).
A quaternion is normalized by dividing each of its components
by its length.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

The normalized quaternion.
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

#### See Also

MathUtil.vec4normalize

<a name='H3DU.MathUtil.quatNormalizeInPlace'></a>
### (static) H3DU.MathUtil.quatNormalizeInPlace(quat)

Converts a quaternion to a <a href="tutorial-glmath.md">unit vector</a>.
When a quaternion is normalized, it describes the same rotation but the distance from the origin
to that quaternion becomes 1 (unless all its components are 0).
A quaternion is normalized by dividing each of its components
by its length.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

The parameter "quat".
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

#### See Also

MathUtil.vec4normalizeInPlace

<a name='H3DU.MathUtil.quatRotate'></a>
### (static) H3DU.MathUtil.quatRotate(quat, angle, v, vy, vz)

Multiplies a quaternion by a rotation transformation that rotates vectors
by the given rotation angle and around the given <a href="tutorial-glmath.md">axis of rotation</a>.
The result is such that the angle-axis
rotation happens before the quaternion's rotation when applied
in the global coordinate frame.

This method is equivalent to the following (see also MathUtil.quatMultiply):

    return quatMultiply(quat,quatFromAxisAngle(angle,v,vy,vz));

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>Quaternion to rotate.
* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. If "v", "vy", and "vz" are omitted, this can instead be a 4-element array giving the axis of rotation as the first three elements, followed by the angle in degrees as the fourth element.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

The resulting quaternion. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatScale'></a>
### (static) H3DU.MathUtil.quatScale(a, scalar)

Multiplies each element of a quaternion by a factor
and returns the result as a new quaternion.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A quaternion.
* `scalar` (Type: number)<br>A factor to multiply.

#### Return Value

The resulting quaternion. (Type: Array.&lt;number>)

#### See Also

MathUtil.vec4scaleInPlace

<a name='H3DU.MathUtil.quatScaleInPlace'></a>
### (static) H3DU.MathUtil.quatScaleInPlace(a, scalar)

Multiplies each element of a quaternion by a factor
and stores the result in that quaternion.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A quaternion.
* `scalar` (Type: number)<br>A factor to multiply.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

#### See Also

MathUtil.vec4scaleInPlace

<a name='H3DU.MathUtil.quatSlerp'></a>
### (static) H3DU.MathUtil.quatSlerp(q1, q2, factor)

Returns a quaternion that lies along the shortest path between the
given two quaternion rotations, using a spherical interpolation function.
This is called spherical linear interpolation, or "slerp". (A spherical
interpolation finds the shortest angle between the two quaternions -- which
are treated as 4D vectors -- and then finds a vector with a smaller angle
between it and the first quaternion. The "factor" parameter specifies
how small the new angle will be relative to the original angle.)

This method will generally interpolate at constant velocity; however,
this method is not commutative (that is, the order in which the quaternions are given
matters), unlike quatNlerp, making it
unsuitable for blending multiple quaternion rotations,
and this method is generally more computationally expensive
than the quatNlerp method.

#### Parameters

* `q1` (Type: Array.&lt;number>)<br>The first quaternion. Must be a <a href="tutorial-glmath.md">unit vector</a>.
* `q2` (Type: Array.&lt;number>)<br>The second quaternion. Must be a unit vector.
* `factor` (Type: number)<br>A value that usually ranges from 0 through 1. Closer to 0 means closer to q1, and closer to 1 means closer to q2.

#### Return Value

The interpolated quaternion. (Type: Array.&lt;number>)

#### See Also

["Understanding Slerp, Then Not Using It", Jonathan Blow](http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/),
for additional background

<a name='H3DU.MathUtil.quatToAxisAngle'></a>
### (static) H3DU.MathUtil.quatToAxisAngle(a)

Calculates the vector rotation for this quaternion in the form
of the angle to rotate the vector by and an <a href="tutorial-glmath.md">axis of rotation</a> to
rotate that vector around.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A quaternion. Must be a <a href="tutorial-glmath.md">unit vector</a>.

#### Return Value

A 4-element array giving the axis
of rotation as the first three elements, followed by the angle
in degrees as the fourth element. If "a" is a unit vector, the axis
of rotation will be a unit vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatToMat4'></a>
### (static) H3DU.MathUtil.quatToMat4(quat)

Generates a 4x4 matrix describing the rotation
described by this quaternion.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A quaternion, containing four elements.

#### Return Value

The generated 4x4 matrix. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatToTaitBryan'></a>
### (static) H3DU.MathUtil.quatToTaitBryan(a, [mode])

Converts this quaternion to the same version of the rotation
in the form of pitch, yaw, and roll angles (or <i>Tait&ndash;Bryan angles</i>).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A quaternion. Should be a <a href="tutorial-glmath.md">unit vector</a>.
* `mode` (Type: number) (optional)<br>Specifies the order in which the rotations will occur (in terms of their effect, not in terms of how they will be returned by this method). This is one of the Math constants such as MathUtil.LocalPitchYawRoll and MathUtil.GlobalYawRollPitch. If null, undefined, or omitted, the default is MathUtil.GlobalRollPitchYaw. The constants starting with <code>Global</code> describe a vector rotation in the order given, each about the original axes (these angles are also called <i>extrinsic</i> angles). The constants starting with <code>Local</code> describe a vector rotation in the order given, where the second and third rotations occur around the rotated object's new axes and not necessarily the original axes (these angles are also called <i>intrinsic</i> angles). The order of <code>Local</code> rotations has the same result as the reversed order of <code>Global</code> rotations and vice versa.

#### Return Value

A 3-element array containing the
pitch, yaw, and roll angles (X, Y, and Z axis angles), in that order and in degrees, by which to rotate vectors.
See "Axis of Rotation" in "<a href="tutorial-glmath.md">H3DU's Math Functions</a>" for the meaning of each angle. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.quatTransform'></a>
### (static) H3DU.MathUtil.quatTransform(q, v)

Transforms a 3- or 4-element vector using a
quaternion's vector rotation.

#### Parameters

* `q` (Type: Array.&lt;number>)<br>A quaternion describing the rotation.
* `v` (Type: Array.&lt;number>)<br>A 3- or 4-element vector to transform. The fourth element, if any, is ignored.

#### Return Value

A 4-element vector representing
the transformed vector. The fourth element will be 1.0.
If the input vector has 3 elements, a 3-element vector will
be returned instead. (Type: Array.&lt;number>)

<a name='Promise.race'></a>
### (static) Promise.race(all)

Creates a promise that resolves or is rejected when one of those promises
resolves or is rejected.

#### Parameters

* `all` (Type: Array.&lt;<a href="Promise.md">Promise</a>>)<br>An array of promises.

#### Return Value

A promise that resolves or is rejected according to
the first promise that resolves or is rejected. It will receive the
value associated with that promise. (Type: <a href="Promise.md">Promise</a>)

<a name='extras_gradients.radialGradient'></a>
### (static) module:extras/gradients.radialGradient(colorCenter, colorEdges)

Generates a 32x32 bitmap of a radial gradient. This function demonstrates generating a custom texture.

#### Parameters

* `colorCenter` (Type: Array.&lt;number> | number | string)<br>A color vector or string identifying the color at the center of the gradient.
* `colorEdges` (Type: Array.&lt;number> | number | string)<br>A color vector or string identifying the color at the edges of the gradient.

#### Return Value

An array with 32x32x4 bytes, arranged in 32 rows of 32 pixels
of 4 bytes each. For each pixel, the four bytes are color components
in the following order: red, green, blue, alpha. (Type: UInt8Array)

<a name='extras_convex.randomConvexPolyhedron'></a>
### (static) module:extras/convex.randomConvexPolyhedron(avgsize, maxfaces)

Generates a mesh buffer of a convex polyhedron at random.

#### Parameters

* `avgsize` (Type: number)<br>Average size of the polyhedron generated.
* `maxfaces` (Type: number)<br>Maximum number of faces for the convex polyhedron.

#### Return Value

The resulting polyhedron. (Type: MeshBuffer)

<a name='extras_randompolygon.randomPolygon'></a>
### (static) module:extras/randompolygon.randomPolygon(cx, cy, avgRadius, sides, irregular, spiky)

TODO: Not documented yet.

#### Parameters

* `cx` (Type: *)<br>TODO: Not documented yet.
* `cy` (Type: *)<br>TODO: Not documented yet.
* `avgRadius` (Type: *)<br>TODO: Not documented yet.
* `sides` (Type: *)<br>TODO: Not documented yet.
* `irregular` (Type: *)<br>TODO: Not documented yet.
* `spiky` (Type: *)<br>TODO: Not documented yet.

#### Return Value

TODO: Not documented yet. (Type: *)

<a name='extras_raypick.raypick'></a>
### (static) module:extras/raypick.raypick(x, y, projView, viewport, objects)

Finds the three-dimensional shape object and world-space coordinates
corresponding to the given two-dimensional (X and Y) coordinates.

#### Parameters

* `x`<br>Two-dimensional X coordinate in window space (usually lying within the viewport rectangle). See also the first parameter of MathUtil.vec3fromWindowPoint.
* `y`<br>Two-dimensional Y coordinate in window space (usually lying within the viewport rectangle). See also the first parameter of MathUtil.vec3fromWindowPoint.
* `projView`<br>Same meaning as second parameter of MathUtil.vec3fromWindowPoint. For example, to convert to world space coordinates, pass a projection matrix (projection matrix multiplied by the view matrix, in that order) to this parameter.
* `viewport`<br>Same meaning as third parameter of MathUtil.vec3fromWindowPoint.
* `objects`<br>Shape objects from which this method will choose one.

#### Return Value

An object with the following properties:<ul>
<li><code>index</code> - Index, starting from 0, into the objects array
of the shape object that was picked. Is -1 if no object was picked
(and the "local" and "world" properties will be absent).
<li><code>local</code> - 3-element array giving the X, Y, and
Z coordinates of the picked point in object (model) space.
<li><code>world</code> - 3-element array giving the X, Y, and
Z coordinates of the picked point in world space.</ul>

#### Examples

The following example shows how a hypothetical scene graph could implement picking objects based on the position of the mouse cursor.

    var mousePos = scene.getMousePosInPixels();
    var viewport = [0, 0, scene.getWidth(), scene.getHeight()];
    var projview = scene.getProjectionViewMatrix();
    var o = raypick(mousePos.cx, mousePos.cy, projview, viewport, objects);
    if(o.index >= 0) {
    pickedShape = objects[o.index];
    } else {
    pickedShape = null;
    }

<a name='H3DU.MeshBuffer_recalcNormals'></a>
### H3DU.MeshBuffer#recalcNormals([flat], [inward])

Recalculates the normal vectors for triangles
in this mesh. For this to properly affect shading, each triangle in
the mesh must have its vertices defined in
counterclockwise order (if the triangle is being rendered
in a right-handed coordinate system). Each normal calculated will
be normalized to have a length of 1 (unless the normal is (0,0,0)),
and will be stored in an attribute with semantic <code>NORMAL_0</code>.
Will have an effect only if the buffer includes an attribute with
semantic <code>POSITION_0</code> and each of that attribute's values is at least 3 elements
long. If the buffer already includes an attribute with semantic <code>NORMAL_0</code>,
ensures its values are each at least 3 elements long.

#### Parameters

* `flat` (Type: boolean) (optional)<br>If true, each triangle in the mesh will have the same normal, which usually leads to a flat appearance. If false, each unique vertex in the mesh will have its own normal, which usually leads to a smooth appearance. If null, undefined, or omitted, the default is false.
* `inward` (Type: boolean) (optional)<br>If true, the generated normals will point inward; otherwise, outward. If null, undefined, or omitted, the default is false.

#### Return Value

This object. (Type: MeshBuffer)

<a name='H3DU.GraphicsPath_rect'></a>
### H3DU.GraphicsPath#rect(x, y, w, h)

Adds path segments to this path that form an axis-aligned rectangle.

#### Parameters

* `x` (Type: number)<br>X coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `y` (Type: number)<br>Y coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `w` (Type: number)<br>Width of the rectangle.
* `h` (Type: number)<br>Height of the rectangle.

#### Return Value

This object. If "w" or "h" is 0, no path segments will be appended. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_regularPolygon'></a>
### H3DU.GraphicsPath#regularPolygon(cx, cy, sides, radius, [phaseInDegrees])

Adds path segments to this path that form a regular polygon.

#### Parameters

* `cx` (Type: number)<br>X coordinate of the center of the polygon.
* `cy` (Type: number)<br>Y coordinate of the center of the polygon.
* `sides` (Type: number)<br>Number of sides the polygon has. Nothing will be added to the path if this value is 2 or less.
* `radius` (Type: number)<br>Radius from the center to each vertex of the polygon.
* `phaseInDegrees` (Type: number) (optional)<br>Starting angle of the first vertex of the polygon, in degrees. 0 means the positive X axis, 90 means the positive Y axis, 180 means the negative X axis, and 270 means the negative Y axis. If null, undefined, or omitted, the default is 0.

#### Return Value

This object. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_regularStar'></a>
### H3DU.GraphicsPath#regularStar(cx, cy, points, radiusOut, radiusIn, phaseInDegrees)

Adds path segments to this path that form a regular N-pointed star.

#### Parameters

* `cx` (Type: number)<br>X coordinate of the center of the star.
* `cy` (Type: number)<br>Y coordinate of the center of the star.
* `points` (Type: number)<br>Number of points the star has. Nothing will be added to the path if this value is 0 or less.
* `radiusOut` (Type: number)<br>Radius from the center to each outer vertex of the star.
* `radiusIn` (Type: number)<br>Radius from the center to each inner vertex of the star.
* `phaseInDegrees` (Type: number)<br>Starting angle of the first vertex of the polygon, in degrees. 0 means the positive X axis, 90 means the positive Y axis, 180 means the negative X axis, and 270 means the negative Y axis.

#### Return Value

This object. (Type: GraphicsPath)

<a name='Promise.reject'></a>
### (static) Promise.reject(reason)

Returns a promise that is rejected.

#### Parameters

* `reason` (Type: Object)<br>The value associated with the promise.

#### Return Value

A promise that is rejected and takes the given value
as its argument. (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.ShapeGroup_removeShape'></a>
### H3DU.ShapeGroup#removeShape(shape)

Removes all instances of a 3D shape from this shape group

#### Parameters

* `shape` (Type: Shape | ShapeGroup)<br>The 3D shape to remove.

#### Return Value

This object. (Type: ShapeGroup)

<a name='H3DU.Transform_reset'></a>
### H3DU.Transform#reset()

Resets this transform to the untransformed state.

#### Return Value

This object. (Type: Transform)

<a name='Promise.resolve'></a>
### (static) Promise.resolve(value)

Returns a promise that resolves.

#### Parameters

* `value` (Type: Object)<br>The value associated with the promise.

#### Return Value

A promise that resolves and takes the given value
as its argument. (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.GraphicsPath_reverse'></a>
### H3DU.GraphicsPath#reverse()

Returns a path that reverses the course of this path.

#### Return Value

A GraphicsPath
object with its path segments reversed. (Type: GraphicsPath)

<a name='H3DU.MeshBuffer_reverseNormals'></a>
### H3DU.MeshBuffer#reverseNormals()

Modifies this mesh buffer by reversing the sign of normals it defines.
Has no effect if this mesh buffer doesn't define any normals.
All attributes with the semantic <code>NORMAL</code>,
regardless of semantic index, are affected.

#### Return Value

This object. (Type: MeshBuffer)

#### Examples

The following code generates a two-sided mesh, where
the normals on each side face in the opposite direction.
This is only useful when drawing open geometric shapes, such as open
cylinders and two-dimensional planar shapes.
Due to the z-fighting effect, drawing a two-sided mesh is
recommended only if face culling is enabled.

    var twoSidedMesh = originalMesh.merge(
    new MeshBuffer().merge(originalMesh)
    .reverseWinding().reverseNormals()
    );

<a name='H3DU.MeshBuffer_reverseWinding'></a>
### H3DU.MeshBuffer#reverseWinding()

Reverses the winding order of the triangles in this mesh buffer
by swapping the second and third vertex indices of each one.
Has an effect only if this mesh buffer consists of triangles.

#### Return Value

This object. (Type: MeshBuffer)

#### Examples

The following code generates a mesh that survives face culling,
since the same triangles occur on each side of the mesh, but
with different winding orders.
This is only useful when drawing open geometric shapes, such as open
cylinders and two-dimensional planar shapes.
Due to the z-fighting effect, drawing this kind of mesh is
recommended only if face culling is enabled.

    var frontBackMesh = originalMesh.merge(
    new MeshBuffer().merge(originalMesh).reverseWinding()
    );

<a name='extras_evaluators_Hypotrochoid.rose'></a>
### (static) module:extras/evaluators~Hypotrochoid.rose(n, distFromInnerCenter, [rotationDegrees])

Creates a curve evaluator object for a rose, a special
form of hypotrochoid.

#### Parameters

* `n` (Type: number)<br>Parameter that determines the petal form of the rose. For example, the rose is symmetrical if this number is even.
* `distFromInnerCenter` (Type: number)<br>Distance from the center of the rolling circle to the drawing pen.
* `rotationDegrees` (Type: number) (optional)<br>Starting angle of the curve from the positive X axis toward the positive Y axis, in degrees. Default is 0.

#### Return Value

The resulting curve evaluator object. (Type: Hypotrochoid)

<a name='extras_matrixstack_MatrixStack_rotate'></a>
### module:extras/matrixstack~MatrixStack#rotate(angle, x, y, z)

Modifies the matrix at the top of this stack by multiplying it by a rotation transformation.

#### Parameters

* `angle` (Type: number)<br>The desired angle to rotate in degrees. If the axis of rotation points toward the viewer, the angle's value is increasing in a counterclockwise direction.
* `x` (Type: number)<br>X-component of the axis of rotation.
* `y` (Type: number)<br>Y-component of the axis of rotation.
* `z` (Type: number)<br>Z-component of the axis of rotation.

#### Return Value

This object. (Type: MatrixStack)

<a name='H3DU.GraphicsPath_roundRect'></a>
### H3DU.GraphicsPath#roundRect(x, y, w, h, arccx, arccy)

Adds path segments to this path that form an axis-aligned rounded rectangle.

#### Parameters

* `x` (Type: number)<br>X coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `y` (Type: number)<br>Y coordinate of the rectangle's upper-left corner (assuming the coordinate system's X axis points right and the Y axis down).
* `w` (Type: number)<br>Width of the rectangle.
* `h` (Type: number)<br>Height of the rectangle.
* `arccx` (Type: number)<br>Horizontal extent (from end to end) of the ellipse formed by each arc that makes up the rectangle's corners. Will be adjusted to be not less than 0 and not greater than "w".
* `arccy` (Type: number)<br>Vertical extent (from end to end) of the ellipse formed by each arc that makes up the rectangle's corners. Will be adjusted to be not less than 0 and not greater than "h".

#### Return Value

This object. If "w" or "h" is less than 0, no path segments will be appended. (Type: GraphicsPath)

<a name='extras_derivedcurves.ruledSurface'></a>
### (static) module:extras/derivedcurves.ruledSurface(directrix, director)

TODO: Not documented yet.

#### Parameters

* `directrix` (Type: *)
* `director` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='extras_matrixstack_MatrixStack_scale'></a>
### module:extras/matrixstack~MatrixStack#scale(x, y, z)

Modifies the matrix at the top of this stack by multiplying it by a
scaling transformation.

#### Parameters

* `x` (Type: number)<br>Scale factor along the X axis.
* `y` (Type: number)<br>Scale factor along the Y axis.
* `z` (Type: number)<br>Scale factor along the Z axis.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_evaluators_Epitrochoid_scaleTo'></a>
### module:extras/evaluators~Epitrochoid#scaleTo(radius)

Creates a modified version of this curve so that it
fits the given radius.

#### Parameters

* `radius` (Type: number)<br>Desired radius of the curve.

#### Return Value

Return value. (Type: Epitrochoid)

<a name='H3DU.BufferAccessor_set'></a>
### H3DU.BufferAccessor#set(index, value)

Sets the first element of the attribute value with the given vertex index.

Note that currently, this method does no bounds checking beyond the
checking naturally done when writing to the attribute's buffer.

#### Parameters

* `index` (Type: number)<br>A numeric index, starting from 0, that identifies a value stored in the attribute's buffer. For example, 0 identifies the first value, 1 identifies the second, and so on.
* `value` (Type: number)<br>The number to set the first element to.

#### Return Value

This object. (Type: BufferAccessor)

<a name='H3DU.MeshBuffer_setAttribute'></a>
### H3DU.MeshBuffer#setAttribute(name, buffer, countPerValue, [offset], [stride])

Adds information about a buffer attribute to this
mesh buffer (or sets an
existing attribute's information). An attribute
gives information about the per-vertex data used and
stored in a vertex buffer.

#### Parameters

* `name` (Type: number | string)<br>An attribute semantic, such as <a href="Semantic.md#Semantic.POSITION">Semantic.POSITION</a>, "POSITION", or "TEXCOORD_0". Throws an error if this value is a string and the string is invalid. If this isn't a string, the set index of the attribute will be 0 (see MeshBuffer#setAttributeEx).
* `buffer` (Type: Float32Array | Array)<br>The buffer where the per-vertex data is stored. See MeshBuffer#setAttributeEx.
* `countPerValue` (Type: number)<br>The number of elements in each per-vertex item. See MeshBuffer#setAttributeEx.
* `offset` (Type: number) (optional)<br>The index into the array (starting from 0) where the first per-vertex item starts.See MeshBuffer#setAttributeEx.
* `stride` (Type: number) (optional)<br>The number of elements from the start of one per-vertex item to the start of the next. See MeshBuffer#setAttributeEx.

#### Return Value

This object. Throws an error if the given
semantic is unsupported. (Type: MeshBuffer)

<a name='H3DU.MeshBuffer_setAttributeEx'></a>
### H3DU.MeshBuffer#setAttributeEx(name, index, buffer, [countPerValue], [offset], [stride])

Adds information about a buffer attribute to this
mesh buffer (or sets an
existing attribute's information), taking a semantic index as
an additional parameter. An attribute
gives information about the per-vertex data used and
stored in a vertex buffer.

#### Parameters

* `name` (Type: number | string)<br>An attribute semantic, such as <a href="Semantic.md#Semantic.POSITION">Semantic.POSITION</a>, "POSITION", or "TEXCOORD_0". Throws an error if this value is a string and the string is invalid.
* `index` (Type: number)<br>The semantic index of the attribute for the given semantic. 0 is the first index of the attribute, 1 is the second, and so on. This is ignored if "name" is a string.
* `buffer` (Type: Float32Array | Array | BufferAccessor)<br>The buffer where the per-vertex data is stored. If this parameter is an (untyped) Array, converts that parameter to a Float32Array.
* `countPerValue` (Type: number) (optional)<br>The number of elements in each per-vertex item. For example, if each vertex is a 3-element vector, this value is 3. Throws an error if this value is 0 or less. If "buffer" is a BufferAccessor, the value of "countPerValue" is taken from that accessor and this parameter is ignored; this parameter is currently required otherwise.
* `offset` (Type: number) (optional)<br>The index into the array (starting from 0) where the first per-vertex item starts. If null, undefined, or omitted, the default is 0. Throws an error if less than 0. If "buffer" is a BufferAccessor, the value of "offset" is taken from that accessor and this parameter is ignored.
* `stride` (Type: number) (optional)<br>The number of elements from the start of one per-vertex item to the start of the next. If null, undefined, or omitted, this value is the same as "countPerValue". Throws an error if this value is 0 or less. If "buffer" is a BufferAccessor, the value of "stride" is taken from that accessor and this parameter is ignored.

#### Return Value

This object.Throws an error if the given
semantic is unsupported. (Type: MeshBuffer)

<a name='extras_drawingtoy_DrawingToy_setColor'></a>
### module:extras/drawingtoy~DrawingToy#setColor(color)

Sets the color to apply when drawing future curves with this object.

#### Parameters

* `color` (Type: Array.&lt;number> | number | string)<br>A color vector or string identifying the color to apply.

#### Return Value

This object. (Type: DrawingToy)

<a name='extras_camera_Camera_setDistance'></a>
### module:extras/camera~Camera#setDistance(dist)

Moves the camera a given distance from the reference
point without changing its orientation.

#### Parameters

* `dist` (Type: number)<br>Positive number giving the distance. If this is less than the near plane distance, the distance will be equal to the near plane distance. Does nothing if the distance is 0 or less.

#### Return Value

This object. (Type: Camera)

<a name='H3DU.MeshBuffer_setIndices'></a>
### H3DU.MeshBuffer#setIndices([indices])

Sets the vertex indices used by this mesh buffer.

#### Parameters

* `indices` (Type: Array.&lt;number> | Uint16Array | Uint32Array | Uint8Array | null) (optional)<br>Array of vertex indices that the mesh buffer will use. Can be null, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.

#### Return Value

This object. (Type: MeshBuffer)

<a name='H3DU.Transform_setMatrix'></a>
### H3DU.Transform#setMatrix(value)

Sets this transform's transformation matrix. This method
will set the position, rotation, and scale properties
accordingly to the matrix given.

#### Parameters

* `value` (Type: Array.&lt;number>)<br>A 4x4 matrix. This method will copy the value of this parameter.

#### Return Value

This object. (Type: Transform)

<a name='extras_camera_Camera_setPosition'></a>
### module:extras/camera~Camera#setPosition(cx, [cy], [cz])

Sets the position of the camera.

#### Parameters

* `cx` (Type: number)<br>The camera's new X coordinate, or a 3-element vector containing the X, Y, and Z coordinates. In the latter case, "cy" and "cz" can be omitted.
* `cy` (Type: number) (optional)<br>The camera's new Y coordinate.
* `cz` (Type: number) (optional)<br>The camera's new Z coordinate.

#### Return Value

This object. (Type: Camera)

<a name='H3DU.MeshBuffer_setPrimitiveType'></a>
### H3DU.MeshBuffer#setPrimitiveType(primType)

Sets the type of graphics primitives stored in this mesh buffer.

#### Parameters

* `primType` (Type: number)<br>The primitive type, either MeshBuffer.TRIANGLES, MeshBuffer.LINES, or MeshBuffer.POINTS. For TRIANGLES, every three vertices or vertex indices identify a single triangle. For LINES, every two vertices or vertex indices identify a single line segment. For POINTS, every vertex or vertex index identifies a single point.

#### Return Value

This object. (Type: MeshBuffer)

<a name='H3DU.ShapeGroup_setQuaternion'></a>
### H3DU.ShapeGroup#setQuaternion(quat)

Sets this shape group's rotation in the form of a <a href="tutorial-glmath.md">quaternion</a>.
See Transform#setQuaternion.
This method will modify this shape group's transform
rather than the transform for each shape in the group.

#### Parameters

* `quat` (Type: Array.&lt;number>)<br>A four-element array describing the rotation.

#### Return Value

This object. (Type: ShapeGroup)

<a name='H3DU.Transform_setRotation'></a>
### H3DU.Transform#setRotation(angle, v, vy, vz)

Sets this transform's rotation in the form of an angle and an axis of
rotation. Has no effect if a matrix was defined with Transform#setMatrix
and the transform wasn't reset yet with Transform#resetTransform.

#### Parameters

* `angle` (Type: Array.&lt;number> | number)<br>The desired angle to rotate in degrees. If "v", "vy", and "vz" are omitted, this can instead be a 4-element array giving the axis of rotation as the first three elements, followed by the angle in degrees as the fourth element. If the axis of rotation points toward the viewer, a positive value means the angle runs in a counterclockwise direction for right-handed coordinate systems and in a clockwise direction for left-handed systems.
* `v` (Type: Array.&lt;number> | number)<br>X-component of the point lying on the axis of rotation. If "vy" and "vz" are omitted, this can instead be a 3-element array giving the axis of rotation in x, y, and z, respectively.
* `vy` (Type: number)<br>Y-component of the point lying on the axis of rotation.
* `vz` (Type: number)<br>Z-component of the point lying on the axis of rotation.

#### Return Value

This object. (Type: Transform)

<a name='H3DU.ShapeGroup_setScale'></a>
### H3DU.ShapeGroup#setScale(x, y, z)

Sets the scale of this shape group relative to its original
size. See Transform#setScale.
This method will modify this shape group's transform
rather than the transform for each shape in the group.

#### Parameters

* `x` (Type: number | Array.&lt;number>)<br>Scaling factor for this object's width, or a 3-element scaling array, as specified in Transform#setScale.
* `y` (Type: number)<br>Scaling factor for this object's height.
* `z` (Type: number)<br>Scaling factor for this object's depth.

#### Return Value

This object. (Type: ShapeGroup)

<a name='H3DU.ShapeGroup_setShape'></a>
### H3DU.ShapeGroup#setShape(index, shape)

Sets a shape or shape group at the given index in this shape group.

#### Parameters

* `index` (Type: number)<br>Integer index, starting from 0, to set the shape or shape group at.
* `shape` (Type: Shape | ShapeGroup)<br>Shape object to set at the given index.

#### Return Value

This object. (Type: ShapeGroup)

<a name='H3DU.ShapeGroup_setTransform'></a>
### H3DU.ShapeGroup#setTransform(transform)

Sets the transform used by this shape group to a copy
of the given transform. Child
shapes can set their own transforms, in which case the
rendering process will multiply this shape group's transform
with the child shape's transform as it renders the child shape.

#### Parameters

* `transform` (Type: Transform)<br>The transform to copy for the use of this shape group.

#### Return Value

Return value. (Type: Object)

<a name='H3DU.BufferAccessor_setVec'></a>
### H3DU.BufferAccessor#setVec(index, vec)

Sets the elements of a vertex attribute value.

Note that currently, this method does no bounds checking beyond the
checking naturally done when writing to the attribute's buffer, except
where noted otherwise.

#### Parameters

* `index` (Type: number)<br>A numeric index, starting from 0, that identifies a value stored in the attribute's buffer. For example, 0 identifies the first value, 1 identifies the second, and so on.
* `vec` (Type: Array.&lt;number>)<br>An array containing the elements to copy to the value at the given index. The number of elements copied is this array's length or the attribute's count per value (see BufferAccessor#countPerValue), whichever is less.

#### Return Value

This object. (Type: BufferAccessor)

<a name='H3DU.ShapeGroup_setVisible'></a>
### H3DU.ShapeGroup#setVisible(value)

Sets whether this shape group will be drawn on rendering.

#### Parameters

* `value` (Type: boolean)<br>True if this shape group will be visible; otherwise, false.

#### Return Value

This object. (Type: ShapeGroup)

<a name='H3DU.ShapeGroup_shapeCount'></a>
### H3DU.ShapeGroup#shapeCount()

Returns the number of shapes and/or shape groups that
are direct children of this shape group.

#### Return Value

Return value. (Type: number)

<a name='extras_torusknot_TorusKnot.simple'></a>
### (static) module:extras/torusknot~TorusKnot.simple(p, q, r1)

Generates a torus knot with simple parameters.

#### Parameters

* `p` (Type: number)<br>Integer greater than 0 giving the number of revolutions.
* `q` (Type: number)<br>Integer greater than 0 giving the number of loop crossings.
* `r1` (Type: *)

#### Return Value

The resulting torus knot evaluator. (Type: TorusKnot)

<a name='extras_derivedcurves.spiralCurve'></a>
### (static) module:extras/derivedcurves.spiralCurve(radius, phase)

TODO: Not documented yet.

#### Parameters

* `radius` (Type: *)
* `phase` (Type: *)

#### Return Value

Return value. (Type: *)

<a name='H3DU.BSplineCurve_split'></a>
### H3DU.BSplineCurve#split(u)

Splits this B-spline curve into two at the given point.

#### Parameters

* `u` (Type: number)<br>Point on the curve where this curve will be split.

#### Return Value

An array containing two B-spline curves: the
first is the part of the curve before the given point, and the second
is the part of the curve after the given point. The first element
will be null if <code>u</code> is at or before the start of the curve.
The second element
will be null if <code>u</code> is at or after the end of the curve. (Type: Array.&lt;BSplineCurve>)

<a name='H3DU.SurfaceBuilder.surfaceToBuffer'></a>
### (static) H3DU.SurfaceBuilder.surfaceToBuffer(surface, [mode], [un], [vn], [u1], [u2], [v1], [v2])

Convenience method for creating a mesh buffer from a parametric
surface. The mesh buffer will contain positions, vertex normals, and
texture coordinates that cover the given surface.

#### Parameters

* `surface` (Type: Object)<br>A surface evaluator object that describes the parametric surface used to generate positions. U and V texture coordinates, which will each be in the interval [0, 1] by this method, correspond to U and V coordinates, respectively, for the given surface.
* `mode` (Type: number) (optional)<br>If this value is MeshBuffer.TRIANGLES, or is null, undefined, or omitted, generates a series of triangles defining the surface. If this value is MeshBuffer.LINES, generates a series of lines defining the surface. If this value is MeshBuffer.POINTS, generates a series of points along the surface. For any other value, this method has no effect.
* `un` (Type: number) (optional)<br>Number of subdivisions along the U axis. Default is 24.
* `vn` (Type: number) (optional)<br>Number of subdivisions along the V axis. Default is 24.
* `u1` (Type: number) (optional)<br>Starting U coordinate of the surface to evaluate. Default is the starting U coordinate given by the surface evaluator object, or 0 if not given.
* `u2` (Type: number) (optional)<br>Ending U coordinate of the surface to evaluate. Default is the ending U coordinate given by the surface evaluator object, or 1 if not given.
* `v1` (Type: number) (optional)<br>Starting V coordinate of the surface to evaluate. Default is the starting V coordinate given by the surface evaluator object, or 0 if not given.
* `v2` (Type: number) (optional)<br>Ending V coordinate of the surface to evaluate. Default is the ending V coordinate given by the surface evaluator object, or 1 if not given.

#### Return Value

The generated mesh buffer. (Type: MeshBuffer)

<a name='H3DU.BSplineSurface_tangent'></a>
### H3DU.BSplineSurface#tangent(u, v)

Finds the tangent vector at the
given point on the surface.

#### Parameters

* `u` (Type: number)<br>U coordinate of the surface to evaluate.
* `v` (Type: number)<br>V coordinate of the surface to evaluate.

#### Return Value

An array giving the tangent vector.
It will have as many elements as a control point (or one fewer
if DIVIDE_BIT is set), as specified in the constructor. (Type: Array.&lt;number>)

<a name='extras_polyhedra_Polyhedra.tetrahedron'></a>
### (static) module:extras/polyhedra~Polyhedra.tetrahedron(radius, level)

Generates a mesh of a regular tetrahedron or a sphere based on that solid.

#### Parameters

* `radius` (Type: number)<br>Maximum radius from the center of the solid to one of its vertices.
* `level` (Type: number)<br>If 0 or less, generates the solid as is. If 1 or greater, subdivides each triangle on the solid's surface into smaller triangles and makes them bulge out to form an approximation of a sphere (the bigger the number, the smaller the triangles).

#### Return Value

The generated solid. (Type: MeshBuffer)

<a name='extras_polyhedra_Polyhedra.tetrahedronFaces'></a>
### (static) module:extras/polyhedra~Polyhedra.tetrahedronFaces()

Gets the vertices of a tetrahedron with radius 1.

#### Return Value

A two-element array. The first
element contains an array of the vertices that make up the solid (each
vertex's X, Y, and Z coordinates are stored as three elements of that array),
and the second element contains an array of vertex indices (multiplying
each element by 3 will get the index to the first coordinate of the corresponding
vertex in the first array). (Type: Array.&lt;Array.&lt;number>>)

<a name='H3DU.SurfaceBuilder_texCoord'></a>
### H3DU.SurfaceBuilder#texCoord(surface, [size])

Sets the parametric surface used to generate texture coordinates.

#### Parameters

* `surface` (Type: Object)<br>A surface evaluator object that describes the parametric surface used to generate texture coordinates. U and V coordinates for the given surface correspond to U and V coordinates, respectively, for the surface used to generate vertex positions.
* `size` (Type: number) (optional)<br>The number of elements in each value of the attribute. For example, if the attribute is 3-dimensional, this parameter is 3. If null, undefined, or omitted, the default is 2.

#### Return Value

This object. (Type: SurfaceBuilder)

<a name='extras_text_H3DU.TextFont_textShape'></a>
### module:extras/text~H3DU.TextFont#textShape(str, params)

Creates a group of shapes containing the primitives needed to
draw text in the given position, size, and color.
For the text to show upright, the coordinate system should have the
X axis pointing right and the Y axis pointing down (for example, an
orthographic projection where the left and top coordinates are less
than the right and bottom coordinates, respectively).

#### Parameters

* `str` (Type: string)<br>The text to draw. Line breaks ("\n", "\r", "\r\n") are recognized by this method.
* `params` (Type: Object)<br>An object described in H3DU.TextFont#makeTextMeshes. Can also contain the following keys:<ul> <li><code>color</code> - A color vector or string giving the color to draw the text with. If this value is given, the bitmap font is assumed to be a signed distance field font. <li><code>msdf</code> - Treat the bitmap font as a multichannel signed distance field font. <li><code>texture</code> - An array of textures (H3DU.Texture) to use with this font, or a single H3DU.Texture if only one texture page is used. If null, undefined, or omitted, uses the default filenames for texture pages defined in this font. </ul>

#### Return Value

The generated group of shapes. (Type: <a href="H3DU.ShapeGroup.md">H3DU.ShapeGroup</a>)

<a name='Promise_Promise$1_then'></a>
### Promise#Promise$1#then(onFulfilled, [onRejected])

Creates a promise that calls a function depending on whether
this promise resolves or is rejected.

#### Parameters

* `onFulfilled` (Type: function)<br>To be called once this promise gets fulfilled
* `onRejected` (Type: function) (optional)<br>To be called once this promise gets rejected

#### Return Value

A promise. (Type: <a href="Promise.md">Promise</a>)

<a name='H3DU.Curve_toArcLengthParam'></a>
### H3DU.Curve#toArcLengthParam()

Gets a curve evaluator object for a curve that follows the same
path as this one but has its U coordinates remapped to
an <i>arc length parameterization</i>. Arc length
parameterization allows for moving along a curve's path at a uniform
speed and for generating points which are spaced evenly along that
path -- both features are more difficult with most other kinds
of curve parameterization.

The <i>end points</i> of the curve (obtained by calling the <code>endPoints</code>
method) will be (0, N), where N is the distance to the end of the curve from its
start.

When converting to an arc length parameterization, the curve
should be continuous and have a speed greater than 0 at every
point on the curve. The arc length parameterization used in
this method is approximate.

#### Return Value

Return value. Returns this object if this curve already uses an arc length parameterization. (Type: Curve)

<a name='H3DU.GraphicsPath_toCurvePath'></a>
### H3DU.GraphicsPath#toCurvePath()

Creates a path in which arcs are decomposed
to cubic B&eacute;zier curves (which will approximate those arcs).

#### Return Value

A path consisting only of line
segments, B&eacute;zier curves, and close commands. (Type: GraphicsPath)

<a name='H3DU.GraphicsPath_toExtrudedMeshBuffer'></a>
### H3DU.GraphicsPath#toExtrudedMeshBuffer(zStart, zEnd, [flatness])

Generates a mesh buffer consisting of "walls" that follow this graphics path approximately.

#### Parameters

* `zStart` (Type: number)<br>Starting Z coordinate of the mesh buffer's "walls".
* `zEnd` (Type: number)<br>Ending Z coordinate of the mesh buffer's "walls".
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

The resulting mesh buffer. (Type: MeshBuffer)

<a name='H3DU.toGLColor'></a>
### (static) H3DU.toGLColor(r, [g], [b], [a])

Creates a 4-element array representing a color. Each element
can range from 0 to 1 and specifies the red, green, blue or alpha
component, respectively.
This method also converts HTML and CSS colors to 4-element RGB
colors. The following lists the kinds of colors accepted:
<ul>
<li>HTML colors with the syntax <code>#RRGGBB</code> or <code>#RRGGBBAA</code>, where
RR is the hexadecimal form of the red component (00-FF), GG
is the hexadecimal green component, BB is the hexadecimal
blue component, and AA is the hexadecimal alpha component. Example: #88DFE0.
<li>HTML colors with the syntax <code>#RGB</code> or <code>#RGBA</code>, where
R is the hexadecimal form of the red component (0-F), G
is the hexadecimal green component, B is the hexadecimal
blue component, and A is the hexadecimal alpha component. Example: #8DE.
<li>CSS colors with the syntax <code>rgb(red, green, blue)</code> or
<code>rgba(red, green, blue, alpha)</code> where
<code>red</code>, <code>green</code>, and <code>blue</code>
are the red, green, and blue components, respectively, either as a
number (0-255) or as a percent, and <code>alpha</code> is
a number from 0-1 specifying the alpha component.
Examples: <code>rgb(255,0,0)</code>,
<code>rgb(100%,50%,0%)</code>, <code>rgba(20,255,255,0.5)</code>.
<li>CSS colors with the syntax <code>hsl(hue, sat, light)</code> or
<code>hsla(hue, sat, light, alpha)</code> where
<code>hue</code> is the hue component in degrees (0-360),
<code>sat</code> and <code>light</code>
are the saturation and lightness components, respectively, as percents,
and <code>alpha</code> is
a number from 0-1 specifying the alpha component.
Examples: <code>rgb(255,0,0)</code>,
<code>hsl(200,50%,50%)</code>, <code>hsla(20,80%,90%,0.5)</code>.
<li>CSS colors such as <code>red</code>, <code>green</code>,
<code>white</code>, <code>lemonchiffon</code>, <code>chocolate</code>,
and so on, including the newly added <code>rebeccapurple</code>.
<li>The value <code>transparent</code>, meaning transparent black.
</ul>
For more information, see the "<a href="tutorial-colors.md">Color Strings</a>" tutorial.

#### Parameters

* `r` (Type: Array.&lt;number> | number | string)<br>One of the following:<ul> <li>A <b>color vector or string</b>, which can be one of these:<ul> <li>An array of three color components, each of which ranges from 0 to 1. The three components are red, green, and blue in that order.</li> <li>An array of four color components, each of which ranges from 0 to 1. The three components are red, green, blue, and alpha in that order.</li> <li>A string specifying an HTML or CSS color, in one of the formats mentioned above in the method description.</li></ul></li> <li>A number specifying the red component. Must range from 0 to 1.</li> </ul> Returns (0,0,0,0) if this value is null.
* `g` (Type: number) (optional)<br>Green color component (0-1). May be null or omitted if a string or array is given as the "r" parameter.
* `b` (Type: number) (optional)<br>Blue color component (0-1). May be null or omitted if a string or array is given as the "r" parameter.
* `a` (Type: number) (optional)<br>Alpha color component (0-1). If the "r" parameter is given and this parameter is null, undefined, or omitted, this value is treated as 1.0.

#### Return Value

The color as a 4-element array; if the color is
invalid, returns [0,0,0,0], or transparent black. Numbers less
than 0 are clamped to 0, and numbers greater than 1 are
clamped to 1. (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_toLineMeshBuffer'></a>
### H3DU.GraphicsPath#toLineMeshBuffer([z], [flatness])

Generates a mesh buffer consisting of the approximate line segments that make up this graphics path.

#### Parameters

* `z` (Type: number) (optional)<br>Z coordinate for each line segment. If null, undefined, or omitted, the default is 0.
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

The resulting mesh buffer. (Type: MeshBuffer)

<a name='H3DU.GraphicsPath_toLinePath'></a>
### H3DU.GraphicsPath#toLinePath([flatness])

Creates a path in which curves and arcs are decomposed
to line segments.

#### Parameters

* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

A path consisting only of line
segments and close commands. (Type: GraphicsPath)

<a name='extras_drawingtoy_DrawingToy_toMeshBuffer'></a>
### module:extras/drawingtoy~DrawingToy#toMeshBuffer()

TODO: Not documented yet.

#### Return Value

Return value. (Type: *)

<a name='H3DU.GraphicsPath_toString'></a>
### H3DU.GraphicsPath#toString()

Returns this path in the form of a string in SVG path format.
See GraphicsPath.fromString.

#### Return Value

A string describing the path in the SVG path
format. (Type: string)

<a name='extras_evaluators_SurfaceOfRevolution.torus'></a>
### (static) module:extras/evaluators~SurfaceOfRevolution.torus(outerRadius, innerRadius, [curve], [axis])

A surface evaluator object for a torus, a special case of a surface of revolution.

#### Parameters

* `outerRadius` (Type: number)<br>Radius from the center to the innermost part of the torus.
* `innerRadius` (Type: number)<br>Radius from the inner edge to the innermost part of the torus.
* `curve` (Type: Object) (optional)<br>A curve evaluator object that describes a 2-dimensional curve to serve as the cross section of the torus. The curve need not be closed; in fact, certain special surfaces can result by leaving the ends open. If null, undefined, or omitted, uses a circular cross section with a radius of 1.
* `axis` (Type: Array.&lt;number>) (optional)<br>Axis of rotation, which the torus will pass through. If null, undefined, or omitted, the positive Z axis (0, 0, 1) will be the axis of rotation. This parameter is a 3-element array describing the X, Y, and Z coordinates, respectively, of a 3D point. The axis of rotation will run in the direction from the origin to the point given in this parameter. This parameter need not be a <a href="tutorial-glmath.md">unit vector</a>.

#### Return Value

Return value. (Type: SurfaceOfRevolution)

<a name='H3DU.GraphicsPath_transform'></a>
### H3DU.GraphicsPath#transform(trans)

Returns a modified version of this path that is transformed
according to the given affine transformation (a transformation
that keeps straight lines straight and parallel lines parallel).

#### Parameters

* `trans` (Type: Array.&lt;number>)<br>An array of six numbers describing a 2-dimensional affine transformation. For each point in the current path, its new X coordinate is `trans[0] \* X + trans[2] \* Y + trans[4]`, and its new Y coordinate is `trans[1] \* X + trans[3] \* Y + trans[5]`.

#### Return Value

The transformed version of this path. (Type: GraphicsPath)

<a name='extras_matrixstack_MatrixStack_translate'></a>
### module:extras/matrixstack~MatrixStack#translate(x, y, z)

Modifies the matrix at the top of this stack by multiplying it by a
translation transformation.

#### Parameters

* `x` (Type: number)<br>Translation along the X axis.
* `y` (Type: number)<br>Translation along the Y axis.
* `z` (Type: number)<br>Translation along the Z axis.

#### Return Value

This object. (Type: MatrixStack)

<a name='extras_camera_Camera_turnAngleHorizontal'></a>
### module:extras/camera~Camera#turnAngleHorizontal(angleDegrees)

Turns the camera to the left or right so that it faces
the same distance from a reference point.

#### Parameters

* `angleDegrees` (Type: number)<br>The angle to rotate the camera, in degrees. If the coordinate-system is right-handed, positive values rotate the camera rightward, and negative values leftward. If the coordinate-system is left-handed, vice versa.

#### Return Value

This object. (Type: Camera)

<a name='extras_camera_Camera_turnAngleVertical'></a>
### module:extras/camera~Camera#turnAngleVertical(angleDegrees)

Turns the camera upward or downward so that it faces
the same distance from a reference point.

#### Parameters

* `angleDegrees` (Type: number)<br>The angle to rotate the camera, in degrees. If the coordinate-system is right-handed, positive values rotate the camera upward, and negative values downward. If the coordinate-system is left-handed, vice versa.

#### Return Value

This object. (Type: Camera)

<a name='H3DU.BSplineSurface.uniform'></a>
### (static) H3DU.BSplineSurface.uniform(controlPoints, [degreeU], [degreeV], [bits])

Creates a B-spline surface with uniform knots.

#### Parameters

* `controlPoints` (Type: Array.&lt;Array.&lt;Array.&lt;number>>>)<br>Array of control point arrays as specified in the BSplineSurface constructor.
* `degreeU` (Type: number) (optional)<br>Degree of the B-spline surface along the U axis. For example, 3 means a degree-3 (cubic) curve. If null, undefined, or omitted, the default is 3.
* `degreeV` (Type: number) (optional)<br>Degree of the B-spline surface along the V axis If null, undefined, or omitted, the default is 3.
* `bits` (Type: number) (optional)<br>Bits as specified in the BSplineSurface constructor.

#### Return Value

Return value. The first
knot of the curve will be 0 and the last knot will be 1. (Type: BSplineSurface)

<a name='H3DU.BSplineCurve.uniformKnots'></a>
### (static) H3DU.BSplineCurve.uniformKnots(controlPoints, [degree])

Generates a knot vector with uniform knots, to be
passed to the BSplineCurve or BSplineCurve constructor.

#### Parameters

* `controlPoints` (Type: number | Object)<br>Number of control points the curve will have, or an array of control points.
* `degree` (Type: number) (optional)<br>Degree of the B-spline curve. For example, 3 means a degree-3 (cubic) curve. If null, undefined, or omitted, the default is 3.

#### Return Value

A uniform knot vector. The first
knot will be 0 and the last knot will be 1. (This is a change from previous
versions.) (Type: Array.&lt;number>)

<a name='H3DU.GraphicsPath_union'></a>
### H3DU.GraphicsPath#union(path, [flatness])

Computes the combination of this path's shape with another
path's shape. The following points apply to this method:<ul>
<li>This method treats unclosed subpaths as implicitly closed
by connecting their end points with their start points.
<li>Currently, the algorithm supports only polygons made up
of line segments, so curves and arcs are converted to line
segments before applying the operation.
<li>Each polygon can be concave or have self-intersections
or holes. Subpaths that are holes have the opposite winding
order (clockwise or counterclockwise) from the subpath
that contains them.
</ul>

#### Parameters

* `path` (Type: GraphicsPath)<br>A path to combine with this one.
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

The union of the two paths. (Type: GraphicsPath)

<a name='extras_camera_Camera_update'></a>
### module:extras/camera~Camera#update([input])

Updates information about this camera based
on the state of an input tracker.

#### Parameters

* `input` (Type: InputTracker) (optional)<br>An input tracker. This method should be called right after the tracker's 'update' method was called. <i>Note that future versions may require this parameter.</i>

#### Return Value

Return value. (Type: Object)

<a name='H3DU.MathUtil.vec2abs'></a>
### (static) H3DU.MathUtil.vec2abs(a)

Returns a new 2-element
vector with the absolute value of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The resulting 2-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2absInPlace'></a>
### (static) H3DU.MathUtil.vec2absInPlace(a)

Sets each component of the given 2-element
vector to its absolute value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The vector "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2add'></a>
### (static) H3DU.MathUtil.vec2add(a, b)

Adds two 2-element vectors and returns a new
vector with the result. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The resulting 2-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2addInPlace'></a>
### (static) H3DU.MathUtil.vec2addInPlace(a, b)

Adds two 2-element vectors and stores
the result in the first vector. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The parameter "a" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2assign'></a>
### (static) H3DU.MathUtil.vec2assign(dst, src)

Assigns the values of a 2-element vector into another
2-element vector.

#### Parameters

* `dst` (Type: Array.&lt;number>)<br>The 2-element vector to assign to.
* `src` (Type: Array.&lt;number>)<br>The 2-element vector whose values will be copied.

#### Return Value

The parameter "dst" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2clamp'></a>
### (static) H3DU.MathUtil.vec2clamp(a, min, max)

Returns a 2-element vector in which each element of the given 2-element vector is clamped
so it's not less than one value or greater than another value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2clampInPlace'></a>
### (static) H3DU.MathUtil.vec2clampInPlace(a, min, max)

Clamps each element of the given 2-element vector
so it's not less than one value or greater than another value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2copy'></a>
### (static) H3DU.MathUtil.vec2copy(vec)

Returns a copy of a 2-element vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2dist'></a>
### (static) H3DU.MathUtil.vec2dist(vecFrom, vecTo)

Finds the straight-line distance from one three-element vector
to another, treating both as 3D points.

#### Parameters

* `vecFrom` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `vecTo` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The distance between the two vectors. (Type: number)

<a name='H3DU.MathUtil.vec2dot'></a>
### (static) H3DU.MathUtil.vec2dot(a, b)

Finds the dot product of two 2-element vectors. It's the
sum of the products of their components (for example, <b>a</b>'s X times
<b>b</b>'s X).

 For properties of the dot product, see MathUtil.vec3dot.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

A number representing the dot product. (Type: number)

#### Examples

The following shows a fast way to compare
a vector's length using the dot product.

    // Check if the vector's length squared is less than 20 units squared
    if(MathUtil.vec2dot(vector, vector)<20*20) {
    // The vector's length is shorter than 20 units
    }

<a name='H3DU.MathUtil.vec2length'></a>
### (static) H3DU.MathUtil.vec2length(a)

Returns the distance of this 2-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
It's the same as the square root of the sum of the squares
of its components.

Note that if vectors are merely sorted or compared by their lengths (and
those lengths are not added or multiplied together or the like),
it's faster to sort or compare them by the squares of their lengths (to find
the square of a 2-element vector's length, call MathUtil.vec2dot
passing the same vector as both of its arguments).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MathUtil.vec2lerp'></a>
### (static) H3DU.MathUtil.vec2lerp(v1, v2, factor)

Does a linear interpolation between two 2-element vectors;
returns a new vector.

#### Parameters

* `v1` (Type: Array.&lt;number>)<br>The first vector to interpolate. The interpolation will occur on each component of this vector and v2.
* `v2` (Type: Array.&lt;number>)<br>The second vector to interpolate.
* `factor` (Type: number)<br>A value that usually ranges from 0 through 1. Closer to 0 means closer to v1, and closer to 1 means closer to v2.<br>For a nonlinear interpolation, define a function that takes a value that usually ranges from 0 through 1 and returns a value generally ranging from 0 through 1, and pass the result of that function to this method. For examples, see MathUtil.vec3lerp.

#### Return Value

The interpolated vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2mul'></a>
### (static) H3DU.MathUtil.vec2mul(a, b)

Multiplies each of the components of two 2-element vectors and returns a new
vector with the result.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The resulting 2-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2mulInPlace'></a>
### (static) H3DU.MathUtil.vec2mulInPlace(a, b)

Multiplies each of the components of two 2-element vectors and stores
the result in the first vector.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The parameter "a" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2negate'></a>
### (static) H3DU.MathUtil.vec2negate(a)

Negates a 2-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction. Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The resulting 2-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2negateInPlace'></a>
### (static) H3DU.MathUtil.vec2negateInPlace(a)

Negates a 2-element vector in place, generally resulting in a vector with
the same length but opposite direction.
Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2normalize'></a>
### (static) H3DU.MathUtil.vec2normalize(vec)

Converts a 2-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The resulting vector.
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

#### Examples

The following example changes the
length of a line segment.

    var startPt=[x1,y1]; // Line segment's start
    var endPt=[x2,y2]; // Line segment's end
    // Find difference between endPt and startPt
    var delta=MathUtil.vec2sub(endPt,startPt);
    // Normalize delta to a unit vector
    var deltaNorm=MathUtil.vec2normalize(delta);
    // Rescale to the desired length, here, 10
    MathUtil.vec2scaleInPlace(deltaNorm,10);
    // Find the new endpoint
    endPt=MathUtil.vec2add(startPt,deltaNorm);

<a name='H3DU.MathUtil.vec2normalizeInPlace'></a>
### (static) H3DU.MathUtil.vec2normalizeInPlace(vec)

Converts a 2-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

The parameter "vec".
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2perp'></a>
### (static) H3DU.MathUtil.vec2perp(vec)

Returns an arbitrary 2-element vector that is perpendicular
(orthogonal) to the given 2-element vector. The return value
will not be converted to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 2-element vector.

#### Return Value

A perpendicular 2-element
vector. Returns (0,0) if "vec" is (0,0). (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2proj'></a>
### (static) H3DU.MathUtil.vec2proj(vec, refVec)

Returns the projection of a 2-element vector on the given
reference vector. Assuming both vectors
start at the same point, the resulting vector
will be parallel to the
reference vector but will make the closest
approach possible to the projected vector's
endpoint. The difference between the projected
vector and the return value will be perpendicular
to the reference vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>The vector to project.
* `refVec` (Type: Array.&lt;number>)<br>The reference vector whose length will be adjusted.

#### Return Value

The projection of
"vec" on "refVec". Returns (0,0,0) if "refVec"'s
length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2reflect'></a>
### (static) H3DU.MathUtil.vec2reflect(incident, normal)

Returns a vector that reflects off a surface.

#### Parameters

* `incident` (Type: Array.&lt;number>)<br>Incident vector, or a vector headed in the direction of the surface, as a 2-element vector.
* `normal` (Type: Array.&lt;number>)<br>Surface normal vector, or a vector that's perpendicular to the surface, as a 2-element vector. Should be a <a href="tutorial-glmath.md">unit vector</a>.

#### Return Value

A vector that has the same length
as "incident" but is reflected away from the surface. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2scale'></a>
### (static) H3DU.MathUtil.vec2scale(a, scalar)

Multiplies each element of a 2-element vector by a factor. Returns
a new vector that is parallel to the old vector
but with its length multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2scaleInPlace'></a>
### (static) H3DU.MathUtil.vec2scaleInPlace(a, scalar)

Multiplies each element of a 2-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 2-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2sub'></a>
### (static) H3DU.MathUtil.vec2sub(a, b)

Subtracts the second vector from the first vector and returns a new
vector with the result. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The resulting 2-element vector.
This is the vector <i>to <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec2subInPlace'></a>
### (static) H3DU.MathUtil.vec2subInPlace(a, b)

Subtracts the second vector from the first vector and stores
the result in the first vector. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 2-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 2-element vector.

#### Return Value

The parameter "a".
This is the vector <i>to the previous <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3abs'></a>
### (static) H3DU.MathUtil.vec3abs(a)

Returns a new 3-element
vector with the absolute value of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The resulting 3-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3absInPlace'></a>
### (static) H3DU.MathUtil.vec3absInPlace(a)

Sets each component of the given 3-element
vector to its absolute value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The vector "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3add'></a>
### (static) H3DU.MathUtil.vec3add(a, b)

Adds two 3-element vectors and returns a new
vector with the result. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The resulting 3-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3addInPlace'></a>
### (static) H3DU.MathUtil.vec3addInPlace(a, b)

Adds two 3-element vectors and stores
the result in the first vector. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The parameter "a" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3assign'></a>
### (static) H3DU.MathUtil.vec3assign(dst, src)

Assigns the values of a 3-element vector into another
3-element vector.

#### Parameters

* `dst` (Type: Array.&lt;number>)<br>The 3-element vector to assign to.
* `src` (Type: Array.&lt;number>)<br>The 3-element vector whose values will be copied.

#### Return Value

The parameter "dst" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3clamp'></a>
### (static) H3DU.MathUtil.vec3clamp(a, min, max)

Returns a 3-element vector in which each element of the given 3-element vector is clamped
so it's not less than one value or greater than another value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3clampInPlace'></a>
### (static) H3DU.MathUtil.vec3clampInPlace(a, min, max)

Clamps each element of the given 3-element vector
so it's not less than one value or greater than another value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3copy'></a>
### (static) H3DU.MathUtil.vec3copy(vec)

Returns a copy of a 3-element vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3cross'></a>
### (static) H3DU.MathUtil.vec3cross(a, b)

Finds the cross product of two 3-element vectors (called A and B).
The following are properties of the cross product:<ul>
<li>The cross product will be a vector that is <i>orthogonal</i> (perpendicular) to both A and B.
<li>Switching the order of A and B results in a cross product
vector with the same length but opposite direction. (Thus, the cross product is not <i>commutative</i>,
but it is <i>anticommutative</i>.)
<li>Let there be a triangle formed by point A, point B, and the point (0,0,0) in that order.
While the cross product of A and B points toward the viewer,
the triangle's vertices are oriented counterclockwise for <a href="tutorial-glmath.md">right-handed coordinate systems</a>,
or clockwise for left-handed systems. The triangle's area is half of the cross product's length.
<li>The length of the cross
product equals |<b>a</b>| &#x2a; |<b>b</b>| &#x2a; |sin &theta;|
where |<b>x</b>| is the length of vector <b>x</b>, and
&theta; is the shortest angle between <b>a</b> and <b>b</b>.
It follows that:<ul>
<li>If the length is 0, then A and B are parallel vectors (0 or 180 degrees apart).
<li>If A and B are <a href="tutorial-glmath.md">unit vectors</a>, the length equals the absolute value
of the sine of the shortest angle between A and B.
<li>If A and B are unit vectors, the cross product will be a unit vector only if A is perpendicular
to B (the shortest angle between A and B will be 90 degrees, since sin 90&deg; = 1).
</ul></ul>
The cross product (<b>c</b>) of vectors <b>a</b> and <b>b</b> is found as
follows:<br>
<b>c</b>.x = <b>a</b>.y &#x2a; <b>b</b>.z - <b>a</b>.z &#x2a; <b>b</b>.y<br>
<b>c</b>.y = <b>a</b>.z &#x2a; <b>b</b>.x - <b>a</b>.x &#x2a; <b>b</b>.z<br>
<b>c</b>.z = <b>a</b>.x &#x2a; <b>b</b>.y - <b>a</b>.y &#x2a; <b>b</b>.x<br>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

A 3-element vector containing the cross product. (Type: Array.&lt;number>)

#### Examples

The following example uses the cross product to
calculate a triangle's normal vector and its area.

    var a=triangle[0];
    var b=triangle[1];
    var c=triangle[2];
    // Find vector from C to A
    var da=MathUtil.vec3sub(a,c);
    // Find vector from C to B
    var db=MathUtil.vec3sub(b,c);
    // The triangle's normal is the cross product of da and db
    var normal=MathUtil.vec3cross(da,db);
    // Find the triangle's area
    var area=MathUtil.vec3length(normal)*0.5;

The following example finds the cosine and sine of
the angle between two unit vectors and the orthogonal unit vector of both.

    var cr=MathUtil.vec3cross(unitA,unitB);
    // Cosine of the angle. Will be positive or negative depending on
    // the shortest angle between the vectors.
    var cosine=MathUtil.vec3dot(unitA,unitB);
    // Sine of the angle. Note that the sine will always be 0 or greater because
    // the shortest angle between them is positive or 0 degrees.
    var sine=MathUtil.vec3length(cr);

<a name='H3DU.MathUtil.vec3dist'></a>
### (static) H3DU.MathUtil.vec3dist(vecFrom, vecTo)

Finds the straight-line distance from one three-element vector
to another, treating both as 3D points.

#### Parameters

* `vecFrom` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `vecTo` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The distance between the two vectors. (Type: number)

<a name='H3DU.MathUtil.vec3dot'></a>
### (static) H3DU.MathUtil.vec3dot(a, b)

Finds the dot product of two 3-element vectors. It's the
sum of the products of their components (for example, <b>a</b>'s X times
<b>b</b>'s X).

The following are properties of the dot product:
<ul>
<li>The dot
product equals |<b>a</b>| &#x2a; |<b>b</b>| &#x2a; cos &theta;
where |<b>x</b>| is the length of vector <b>x</b>, and
&theta; is the shortest angle between <b>a</b> and <b>b</b>.
It follows that:<ul>
<li>A dot product of 0 indicates that the vectors are 90
degrees apart, making them <i>orthogonal</i>
(perpendicular to each other).
<li>A dot product greater than 0 means less than 90 degrees apart.
<li>A dot product less than 0 means greater than 90 degrees apart.
<li>If both vectors are <a href="tutorial-glmath.md">unit vectors</a>, the cosine
of the shortest angle between them is equal to their dot product.
However, <code>Math.acos</code> won't return a negative angle
from that cosine, so the dot product can't
be used to determine if one vector is "ahead of" or "behind" another
vector.
<li>If both vectors are unit vectors, a dot product of 1 or -1 indicates
that the two vectors are parallel (and the vectors are 0 or
180 degrees apart, respectively.)
<li>If one of the vectors is a unit vector, the dot product's absolute
value will be the length that vector must have to make the closest
approach to the other vector's endpoint. If the dot product is negative,
the unit vector must also be in the opposite direction to approach the
other vector's endpoint.
</ul></li>
<li>If the two vectors are the same, the return value indicates
the vector's length squared. This is illustrated in the example.
<li>Switching the order of the two vectors results in the
same dot product. (Thus, the dot product is <i>commutative</i>.)
</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

A number representing the dot product. (Type: number)

#### Examples

The following shows a fast way to compare
a vector's length using the dot product.

    // Check if the vector's length squared is less than 20 units squared
    if(MathUtil.vec3dot(vector, vector)<20*20) {
    // The vector's length is shorter than 20 units
    }

<a name='H3DU.MathUtil.vec3fromWindowPoint'></a>
### (static) H3DU.MathUtil.vec3fromWindowPoint(vector, matrix, viewport, [yUp])

Unprojects the <i>window coordinates</i> given in a
3-element vector,
using the given transformation matrix and viewport
rectangle.

In the window coordinate space, X coordinates increase
rightward and Y coordinates increase upward
or downward depending on the "yUp" parameter, and
Z coordinates within the view volume range from 0 to 1 and
increase from front to back.

#### Parameters

* `vector` (Type: Array.&lt;number>)<br>A 3-element vector giving the X, Y, and Z coordinates of the 3D point to transform, in window coordinates.
* `matrix` (Type: Array.&lt;number>)<br>A 4x4 matrix. After undoing the transformation to window coordinates, the vector will be transformed by the inverse of this matrix according to the MathUtil.mat4projectVec3 method.<br> To convert to world space, this parameter will generally be a projection-view matrix (projection matrix multiplied by the view matrix, in that order). To convert to object (model) space, this parameter will generally be a model-view-projection matrix (projection-view matrix multiplied by the world [model] matrix, in that order). See MathUtil.vec3toWindowPoint for the meaning of window coordinates with respect to the "matrix" and "yUp" parameters.
* `viewport` (Type: Array.&lt;number>)<br>A 4-element array specifying the starting position and size of the viewport in window units (such as pixels). In order, the four elements are the starting position's X coordinate, its Y coordinate, the viewport's width, and the viewport's height. Throws an error if the width or height is less than 0.
* `yUp` (Type: boolean) (optional)<br>If omitted or a "falsy" value, reverses the sign of the Y coordinate returned by the MathUtil.mat4projectVec3 method before converting it to window coordinates. If true, the Y coordinate will remain unchanged. If window Y coordinates increase upward, the viewport's starting position is at the lower left corner. If those coordinates increase downward, the viewport's starting position is at the upper left corner.

#### Return Value

A 3-element array giving the coordinates
of the unprojected point, in that order. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3length'></a>
### (static) H3DU.MathUtil.vec3length(a)

Returns the distance of this 3-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
It's the same as the square root of the sum of the squares
of its components.

Note that if vectors are merely sorted or compared by their lengths (and
those lengths are not added or multiplied together or the like),
it's faster to sort or compare them by the squares of their lengths (to find
the square of a 3-element vector's length, call MathUtil.vec3dot
passing the same vector as both of its arguments).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MathUtil.vec3lerp'></a>
### (static) H3DU.MathUtil.vec3lerp(v1, v2, factor)

Does a linear interpolation between two 3-element vectors;
returns a new vector.

#### Parameters

* `v1` (Type: Array.&lt;number>)<br>The first vector to interpolate. The interpolation will occur on each component of this vector and v2.
* `v2` (Type: Array.&lt;number>)<br>The second vector to interpolate.
* `factor` (Type: number)<br>A value that usually ranges from 0 through 1. Closer to 0 means closer to v1, and closer to 1 means closer to v2.<br>For a nonlinear interpolation, define a function that takes a value that usually ranges from 0 through 1 and returns a value generally ranging from 0 through 1, and pass the result of that function to this method.<br> The following are examples of interpolation functions. See also the code examples following this list.<ul> <li>Linear: <code>factor</code>. Constant speed. <li>Powers: <code>Math.pow(factor, N)</code>, where N &gt; 0. For example, N=2 means a square, N=3 means cube, N=1/2 means square root, and N=1/3 means cube root. If N &gt; 1, this function starts slow and ends fast. If N &lt; 1, this function starts fast and ends slow. <li>Sine: <code>Math.sin(Math.PI\*0.5\*factor)</code>. This function starts fast and ends slow. <li>Smoothstep: <code>(3.0-2.0\*factor)\*factor\*factor</code>. This function starts and ends slow, and speeds up in the middle. <li>Perlin's "Smootherstep": <code>(10+factor\*(factor\*6-15))\*factor\*factor\*factor</code>. This function starts and ends slow, and speeds up in the middle. <li>Discrete-step timing, where N is a number of steps greater than 0:<ul> <li>Position start: <code>factor &lt; 0 ? 0 : Math.max(1.0,(1.0+Math.floor(factor\*N))/N)</code>.</li> <li>Position end: <code>Math.floor(factor\*N)/N</code>.</li></ul> <li>Inverted interpolation: <code>1.0-INTF(1.0-factor)</code>, where <code>INTF(x)</code> is another interpolation function. This function reverses the speed behavior; for example, a function that started fast now starts slow. <li>Ease: <code>factor &lt; 0.5 ? INTF(factor\*2)\*0.5 : 1.0-(INTF((1.0-factor)\*2)\*0.5)</code>, where <code>INTF(x)</code> is another interpolation function. Depending on the underlying function, this function eases in, then eases out, or vice versa. </ul>

#### Return Value

The interpolated vector. (Type: Array.&lt;number>)

#### Examples

The following code does a nonlinear
interpolation of two vectors that uses the cube of "factor" rather than
"factor". Rather than at a constant speed, the vectors are interpolated
slowly then very fast.

    factor = factor*factor*factor; // cube the interpolation factor
    var newVector = MathUtil.vec3lerp(vector1, vector2, factor);

The following code does an inverted cubic
interpolation. This time, vectors are interpolated fast then very slowly.

    factor = 1 - factor; // Invert the factor
    factor = factor*factor*factor; // cube the interpolation factor
    factor = 1 - factor; // Invert the result
    var newVector = MathUtil.vec3lerp(vector1, vector2, factor);

The following code does the nonlinear
 interpolation called "smoothstep". It slows down at the beginning
and end, and speeds up in the middle.

    factor = (3.0-2.0*factor)*factor*factor; // smoothstep interpolation
    var newVector = MathUtil.vec3lerp(vector1, vector2, factor);

<a name='H3DU.MathUtil.vec3mul'></a>
### (static) H3DU.MathUtil.vec3mul(a, b)

Multiplies each of the components of two 3-element vectors and returns a new
vector with the result.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The resulting 3-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3mulInPlace'></a>
### (static) H3DU.MathUtil.vec3mulInPlace(a, b)

Multiplies each of the components of two 3-element vectors and stores
the result in the first vector.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The parameter "a" (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3negate'></a>
### (static) H3DU.MathUtil.vec3negate(a)

Negates a 3-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction. Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The resulting 3-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3negateInPlace'></a>
### (static) H3DU.MathUtil.vec3negateInPlace(a)

Negates a 3-element vector in place, generally resulting in a vector with
the same length but opposite direction.
Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3normalize'></a>
### (static) H3DU.MathUtil.vec3normalize(vec)

Converts a 3-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The resulting vector.
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

#### Examples

The following example changes the
length of a line segment.

    var startPt=[x1,y1,z1]; // Line segment's start
    var endPt=[x2,y2,z2]; // Line segment's end
    // Find difference between endPt and startPt
    var delta=MathUtil.vec3sub(endPt,startPt);
    // Normalize delta to a unit vector
    var deltaNorm=MathUtil.vec3normalize(delta);
    // Rescale to the desired length, here, 10
    MathUtil.vec3scaleInPlace(deltaNorm,10);
    // Find the new endpoint
    endPt=MathUtil.vec3add(startPt,deltaNorm);

<a name='H3DU.MathUtil.vec3normalizeInPlace'></a>
### (static) H3DU.MathUtil.vec3normalizeInPlace(vec)

Converts a 3-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

The parameter "vec".
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3perp'></a>
### (static) H3DU.MathUtil.vec3perp(vec)

Returns an arbitrary 3-element vector that is perpendicular
(orthogonal) to the given 3-element vector. The return value
will not be converted to a <a href="tutorial-glmath.md">unit vector</a>.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 3-element vector.

#### Return Value

A perpendicular 3-element
vector. Returns (0,0,0) if "vec" is (0,0,0). (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3proj'></a>
### (static) H3DU.MathUtil.vec3proj(vec, refVec)

Returns the projection of a 3-element vector on the given
reference vector. Assuming both vectors
start at the same point, the resulting vector
will be parallel to the
reference vector but will make the closest
approach possible to the projected vector's
endpoint. The difference between the projected
vector and the return value will be perpendicular
to the reference vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>The vector to project.
* `refVec` (Type: Array.&lt;number>)<br>The reference vector whose length will be adjusted.

#### Return Value

The projection of
"vec" on "refVec". Returns (0,0,0) if "refVec"'s
length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3reflect'></a>
### (static) H3DU.MathUtil.vec3reflect(incident, normal)

Returns a vector that reflects off a surface.

#### Parameters

* `incident` (Type: Array.&lt;number>)<br>Incident vector, or a vector headed in the direction of the surface, as a 3-element vector.
* `normal` (Type: Array.&lt;number>)<br>Surface normal vector, or a vector that's perpendicular to the surface, as a 3-element vector. Should be a <a href="tutorial-glmath.md">unit vector</a>.

#### Return Value

A vector that has the same length
as "incident" but is reflected away from the surface. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3scale'></a>
### (static) H3DU.MathUtil.vec3scale(a, scalar)

Multiplies each element of a 3-element vector by a factor. Returns
a new vector that is parallel to the old vector
but with its length multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3scaleInPlace'></a>
### (static) H3DU.MathUtil.vec3scaleInPlace(a, scalar)

Multiplies each element of a 3-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 3-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3sub'></a>
### (static) H3DU.MathUtil.vec3sub(a, b)

Subtracts the second vector from the first vector and returns a new
vector with the result. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The resulting 3-element vector.
This is the vector <i>to <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3subInPlace'></a>
### (static) H3DU.MathUtil.vec3subInPlace(a, b)

Subtracts the second vector from the first vector and stores
the result in the first vector. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector.

#### Return Value

The parameter "a".
This is the vector <i>to the previous <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3toWindowPoint'></a>
### (static) H3DU.MathUtil.vec3toWindowPoint(vector, matrix, viewport, [yUp])

Transforms the 3D point specified in this 3-element vector to its
<i>window coordinates</i>
using the given transformation matrix and viewport rectangle.

#### Parameters

* `vector` (Type: Array.&lt;number>)<br>A 3-element vector giving the X, Y, and Z coordinates of the 3D point to transform.
* `matrix` (Type: Array.&lt;number>)<br>A 4x4 matrix to use to transform the vector according to the MathUtil.mat4projectVec3 method, before the transformed vector is converted to window coordinates. <br>This parameter will generally be a projection-view matrix (projection matrix multiplied by the view matrix, in that order), if the vector to transform is in <i>world space</i>, or a model-view-projection matrix, that is, (projection-view matrix multiplied by the model [world] matrix, in that order), if the vector is in <i>model (object) space</i>. <br>If the matrix includes a projection transform returned by MathUtil.mat4ortho, MathUtil.mat4perspective, or similar MathUtil methods, then in the <i>window coordinate</i> space, X coordinates increase rightward, Y coordinates increase upward, and Z coordinates within the view volume range from 0 to 1 and increase from front to back, unless otherwise specified in those methods' documentation. If "yUp" is omitted or is a "falsy" value, the Y coordinates increase downward instead of upward or vice versa.
* `viewport` (Type: Array.&lt;number>)<br>A 4-element array specifying the starting position and size of the viewport in window units (such as pixels). In order, the four elements are the starting position's X coordinate, its Y coordinate, the viewport's width, and the viewport's height. Throws an error if the width or height is less than 0.
* `yUp` (Type: boolean) (optional)<br>If omitted or a "falsy" value, reverses the sign of the Y coordinate returned by the MathUtil.mat4projectVec3 method before converting it to window coordinates. If true, the Y coordinate will remain unchanged. If window Y coordinates increase upward, the viewport's starting position is at the lower left corner. If those coordinates increase downward, the viewport's starting position is at the upper left corner.

#### Return Value

A 3-element array giving the window
coordinates, in that order. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec3triple'></a>
### (static) H3DU.MathUtil.vec3triple(a, b, c)

Finds the scalar triple product of three vectors (A, B, and C). The triple
product is the dot product of both A and the
cross product
of B and C. The following are properties of the scalar triple product
(called triple product in what follows):<ul>
<li>Switching the order of B and C, A and C, or A and B results in a triple product
with its sign reversed. Moving all three parameters to different positions, though,
results in the same triple product.
<li>The triple product's absolute value is the volume of a parallelepiped (skewed
box) where three of its sides having a vertex in common are
defined by A, B, and C, in any order.
<li>The triple product's absolute value divided by 6 is the volume of a tetrahedron,
where three of its sides having a vertex in common are
defined by A, B, and C, in any order.
<li>If the triple product is 0, all three vectors lie on the same plane (are <i>coplanar</i>).
<li>The triple product is the same as the <i>determinant</i> (overall scaling factor)
of a 3x3 matrix whose rows or columns are the vectors A, B, and C, in that order.
<li>Assume A is perpendicular to vectors B and C. If the triple product is positive,
then A points in the same direction as the cross product of
B and C -- which will be perpendicular -- and the angle from B to C, when rotated
about vector A, is positive. If the triple product is negative, then A points in the
opposite direction from that cross product, and that angle is negative.
(See the example below.)
</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 3-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 3-element vector, or the first parameter to the cross product.
* `c` (Type: Array.&lt;number>)<br>The third 3-element vector, or the second parameter to the cross product.

#### Return Value

A number giving the triple product. (Type: number)

<a name='H3DU.MathUtil.vec4abs'></a>
### (static) H3DU.MathUtil.vec4abs(a)

Returns a new 4-element
vector with the absolute value of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The resulting 4-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4absInPlace'></a>
### (static) H3DU.MathUtil.vec4absInPlace(a)

Sets each component of the given 4-element
vector to its absolute value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The vector "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4add'></a>
### (static) H3DU.MathUtil.vec4add(a, b)

Adds two 4-element vectors and returns a new
vector with the result. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 4-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 4-element vector.

#### Return Value

The resulting 4-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4addInPlace'></a>
### (static) H3DU.MathUtil.vec4addInPlace(a, b)

Adds two 4-element vectors and stores
the result in the first vector. Adding two vectors
is the same as adding each of their components.
The resulting vector:<ul>
<li>describes a straight-line path for the
combined paths described by the given vectors, in either order, and
<li>will come "between" the two vectors given (at their shortest angle) if all three start
at the same position.</ul>

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 4-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 4-element vector.

#### Return Value

The parameter "a".
This is the vector <i>to the previous <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4assign'></a>
### (static) H3DU.MathUtil.vec4assign(dst, src)

Assigns the values of a 4-element vector into another
4-element vector.

#### Parameters

* `dst` (Type: Array.&lt;number>)<br>The 4-element vector to copy the source values to.
* `src` (Type: Array.&lt;number>)<br>The 4-element vector whose values will be copied.

#### Return Value

The parameter "dst". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4clamp'></a>
### (static) H3DU.MathUtil.vec4clamp(a, min, max)

Returns a 4-element vector in which each element of the given 4-element vector is clamped

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4clampInPlace'></a>
### (static) H3DU.MathUtil.vec4clampInPlace(a, min, max)

Clamps each element of the given 4-element vector
so it's not less than one value or greater than another value.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The vector to clamp.
* `min` (Type: number)<br>Lowest possible value. Should not be greater than "max".
* `max` (Type: number)<br>Highest possible value. Should not be less than "min".

#### Return Value

The resulting vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4copy'></a>
### (static) H3DU.MathUtil.vec4copy(vec)

Returns a copy of a 4-element vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

Return value. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4dot'></a>
### (static) H3DU.MathUtil.vec4dot(a, b)

Finds the dot product of two 4-element vectors. It's the
sum of the products of their components (for example, <b>a</b>'s X times <b>b</b>'s X).
For properties of the dot product, see MathUtil.vec3dot.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 4-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 4-element vector.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MathUtil.vec4length'></a>
### (static) H3DU.MathUtil.vec4length(a)

Returns the distance of this 4-element vector from the origin,
also known as its <i>length</i> or <i>magnitude</i>.
It's the same as the square root of the sum of the squares
of its components.

Note that if vectors are merely sorted or compared by their lengths,
it's faster to sort or compare them by the squares of their lengths (to find
the square of a 4-element vector's length, call MathUtil.vec4dot
passing the same vector as both of its arguments).

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MathUtil.vec4lerp'></a>
### (static) H3DU.MathUtil.vec4lerp(v1, v2, factor)

Does a linear interpolation between two 4-element vectors;
returns a new vector.

#### Parameters

* `v1` (Type: Array.&lt;number>)<br>The first vector to interpolate. The interpolation will occur on each component of this vector and v2.
* `v2` (Type: Array.&lt;number>)<br>The second vector to interpolate.
* `factor` (Type: number)<br>A value that usually ranges from 0 through 1. Closer to 0 means closer to v1, and closer to 1 means closer to v2. For a nonlinear interpolation, define a function that takes a value that usually ranges from 0 through 1 and generally returns A value that usually ranges from 0 through 1, and pass the result of that function to this method. See the documentation for MathUtil.vec3lerp for examples of interpolation functions.

#### Return Value

The interpolated vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4negate'></a>
### (static) H3DU.MathUtil.vec4negate(a)

Negates a 4-element vector and returns a new
vector with the result, which is generally a vector with
the same length but opposite direction. Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The resulting 4-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4negateInPlace'></a>
### (static) H3DU.MathUtil.vec4negateInPlace(a)

Negates a 4-element vector in place, generally resulting in a vector with
the same length but opposite direction.
Negating a vector
is the same as reversing the sign of each of its components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4normalize'></a>
### (static) H3DU.MathUtil.vec4normalize(vec)

Converts a 4-element vector to a <a href="tutorial-glmath.md">unit vector</a>; returns a new vector.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The resulting vector.
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4normalizeInPlace'></a>
### (static) H3DU.MathUtil.vec4normalizeInPlace(vec)

Converts a 4-element vector to a <a href="tutorial-glmath.md">unit vector</a>.
When a vector is normalized, its direction remains the same but the distance from the origin
to that vector becomes 1 (unless all its components are 0).
A vector is normalized by dividing each of its components
by its length.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>A 4-element vector.

#### Return Value

The parameter "vec".
Note that due to rounding error, the vector's length might not be exactly equal to 1, and that the vector will remain unchanged if its length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4proj'></a>
### (static) H3DU.MathUtil.vec4proj(vec, refVec)

Returns the projection of a 4-element vector on the given
reference vector. Assuming both vectors
start at the same point, the resulting vector
will be parallel to the
reference vector but will make the closest
approach possible to the projected vector's
endpoint. The difference between the projected
vector and the return value will be perpendicular
to the reference vector.

#### Parameters

* `vec` (Type: Array.&lt;number>)<br>The vector to project.
* `refVec` (Type: Array.&lt;number>)<br>The reference vector whose length will be adjusted.

#### Return Value

The projection of
"vec" on "refVec". Returns (0,0,0,0) if "refVec"'s
length is 0 or extremely close to 0. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4scale'></a>
### (static) H3DU.MathUtil.vec4scale(a, scalar)

Multiplies each element of a 4-element vector by a factor, returning
a new vector that is parallel to the old vector
but with its length multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The resulting 4-element vector. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4scaleInPlace'></a>
### (static) H3DU.MathUtil.vec4scaleInPlace(a, scalar)

Multiplies each element of a 4-element vector by a factor, so
that the vector is parallel to the old vector
but its length is multiplied by the given factor. If the factor
is positive, the vector will point in the same direction; if negative,
in the opposite direction; if zero, the vector's components will all be 0.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>A 4-element vector.
* `scalar` (Type: number)<br>A factor to multiply. To divide a vector by a number, the factor will be 1 divided by that number.

#### Return Value

The parameter "a". (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4sub'></a>
### (static) H3DU.MathUtil.vec4sub(a, b)

Subtracts the second vector from the first vector and returns a new
vector with the result. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 4-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 4-element vector.

#### Return Value

The resulting 4-element vector.
This is the vector <i>to <code>a</code> from <code>b</code></i>. (Type: Array.&lt;number>)

<a name='H3DU.MathUtil.vec4subInPlace'></a>
### (static) H3DU.MathUtil.vec4subInPlace(a, b)

Subtracts the second vector from the first vector and stores
the result in the first vector. Subtracting two vectors
is the same as subtracting each of their components.

#### Parameters

* `a` (Type: Array.&lt;number>)<br>The first 4-element vector.
* `b` (Type: Array.&lt;number>)<br>The second 4-element vector.

#### Return Value

The parameter "a" (Type: Array.&lt;number>)

<a name='extras_evaluators_Trochoid_velocity'></a>
### module:extras/evaluators~Trochoid#velocity(u)

Finds the velocity (derivative) of this curve at the given point.

#### Parameters

* `u` (Type: number)<br>Point on the curve to evaluate.

#### Return Value

An array giving the velocity vector. (Type: Array.&lt;number>)

<a name='H3DU.ShapeGroup_vertexCount'></a>
### H3DU.ShapeGroup#vertexCount()

Gets the number of vertices composed by all shapes in this shape group.

#### Return Value

Return value. (Type: number)

<a name='H3DU.MeshBuffer_vertexIndices'></a>
### H3DU.MeshBuffer#vertexIndices(primitiveIndex, ret)

Gets the vertex indices of a given primitive (triangle, line,
or point) in this mesh buffer.

#### Parameters

* `primitiveIndex` (Type: number)<br>The index (counting from 0) of the primitive whose indices will be retrieved.
* `ret` (Type: Array.&lt;number>)<br>An array where the vertex indices for the given primitive will be stored. If this mesh buffer stores triangles, three indices will be stored; if lines, two; and if points, one.

#### Return Value

The parameter "ret". (Type: Array.&lt;number>)

<a name='H3DU.MeshBuffer_wireFrame'></a>
### H3DU.MeshBuffer#wireFrame()

Converts the triangles in this mesh to line segments.
Has no effect if this mesh doesn't use triangles as primitives.

#### Return Value

This object. (Type: MeshBuffer)

<a name='H3DU.GraphicsPath_xor'></a>
### H3DU.GraphicsPath#xor(path, [flatness])

Computes the shape contained in either this path or another path,
but not both. The points given in the GraphicsPath#union method
apply to this method.

#### Parameters

* `path` (Type: GraphicsPath)<br>A path to combine with this one.
* `flatness` (Type: number) (optional)<br>When curves and arcs are decomposed to line segments, the segments will be close to the true path of the curve by this value, given in units. If null, undefined, or omitted, default is 1.

#### Return Value

A path whose shape is contained in
only one of the two paths. (Type: GraphicsPath)

[Back to documentation index.](index.md)
